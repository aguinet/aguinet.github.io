<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://aguinet.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://aguinet.github.io/" rel="alternate" type="text/html" hreflang="en" /><updated>2025-09-28T16:42:06+02:00</updated><id>https://aguinet.github.io/feed.xml</id><subtitle></subtitle><entry><title type="html">Breaking decryption.ch: the CTF that wasn’t meant to be</title><link href="https://aguinet.github.io/blog/2022/01/30/decryption-ch.html" rel="alternate" type="text/html" title="Breaking decryption.ch: the CTF that wasn’t meant to be" /><published>2022-01-30T00:00:00+01:00</published><updated>2022-01-30T00:00:00+01:00</updated><id>https://aguinet.github.io/blog/2022/01/30/decryption-ch</id><content type="html" xml:base="https://aguinet.github.io/blog/2022/01/30/decryption-ch.html"><![CDATA[<p>This article is a write up regarding the challenge published on
<a href="https://decryption.ch">decryption.ch</a> by the <a href="https://ex0-sys.com/">Ex0-Sys</a> company. Even if I resolved
it in 2019, it took me a bit of time and motivation to write and finalize that
blog post. Better late than never, as they say.</p>

<p>Anyway, this post describes how the challenge has been broken, from reverse
engineering the software to actually decrypting the provided <em>secure</em> container.</p>

<p>The source code that breaks the challenge is <a href="https://github.com/aguinet/alphatav">available on
Github</a>.</p>

<p class="figure"><img src="/assets/2022-01-30-decryption-ch/bounty.jpg" alt="" class="center-image" />
A screenshot of the <a href="https://decryption.ch">decryption.ch</a> web site</p>

<h1 id="the-alphatav-software">The AlphaTav software</h1>

<p>The challenge is about assessing the cryptography strength of the <a href="https://alpha-tav-vault.com">AlphaTav
software</a>. This software claims various security properties:</p>

<ul>
  <li>being quantum resistant</li>
  <li>time limitation</li>
  <li>destruction on bad credentials</li>
  <li>computer hardware restriction (based on a technology named <a href="https://www.alpha-tav-vault.com/documentation/#uid">Ex0-UiD</a>)</li>
  <li>final encryption key up to 87000 bits</li>
  <li>over encryption with <em>conventional</em> algorithms (AES256/3DES/RC2)</li>
</ul>

<p>Some of these properties (like time limitation &amp; destruction on bad
credentials) are “enforced” by the AlphaTav client itself. As you might
imagine, this holds as long as you don’t have any other code that would
implement the same algorithm.</p>

<p>Moreover, the AlphaTav software has multiple particularities that need to be
defined in order to make the rest of the writeup easier to follow:</p>

<ul>
  <li>a container is separated into four files:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">ATK3</code>: a file that contains settings (e.g. used algorithms, time restriction &amp; so on) and some key material</li>
      <li><code class="language-plaintext highlighter-rouge">ATD</code>/<code class="language-plaintext highlighter-rouge">ATK1</code>/<code class="language-plaintext highlighter-rouge">ATK2</code>: encrypted data split in three parts</li>
    </ul>
  </li>
  <li>multiple raw key materials: password &amp; PIN code.</li>
  <li>multiple levels of security:
    <ul>
      <li><a href="https://www.alpha-tav-vault.com/documentation/#level1">level 1</a>: only the <a href="#the-fragmentation-algorithm-atdatk1atk2">fragmentation algorithm</a> is used to “encrypt” <sup id="fnref:1"><a href="#fn:1" class="footnote" rel="footnote" role="doc-noteref">1</a></sup> data.</li>
      <li><a href="https://www.alpha-tav-vault.com/documentation/#level2">level 2</a>: level 1 with a random “PIN code” (see below) as key material <sup id="fnref:2"><a href="#fn:2" class="footnote" rel="footnote" role="doc-noteref">2</a></sup></li>
      <li><a href="https://www.alpha-tav-vault.com/documentation/#level3">level 3</a>: level 2, with an additional user password as key material</li>
    </ul>
  </li>
</ul>

<p>Surprisingly enough, and as we will see in the sections below, the Exo-UID
isn’t used as key material and is just a test performed by the decryption
process that verifies that the expected hardware is present (see previous
remark on time limit). Moreover:</p>

<ul>
  <li>the PIN code is a 16-byte random buffer saved as a bar code. It is generated
by the software when encrypting, and is needed to decrypt.</li>
  <li>the password is optional and provided by the user.</li>
</ul>

<p>We’ll discuss the various claims in the following sections. Let’s now take a
look at the actual challenge.</p>

<h1 id="the-challenge-material">The challenge material</h1>

<p>We are provided with:</p>

<ul>
  <li>a 460MB container encrypted with:
    <ul>
      <li>Vault level 3 (4 files, PIN code, password)</li>
      <li>Hardware restrictions (4 USB keys + various computers)</li>
      <li>Time limitation</li>
      <li>Destruction on bad credentials</li>
    </ul>
  </li>
  <li>the AlphaTav version used to make this container, as a Windows installer</li>
  <li>a free 30 days licence on demand</li>
</ul>

<p>What we <strong>don’t</strong> have:</p>

<ul>
  <li>The password used to encrypt this container</li>
  <li>The generated PIN-code</li>
</ul>

<p>If we manage to decrypt the container, we are supposed to find a video with the
instructions to validate the challenge.</p>

<h1 id="methodology">Methodology</h1>

<p>So we have to crack an encrypted container, without the raw key material that
was used to create it, and without a description of the proprietary algorithm
that has been used. The methodology I use for these cases is somehow always the
same:</p>

<ul>
  <li>reverse engineer the application to understand the underlying algorithms and/or file formats</li>
  <li>reimplement an encryption and/or decryption tool it in a language that
allows fast prototyping and provides a cryptography toolbox with the usual
primitives (in this case Python has been used)</li>
  <li>create a container similar to the one of the challenge, but whose original
content is known (can help figuring out implementation errors)</li>
  <li>emit hypothesis about potential cryptographic vulnerabilities</li>
  <li>play with our implementation and container to prototype attacks and
(in)validate the previous hypothesis</li>
  <li>repeat until it works, or until we can demonstrate that it will require a
bruteforce we won’t be able to perform</li>
</ul>

<p>In this case, I started to understand the decryption routine, but doing so with
the encryption one would also work. Per design, you should be able to derive
one from the other.</p>

<p>One of the hardest part in this is the reverse engineering job to
create a third party implementation we can toy with. We need to be rigorous
here, as a minor mistake in the algorithm reversing/implementation can be hard
to detect and cause potentially valid attacks to fail. One way to make this not
too much of a pain is to extract as much test vectors as possible from the
original application for every step of the algorithm (e.g. using a debugger),
and use these vectors to validate our custom implementation.</p>

<p>So let’s go through all these steps!</p>

<h1 id="reverse-engineering">Reverse engineering</h1>

<p>The only thing in our possession to figure out the encryption algorithm(s) is
the AlphaTav software, which is an obfuscated .Net application. We can also
gather public information about what is supposed to happen at least on a high
level view:</p>

<p><img src="/assets/2022-01-30-decryption-ch/official_workflow.jpg" alt="" class="center-image" /></p>

<h2 id="deobfuscation--debugging">Deobfuscation / debugging</h2>

<p>In order to do a first static analysis, we used the very efficient
<a href="https://github.com/0xd4d/de4dot">de4dot</a> software, which can deobfuscate a large variety of protectors.</p>

<p>Fortunately for us, <a href="https://github.com/0xd4d/de4dot">de4dot</a> detects that the AlphaTav software has
been obfuscated with CryptoObfuscator… twice.  Indeed, some libraries also
have to be deobfuscated again, still using <a href="https://github.com/0xd4d/de4dot">de4dot</a>.</p>

<p>What’s nice about this tool is that it can generate a proper binary that just
runs. So we can now use <a href="https://github.com/0xd4d/dnSpy">dnSpy</a> to debug and analyze the software.</p>

<p>Now that we are in a more comfortable position, our main goal was to follow
two <em>data flows</em>: the one that starts from clear data to encrypted data, and the
one that starts from raw key material (the password / PIN code) to whatever
derivations might happen, all towards the convergence of these two <em>flows</em> to
the final encrypted data.</p>

<h2 id="the-decryption-algorithm">The decryption algorithm</h2>

<p>After tedious reading of .Net code, and some debugging session to be sure
everything was correctly understood, here is a scheme of the decryption
algorithm as understood after reverse engineering:</p>

<p><img src="/assets/2022-01-30-decryption-ch/decrypt_algo.svg" alt="" class="center-image" /></p>

<p>This is a bit huge, so let’s discuss the various parts of this algorithm.</p>

<h3 id="the-fragmentation-algorithm-atdatk1atk2">The fragmentation algorithm (<code class="language-plaintext highlighter-rouge">ATD</code>/<code class="language-plaintext highlighter-rouge">ATK1</code>/<code class="language-plaintext highlighter-rouge">ATK2</code>)</h3>

<p>The AlphaTav fragmentation algorithm is an encoding process that splits a byte
into three different values. In the AlphaTav software, each of these values are
stored in different files:</p>

<ul>
  <li>AlphaTav (<code class="language-plaintext highlighter-rouge">AT</code>), stored in <code class="language-plaintext highlighter-rouge">ATK1</code></li>
  <li>Block sizes (<code class="language-plaintext highlighter-rouge">BS</code>), stored in <code class="language-plaintext highlighter-rouge">ATK2</code>. This file <strong>is not encrypted</strong>.</li>
  <li>Bit indexes (<code class="language-plaintext highlighter-rouge">BI</code>), stored in <code class="language-plaintext highlighter-rouge">ATD</code></li>
</ul>

<p>Here is a Python code describing how an 8-bit value is encoded:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">EncodedData</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">V</span><span class="p">):</span>
        <span class="n">BC</span> <span class="o">=</span> <span class="nc">BitCount</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">AT</span> <span class="o">=</span> <span class="p">(</span><span class="n">BC</span> <span class="o">==</span> <span class="mi">8</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">BC</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">BC</span> <span class="o">&lt;=</span> <span class="mi">4</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">V</span> <span class="o">==</span> <span class="mh">0xFF</span> <span class="ow">or</span> <span class="n">V</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">self</span><span class="p">.</span><span class="n">BS</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">self</span><span class="p">.</span><span class="n">BS</span> <span class="o">=</span> <span class="n">BC</span> <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">AT</span> <span class="nf">else </span><span class="p">(</span><span class="mi">8</span><span class="o">-</span><span class="n">BC</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">BI</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">V</span> <span class="o">!=</span> <span class="mh">0xFF</span> <span class="ow">and</span> <span class="n">V</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">reversed</span><span class="p">(</span><span class="nf">range</span><span class="p">(</span><span class="mi">8</span><span class="p">)):</span>
                <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="n">V</span> <span class="o">&gt;&gt;</span> <span class="n">i</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span>
                <span class="nf">if </span><span class="p">(</span><span class="nf">int</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">AT</span><span class="p">)</span> <span class="o">==</span> <span class="n">b</span><span class="p">):</span>
                    <span class="n">self</span><span class="p">.</span><span class="n">BI</span> <span class="o">=</span> <span class="mi">10</span><span class="o">*</span><span class="n">self</span><span class="p">.</span><span class="n">BI</span> <span class="o">+</span> <span class="p">(</span><span class="mi">7</span><span class="o">-</span><span class="n">i</span><span class="p">)</span>
</code></pre></div></div>

<p>And a few examples:</p>

<table>
  <thead>
    <tr>
      <th>V</th>
      <th>bin(V)</th>
      <th>Bit count</th>
      <th>AT</th>
      <th>BS</th>
      <th>BI</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0x07</td>
      <td>0b00000111</td>
      <td>3</td>
      <td>1</td>
      <td>3</td>
      <td>567</td>
    </tr>
    <tr>
      <td>0xAF</td>
      <td>0b10101111</td>
      <td>6</td>
      <td>0</td>
      <td>2</td>
      <td>13</td>
    </tr>
    <tr>
      <td>0x2F</td>
      <td>0b00101111</td>
      <td>5</td>
      <td>0</td>
      <td>3</td>
      <td>13</td>
    </tr>
    <tr>
      <td>0x00</td>
      <td>0b00000000</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <td>0xFF</td>
      <td>0b11111111</td>
      <td>8</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
    </tr>
  </tbody>
</table>

<p>Some points worth mentioning for what’s next:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">AT</code> is just one bit wide, and is stored as a bitstream in ATK1</li>
  <li><code class="language-plaintext highlighter-rouge">BS</code> is basically the number of bits at one or zero, depending on <code class="language-plaintext highlighter-rouge">AT</code>
(except for <code class="language-plaintext highlighter-rouge">0x00</code> and <code class="language-plaintext highlighter-rouge">0xFF</code>). It is stored as packed 4 bit numbers.</li>
  <li><code class="language-plaintext highlighter-rouge">BI</code> is basically a base 10 encoding of the bits that are at one or zero
(depending on AT)</li>
</ul>

<p>Moreover, as you can see in the table above, the <code class="language-plaintext highlighter-rouge">BI</code> value can be bigger
than one byte. That being said, there is only 99 possible different values (run
<code class="language-plaintext highlighter-rouge">len(set(EncodedData(v).BI for v in range(256)))</code> to convince yourself). We
can thus encode this value on one byte, with a fixed substitution table to
recover the original value. Such a table is included in the AlphaTav software.
The important thing to remember here is that the MSB bit of an encoded <code class="language-plaintext highlighter-rouge">BI</code>
value will always be zero. This will be very important for what’s next.</p>

<h3 id="the-atk3-file">The ATK3 file</h3>

<p>This file is actually a TIFF image. It contains mainly two things:</p>

<ul>
  <li>
    <p>inside its copyright metadata: encryption key material used in various key
derivation process. The actual key used for the AES/3DES/RC2 algorithm is
derived from these information. The important point here is that
no user key material is necessary to compute this key.</p>
  </li>
  <li>
    <p>encoded inside the value of its green pixels (!): a serialized .Net object
containing information about the encryption algorithm used for <code class="language-plaintext highlighter-rouge">ATD</code>/<code class="language-plaintext highlighter-rouge">ATK1</code>/<code class="language-plaintext highlighter-rouge">ATK2</code>.
It also contains the various “restrictions”. This is encrypted with key material
derived from the copyright metadata above, so we are always able to decrypt
it.</p>
  </li>
</ul>

<p>Using a serialized .Net object doesn’t seem the best choice for
interoperability with non .Net platforms, and might also be <a href="https://github.com/pwntester/ysoserial.net">a security
risk</a>.</p>

<p>Moreover, as we just said, deserializing a .Net object from something else than
a .Net virtual machine is not that trivial. I’ve built a
<a href="https://construct.readthedocs.io/en/latest/">construct</a>-based python module
for this, that does not support the whole format, but is enough for the need of
this challenge: <a href="https://github.com/aguinet/dotnetDeser">dotnetDeser</a>.</p>

<h3 id="keystream-derivation-process">Keystream derivation process</h3>

<p>What is called “keystream” is a fixed amount of bytes that is generated out of
many information, thanks to a <a href="https://en.wikipedia.org/wiki/PBKDF2">PBKDF2</a>
function:</p>

<ul>
  <li>the user password (if used any)</li>
  <li>the PIN code</li>
  <li>additional restriction information (e.g. hardware ones), that you can just
gather from <a href="#the-atk3-file">ATK3</a></li>
</ul>

<p>The length of this keystream depends on the length <code class="language-plaintext highlighter-rouge">L</code> of the user password.
The formula is <code class="language-plaintext highlighter-rouge">#(KS) = clamp(100*L, 1024, 131072)</code>.</p>

<p>The user password and PIN code, among with information extracted from
<a href="#the-atk3-file">ATK3</a>, are used to generate something called a “factor table”.
We don’t really need to understand that part to crack the challenge, so it will
be left aside for the sake of consistency.</p>

<p>This factor table, along with the additional restriction, are all mixed
together through a PBDKF2 function to finally generate the keystream. It is
interesting to note that a first version that I have reversed directly used the
“factor table” as a keystream (and that’s why the keystream is still called
“factor table” in various places of the PoC code).</p>

<p>Obviously, in these information, we don’t have the user password and the PIN
code, so no direct way to regenerate that keystream.</p>

<p>It is also important to notice that, once we have this keystream, we can fully
retrieve the encrypted zip. Indeed, it gives the IV for the AES/3DES/RC2
algorithms, and their key is already known thanks to <a href="#the-atk3-file">ATK3</a>.</p>

<h1 id="the-cracking-algorithm">The cracking algorithm</h1>

<h2 id="keystream-reuse-and-retrieval">Keystream reuse and retrieval</h2>

<p>That being said, the main vulnerability in this design is that this <strong>fixed
length</strong> keystream is reused multiple times to XOR data, and not only inside
the same file, but also accross <code class="language-plaintext highlighter-rouge">ATD</code> &amp; <code class="language-plaintext highlighter-rouge">ATK1</code> (<code class="language-plaintext highlighter-rouge">ATK2</code> isn’t XORed with this
keystream).</p>

<p>Let’s take a closer look at how this keystream is used:</p>

<p><img src="/assets/2022-01-30-decryption-ch/decrypt_algo_ks.svg" alt="" class="center-image" /></p>

<p>Before trying to exploit known clear text to recover that keystream, we need to
be able to decrypt and <em>ungzip</em> <code class="language-plaintext highlighter-rouge">ATD</code>/<code class="language-plaintext highlighter-rouge">ATK1</code>/<code class="language-plaintext highlighter-rouge">ATK2</code>. According to our scheme, they
are encrypted using either AES, 3DES or RC2 in CBC mode. The key is known
(derived from information in <a href="#the-atk3-file">ATK3</a>), but the IV is unknown, as
it is the first bytes of the keystream we are trying to recover. But let’s take
a look at how CBC work:</p>

<p class="figure"><img src="/assets/2022-01-30-decryption-ch/CBC_decr.svg" alt="" class="center-image" />
From <a href="https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Cipher_block_chaining_(CBC)">Wikipedia</a></p>

<p>Not knowing the IV only makes the first block unavailable. In the case of AES,
it is thus 16 bytes. In the case of 3DES or RC2, it is 8 bytes. Now, let’s take
a look at what a GZip file looks like, to see what we lose:</p>

<p class="figure"><img src="/assets/2022-01-30-decryption-ch/gzip.svg" alt="" class="center-image" />
Scheme by <a href="https://github.com/corkami">Corkami</a></p>

<p>In our cases, the first 8 bytes are, for instance:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">1F 8B</code>: header</li>
  <li><code class="language-plaintext highlighter-rouge">08</code>: use DEFLATE (always the case)</li>
  <li><code class="language-plaintext highlighter-rouge">00</code>: no flags (so no filename)</li>
  <li><code class="language-plaintext highlighter-rouge">66 59 59 3A</code>: timestamp (we don’t care)</li>
</ul>

<p>So, if <code class="language-plaintext highlighter-rouge">ATD</code>, <code class="language-plaintext highlighter-rouge">ATK1</code> or <code class="language-plaintext highlighter-rouge">ATK2</code> is encrypted using 3DES or RC2, then we can
fully decompress the underlying DEFLATE stream. In the case of AES, we miss the
first 8 bytes of the actual DEFLATE stream. <a href="#incomplete-gzip-streams">The end of this blog post
</a> describes how we can still recover almost all the
decompressed data even in this case. Note that, for the actual challenge
container, this is not really an issue as none of the files are encrypted with
AES (did someone say this was a CTF?).</p>

<p>With all these information in mind, let’s formalize a bit the cracking
algorithm.</p>

<h3 id="hunting-for-known-plaintext">Hunting for known plaintext</h3>

<p>Let’s consider we are able to ungzip <code class="language-plaintext highlighter-rouge">ATD</code>, <code class="language-plaintext highlighter-rouge">ATK1</code> and <code class="language-plaintext highlighter-rouge">ATK2</code>. The only
remaining unknown information is still the <strong>fixed length</strong> keystream (now
named <code class="language-plaintext highlighter-rouge">KS</code>). As it is reused within the same file and for <code class="language-plaintext highlighter-rouge">ATD</code> &amp; <code class="language-plaintext highlighter-rouge">ATK1</code> with
a XOR operator, knowning the data that has been fed to the <a href="#the-fragmentation-algorithm-atdatk1atk2">fragmentation
algorithm</a> will give us known <em>Bit
Indexes</em> (<code class="language-plaintext highlighter-rouge">BI</code>) and <em>AlphaTav</em> (<code class="language-plaintext highlighter-rouge">AT</code>) clear values, and hence known bits of <code class="language-plaintext highlighter-rouge">KS</code>.
The scheme below describes this attack:</p>

<p><img src="/assets/2022-01-30-decryption-ch/attack.svg" alt="" class="center-image" /></p>

<p>So let’s hunt for known data!</p>

<p>The first thing to notice is that the data that are fed to the <a href="#the-fragmentation-algorithm-atdatk1atk2">fragmentation
algorithm</a> are not the actual user
files, but an encrypted zip version of them.  We don’t need the password of
this zip for now, even if it can be derived <a href="#the-zip-password">straight from
ATK3</a>. The important parts are:</p>

<ul>
  <li>we can guess some known values from the zip format specification</li>
  <li>it is an encrypted and compress stream, so the values of this zip file can
be considered as random ones</li>
</ul>

<h4 id="thanks-to-the-zip-format">Thanks to the zip format</h4>

<p>Let’s take a look at what a zip file look like:</p>

<p class="figure"><img src="/assets/2022-01-30-decryption-ch/zip.svg" alt="" class="center-image" />
Scheme by <a href="https://github.com/corkami">Corkami</a></p>

<p>As we can see from this scheme, there are some fixed signatures we can use as
known data. This is what we do as a first bootstrap step. In the case of the
challenge, this helps recover approximately 12% of the keystream.</p>

<h4 id="thanks-to-block-sizes-in-atk2">Thanks to block sizes (in ATK2)</h4>

<p>If we look carefully at the <a href="##the-decryption-algorithm">decryption scheme</a>, we
see that ATK2 isn’t xored with <code class="language-plaintext highlighter-rouge">KS</code>. This means we have direct access to the
<em>Block Sizes</em> (<code class="language-plaintext highlighter-rouge">BS</code>) part of the fragmented data. Moreover, one interesting
fact of the <a href="#the-fragmentation-algorithm-atdatk1atk2">fragmentation algorithm</a>
is that if <code class="language-plaintext highlighter-rouge">BS == 0</code>, then we can have only two original clear values:
<code class="language-plaintext highlighter-rouge">0x00</code> or <code class="language-plaintext highlighter-rouge">0xFF</code>. The discrimination is made thanks to the associated
<em>AlphaTav</em> (<code class="language-plaintext highlighter-rouge">AT</code>) bit.</p>

<p>Coupled with the fact that the fragmented data are the ones of an <a href="#the-decryption-algorithm">encrypted
zip stream</a>, it means that the probability of having
an original unfragmented value of <code class="language-plaintext highlighter-rouge">0x00</code> or <code class="language-plaintext highlighter-rouge">0xFF</code> is <code class="language-plaintext highlighter-rouge">2/256</code>. For big
containers that are a few megabytes, as we have already recovered a few bits
from <code class="language-plaintext highlighter-rouge">KS</code> thanks to the zip format (and thus some <code class="language-plaintext highlighter-rouge">AT</code> values), our
experiences show we usually manage to figure out enough <code class="language-plaintext highlighter-rouge">0x00</code> or <code class="language-plaintext highlighter-rouge">0xFF</code>
original values for the zip stream, and with them what remains of <code class="language-plaintext highlighter-rouge">KS</code>. In
the case of the challenge, the container is around 460Mb, so we have plenty of
data to run the attack and make it successful.</p>

<p>We can also notice that there is some form of “avalanche” effect, due to the
fact that <code class="language-plaintext highlighter-rouge">KS</code> is reused repeatedly across the same file, and across
<code class="language-plaintext highlighter-rouge">ATD</code>/<code class="language-plaintext highlighter-rouge">ATK1</code> &amp; <code class="language-plaintext highlighter-rouge">ATK2</code>. Indeed, if we manage to recover at least one new bit of
<code class="language-plaintext highlighter-rouge">KS</code> with this technique, it means we might recover new bits of <code class="language-plaintext highlighter-rouge">KS</code> by
just rerunning this part of the algorithm from the beginning, and so on.  In
the case of the challenge, only one run was necessary to fully recover <code class="language-plaintext highlighter-rouge">KS</code>
(as this is a relatively big container).</p>

<p>We also think there is an interesting math exercise that would compute the
probability of success of this attack given the size of the original container
(considering the number of already known <code class="language-plaintext highlighter-rouge">KS</code> bits).</p>

<h3 id="figuring-out-the-keystream-length">Figuring out the keystream length</h3>

<p>One thing we didn’t discuss yet is how to find the length of <code class="language-plaintext highlighter-rouge">KS</code>, which is,
as a reminder, <code class="language-plaintext highlighter-rouge">#(KS) = clamp(100*L, 1024, 131072)</code> (with <code class="language-plaintext highlighter-rouge">L</code> the length of
the user provided password, which is unknown).</p>

<p>One interesting thing we have noticed during the analysis of the <a href="#the-fragmentation-algorithm-atdatk1atk2">fragmentation
algorithm</a> is that the maximum value
for <code class="language-plaintext highlighter-rouge">AT</code> is <code class="language-plaintext highlighter-rouge">99</code>, so the MSB of <code class="language-plaintext highlighter-rouge">AT</code> will <strong>always be 0</strong>. So if we take
two different blocks of ATD data of length <code class="language-plaintext highlighter-rouge">N</code> whose index is aligned on
<code class="language-plaintext highlighter-rouge">N</code> bytes, and XOR-ing these two blocks gives at least one byte with its MSB
equals to 1, it means we have guessed a wrong value for <code class="language-plaintext highlighter-rouge">#(KS)</code>.</p>

<p>Moreover, reverse engineering the AlphaTav software shows that the password
length <code class="language-plaintext highlighter-rouge">L</code> is between 10 and 1310. So we have 1300 possibilities for <code class="language-plaintext highlighter-rouge">L</code>,
and thus for <code class="language-plaintext highlighter-rouge">#(KS)</code> (clamping does not change this), which is easily
<em>bruteforcable</em> with this technique.</p>

<p>Then, once we have figured out candidates for <code class="language-plaintext highlighter-rouge">#(KS)</code>, we verify that we don’t
find any inconsistencies while guessing clear texts. Indeed, if two clear texts
at various positions provides two different bits for <code class="language-plaintext highlighter-rouge">KS</code>, it means <code class="language-plaintext highlighter-rouge">#(KS)</code>
isn’t valid (considering there are no errors in the guessed clear texts).</p>

<p>In practice, we can crack the challenge with the first <code class="language-plaintext highlighter-rouge">L</code> value guessed.</p>

<h3 id="the-zip-password">The zip password</h3>

<p>The zip password is basically a number called <code class="language-plaintext highlighter-rouge">TimeKey</code> stored in the
serialized .Net object in <a href="#the-atk3-file">ATK3</a>. It is more precisely the base
8 representation of this number as a string. The important point is that it
does not depend on any user supplied key material, and so is always computable
given only <a href="#the-atk3-file">ATK3</a>.</p>

<h2 id="incomplete-gzip-streams">Incomplete GZip streams</h2>

<p>There’s this problem of incomplete GZip stream we left aside previously.</p>

<p>As a reminder, we are in a situation where we are missing the first 16 bytes of
a GZip file. As seen <a href="#keystream-reuse-and-retrieval">above</a>, a GZip file is
basically a wrapper around a compressed stream.
<a href="https://en.wikipedia.org/wiki/Deflate">DEFLATE</a> is the only one officially
supported, according to <a href="https://datatracker.ietf.org/doc/html/rfc1952">RFC
1952</a>. This is also the
algorithm used in the files generated by AlphaTav. So, in the end, what we are
missing is the beggining of the DEFLATE stream.</p>

<p>So let’s take a high-level view at DEFLATE streams:</p>

<p><img src="/assets/2022-01-30-decryption-ch/deflate_stream.svg" alt="" class="center-image" /></p>

<p>A DEFLATE stream is a <strong>bit</strong>-stream, built around blocks. Each block defines a
type of data, which is either raw/uncompressed data, or compressed Huffman
data using a static or dynamically computed tree.</p>

<p>To still decompress as much data as possible, the general idea is to first find
the bit index of the next block, and then decompress the DEFLATE stream
starting from this block. Doing this, it is important to note that one block
can point to data from the previous blocks, up to 32 kb. If such a thing happens,
we generate <em>unknown</em> bytes in the recovered stream. We thus end up with a
stream with unknown bytes at the beginning, and this can happen until
backtracking only points to known data. This is illustrated in the scheme
below:</p>

<p><img src="/assets/2022-01-30-decryption-ch/recovered_deflate.svg" alt="" class="center-image" /></p>

<p>Finding the bit index of the next block is done by bruteforcing it:</p>

<ol>
  <li>we start at bit <code class="language-plaintext highlighter-rouge">X</code> in the DEFLATE stream</li>
  <li>we launch a full decompression of the stream. If some data are found to be
incoherent, add 1 to <code class="language-plaintext highlighter-rouge">X</code> and go to 1.</li>
  <li>if we found the last block, make sure it is actually the end of the DEFLATE
stream. If not, add 1 to <code class="language-plaintext highlighter-rouge">X</code> and go to 1. Otherwise, the position of the next
valid block is <code class="language-plaintext highlighter-rouge">X</code>.</li>
</ol>

<p>Doing this, we manage to partially decompress the DEFLATE stream. The only
thing we don’t know is how much decompressed data are missing at the beginning.
We need this information, otherwise we can’t “align” <code class="language-plaintext highlighter-rouge">ATD</code>, <code class="language-plaintext highlighter-rouge">ATK1</code> and/or
<code class="language-plaintext highlighter-rouge">ATK2</code>. Fortunately (again), the GZip format provides, as its four last
bytes, the size of the original data (<code class="language-plaintext highlighter-rouge">DecompSize</code>). So, we have exactly
<code class="language-plaintext highlighter-rouge">DecompSize-PartialDecompSize</code> unknown bytes at the beginning of the partially
decompressed data.</p>

<p>To implement this algorithm, we tweaked the excellent <a href="https://www.nayuki.io/page/simple-deflate-decompressor">pure Python DEFLATE
implemention by Project
Nayuki</a>.</p>

<p>In practice, in the tests we’ve done, recovering the index of the next block
only takes a few seconds, and we manage to recover around 99.9% of the
decompressed data.</p>

<h1 id="cracking-the-challenge">Cracking the challenge</h1>

<p><a href="#the-challenge-material">As said previously</a>, the challenge is an AlphaTav
container. On the 2019-10-11, Ex0-Sys published the last (<code class="language-plaintext highlighter-rouge">ATK3</code>) of the four
files (<code class="language-plaintext highlighter-rouge">ATD</code>, <code class="language-plaintext highlighter-rouge">ATK1</code>, <code class="language-plaintext highlighter-rouge">ATK2</code>, <code class="language-plaintext highlighter-rouge">ATK3</code>), allowing us to launch our attack.</p>

<p>In this case, <code class="language-plaintext highlighter-rouge">ATD</code>/<code class="language-plaintext highlighter-rouge">ATK1</code>/<code class="language-plaintext highlighter-rouge">ATK2</code> are encrypted with, respectively,
RC2/3DES/3DES. We are thus lucky enough not to have to deal with the <a href="#incomplete-gzip-streams">partial
GZip stream issue</a>. Moreover, as the container
is 460MB, we had plenty of known bits to play with, and the keystream is
successfully retreived in less than a minute (what actually takes of the time
is decrypting and decompressing the <code class="language-plaintext highlighter-rouge">AT*</code> files in Python).</p>

<p>Once cracked, we are left with a zip file that contains a video to claim the
bounty, and another AlphaTav container named <code class="language-plaintext highlighter-rouge">Bounty Challenge BTC Wallet.at{d,k1,k2,k3}</code>.</p>

<h2 id="bonus-container-with-the-electrum-wallet">Bonus: container with the Electrum wallet</h2>

<p>Cracking the previous container was enough to claim the bounty, but we were
curious about this new container. Here, <code class="language-plaintext highlighter-rouge">ATD</code>/<code class="language-plaintext highlighter-rouge">ATK1</code>/<code class="language-plaintext highlighter-rouge">ATK2</code> are encrypted
with, respectively, AES256/AES256/3DES. We have thus to deal with the <a href="#incomplete-gzip-stream">partial
GZip stream issue</a>. Fortunately, our partial
decompression algorithm allows us to recover 99.9% of <code class="language-plaintext highlighter-rouge">ATD</code> and <code class="language-plaintext highlighter-rouge">ATK1</code>,
giving plenty of data to run our keystream recovery attack.</p>

<p>After cracking the container, we are left with an
<a href="https://electrum.org/">electrum</a> wallet, whose passphrase is unknown to us (at
that time).</p>

<h1 id="conclusion">Conclusion</h1>

<p>As stated in the title of this article, this somehow looked like a CTF, as for
every step of the algorithm there was always something possible to achieve to
move to the next one (e.g. having reliable clear text values thanks to the zip
format, being able to still retrieve partial DEFLATE streams, etc). The core of
the attack is the reuse of a fixed keystream to XOR various data, and
everything we do in the attack is about finding known clear/encrypted data to
recover that keystream. As a side note, we also haven’t seen any integrity
checks in the container, but might have missed it.</p>

<p>The Ex0-sys team was professional in handling their bounty program. They had
the real desire to improve their technology. That being said, I think this
proves once again that cryptosystem designs should be open and their
implementation easily reviewable by everyone. The only secrets should be
various key materials.</p>

<p>Kerckhoff was right, once again.</p>

<h1 id="timeline">Timeline</h1>

<ul>
  <li>2019-10-11: challenge broken in the morning (publication of the ATK3 file), sending of the proof by mail</li>
  <li>2019-10-11: acknowledgment by the ex0-sys team</li>
  <li>2019-10-13: sending of a PoC that decrypts the challenge</li>
  <li>2019-10-16: acknowledgment that the PoC works. ex0-sys also provides the wallet password.</li>
  <li>2019-10-21: authorization to present this work at a private conference in Paris</li>
  <li>[…]: procrastinating this blog post</li>
  <li>2021-01-30: publication of this blog post</li>
</ul>

<h1 id="acknowledgments">Acknowledgments</h1>

<p>I would like to thank <a href="https://twitter.com/angealbertini">Ange Albertini</a> for
providing the very nice Zip and GZip file format description images.</p>

<p>Also thanks to toffan, patate &amp; acid for reviewing this blog post!</p>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1">
      <p><a href="https://en.wikipedia.org/wiki/Kerckhoffs%27s_principle">Kerckhoff</a> might not agree on calling this encryption. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2">
      <p>Kerckhoff is happier with this one <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name>adrien_guinet</name></author><category term="blog" /><summary type="html"><![CDATA[This article is a write up regarding the challenge published on decryption.ch by the Ex0-Sys company. Even if I resolved it in 2019, it took me a bit of time and motivation to write and finalize that blog post. Better late than never, as they say.]]></summary></entry><entry><title type="html">Donjon CTF SSSGX write-up: linear functions strike back</title><link href="https://aguinet.github.io/blog/2020/11/22/donjon-ctf-sssgx.html" rel="alternate" type="text/html" title="Donjon CTF SSSGX write-up: linear functions strike back" /><published>2020-11-22T00:00:00+01:00</published><updated>2020-11-22T00:00:00+01:00</updated><id>https://aguinet.github.io/blog/2020/11/22/donjon-ctf-sssgx</id><content type="html" xml:base="https://aguinet.github.io/blog/2020/11/22/donjon-ctf-sssgx.html"><![CDATA[<p>This writeup presents a solution to the SSSGX Wallet stage of the <a href="https://donjon-ctf.io/">2020 Ledger
Donjon’s CTF</a>. It showcases a solution using a kind of generic
method to exploit the issues that we are facing in this challenge, which
can basically be reduced to solving a linear system in the vector space
\(\{0,1\}^N\).</p>

<p>We will first <a href="#introduction">describe the challenge</a>, then <a href="#figuring-out-the-problem-to-solve">the generic
problem to solve</a>, the <a href="#figuring-out-the-vulnerability">vulnerability to
exploit</a>, and finally <a href="#exploiting-the-vulnerability-and-solving-the-challenge">how to solve the
challenge</a> using
<a href="https://www.sagemath.org/">Sage</a> and <a href="https://github.com/aguinet/dragonffi/">DragonFFI</a>!</p>

<p>The full code of this solution is <a href="https://github.com/aguinet/donjonctf_sssgx">available
on Github</a>.</p>

<p><img src="/assets/2020-11-22-donjon-ctf-sssgx/sssgx_chall.png" alt="" class="center-image" /></p>

<h1 id="introduction">Introduction</h1>

<p>For this challenge, we had access to a web-browser based wallet service
(and its source code), on which we can create or restore accounts, and
digitally sign messages with that account.</p>

<p><img src="/assets/2020-11-22-donjon-ctf-sssgx/sssgx_create.png" alt="Create Wallet" class="center-image" /></p>

<p>This system also has the particularity of allowing the user to split the secret
associated to his account in three “shares”, and to send two of them
to two other persons, so that he’ll be able to recover his account if the three
shares are put back together.</p>

<p><img src="/assets/2020-11-22-donjon-ctf-sssgx/sssgx_restore.png" alt="Restore Wallet" class="center-image" /></p>

<p>In the challenge’s data, we are also given a copy of the local storage SQLite
database of a browser that has been using this service. Indeed, once
an account has been created on this platform, we can see that a “backup” local
storage entry appears, with information linked to our account.</p>

<p><img src="/assets/2020-11-22-donjon-ctf-sssgx/sssgx_backup_local_storage.png" alt="Local storage" class="center-image" /></p>

<p>The goal of the challenge is to retrieve the secret associated to that account.</p>

<p>As we have the source code, let’s take a look at it to understand what are
these data, especially the <code class="language-plaintext highlighter-rouge">backup</code> field.</p>

<h2 id="service-architecture">Service architecture</h2>

<p>The service has actually a quite interesting <a href="https://en.wikipedia.org/wiki/Software_Guard_Extensions">Intel SGX</a>-based
architecture. What happens when an account is created is:</p>

<ul>
  <li>a random 32-bytes secret \(S\) is generated in an SGX container. It is later used
to sign messages using <a href="https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm">ECDSA</a></li>
  <li>this secret is encrypted and authenticated in the very same container, alongside with
the email information and the users’ PIN</li>
  <li>the result is sent back to the user that stores it in its browser local
storage</li>
</ul>

<p>When a user asks to sign a message, he has to enter its PIN. The complete
request, containing the message, the PIN and the encrypted backup, is forwarded
to the SGX container, which:</p>

<ul>
  <li>decrypts the backup</li>
  <li>verifies the users’ PIN</li>
  <li>signs the message</li>
</ul>

<p>The signature is then sent back to the user.</p>

<p>If the user wants to send its shares to two of his friends, he just send his
encrypted backup alongside with the two recipients’ mail address. This is the
only API we can use with the backup that have been provided in the challenge,
because the PIN isn’t requested and checked here.</p>

<h1 id="figuring-out-the-problem-to-solve">Figuring out the problem to solve</h1>

<h2 id="what-data-do-we-have">What data do we have</h2>

<p>It looks like solving this challenge would imply using the two shares that the
server is willing to send us. Using the SQLite database we are provided with,
we inject it into the browser of our choice, and ask the interface to send the
shares to two email addresses we control:</p>

<p><img src="/assets/2020-11-22-donjon-ctf-sssgx/sssgx_share.png" alt="Send shares" class="center-image" /></p>

<p>For the sake of history, the two resulting shares are available in the
<a href="https://github.com/aguinet/donjonctf_sssgx/blob/main/shares.txt">repository of the
solution</a>.</p>

<p>Now, let’s go back to the code and look at the “data flow” between our victim’s
secret (what we are looking for) and the two shares we have. Given the name of
the challenge, we are expecting to find some sharing scheme, like the <a href="https://en.wikipedia.org/wiki/Shamir%27s_Secret_Sharing">Shamir’s
Secret Sharing (SSS)</a> one.</p>

<h2 id="what-function-computes-them">What function computes them</h2>

<p>We are interested in isolating the function that computes these two shares
from the original secret.</p>

<p>From the code, in the file <code class="language-plaintext highlighter-rouge">src/wallet/libwallet/Enclave/Enclave.cpp</code>, the
function <code class="language-plaintext highlighter-rouge">share_user_seed</code> looks interesting. It is indeed declared as a
“public endpoint” of the enclave in
<code class="language-plaintext highlighter-rouge">src/wallet/libwallet/Enclave/Enclave.edl</code>, is wrapped in the function
<code class="language-plaintext highlighter-rouge">wallet_share_seed</code>, which itself is called by the Node.js server by the <code class="language-plaintext highlighter-rouge">/share</code>
public REST API, all through of bunch of bindings we don’t describe here. The
shares we got by email have thus been generated by the <code class="language-plaintext highlighter-rouge">share_user_seed</code>
function, which looks like this (stripped down for readability):</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sgx_status_t</span> <span class="nf">share_user_seed</span><span class="p">(</span><span class="n">share_t</span> <span class="n">contact_shares</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">blob</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">blob_size</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">password</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">email1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">email2</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">sgx_status_t</span> <span class="n">status</span><span class="p">;</span>
    <span class="n">sss_Share</span> <span class="n">shares</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
    <span class="n">user_data_t</span> <span class="n">user_data</span><span class="p">;</span>
    <span class="kt">uint8_t</span> <span class="n">entropy</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>

    <span class="c1">// No need to check the password, as one share will always be sent to the owner email address.</span>
    <span class="c1">// We can assume access to the mail account is enough.</span>
    <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">password</span><span class="p">;</span>

    <span class="n">unseal_user_data</span><span class="p">(</span><span class="n">blob</span><span class="p">,</span> <span class="n">blob_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">user_data</span><span class="p">);</span>
    <span class="n">sgx_read_rand</span><span class="p">(</span><span class="n">entropy</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">entropy</span><span class="p">));</span>
    <span class="n">randominit</span><span class="p">(</span><span class="n">entropy</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">entropy</span><span class="p">));</span>

    <span class="kt">uint8_t</span> <span class="n">msg</span><span class="p">[</span><span class="n">sss_MLEN</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">user_data</span><span class="p">.</span><span class="n">key</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">user_data</span><span class="p">.</span><span class="n">key</span><span class="p">));</span>
    <span class="n">sss_create_shares</span><span class="p">(</span><span class="n">shares</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span> 

    <span class="p">[...]</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="n">contact_shares</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">data</span><span class="p">,</span> <span class="n">shares</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">sss_SHARE_LEN</span><span class="p">);</span>
    <span class="p">}</span>   
    <span class="k">return</span> <span class="n">SGX_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>It is indeed using <a href="https://en.wikipedia.org/wiki/Shamir%27s_Secret_Sharing">Shamir’s Secret Sharing (SSS)</a> protocol, splitting
the secret in three shares and requiring the three of them to recover the
secret.  The core function that creates these shares is <code class="language-plaintext highlighter-rouge">sss_create_shares</code>,
which is from the <a href="https://github.com/dsprenkels/sss">sss library</a> by <a href="https://dsprenkels.com/">Daan
Sprenkels</a>.  This function takes as input the user’s
secret key (which we are interested in), and returns three shares. Given these
three shares, it is possible to do the inverse operation, <em>i.e.</em> recompute the
original user’s secret. As a reminder, we only have two of these shares.</p>

<h2 id="shamirs-secret-sharing-and-its-implementation-in-sss">Shamir’s Secret Sharing, and its implementation in <a href="https://github.com/dsprenkels/sss">sss</a></h2>

<p><a href="https://en.wikipedia.org/wiki/Shamir%27s_Secret_Sharing">Shamir’s Secret Sharing</a> scheme is a <a href="https://en.wikipedia.org/wiki/Secret_sharing">secret
sharing</a> scheme. The goal is to
share a secret between \(n\) participants, and require at least \(k\)
participants to retrieve it.</p>

<p><a href="https://en.wikipedia.org/wiki/Shamir%27s_Secret_Sharing">SSS</a> implements this using polynomials. This is best described by the
<a href="https://en.wikipedia.org/wiki/Shamir%27s_Secret_Sharing#Shamir's_secret_sharing_scheme">Wikipedia’s
article</a>
on the matter:</p>

<blockquote>
  <p>The essential idea of Adi Shamir’s threshold scheme is that 2 points are
sufficient to define a line, 3 points are sufficient to define a parabola, 4
points to define a cubic curve and so forth. That is, it takes \(k\) points to
define a polynomial of degree \(k-1\).</p>
</blockquote>

<p>The degree of the polynomial \(P\) will thus be \(k-1\). We embed the secret into
this polynomial, for instance by setting its constant coefficient \(P(0)\) to the
secret, and the rest to random values. We then evaluate this polynomial in
\(N\) points, and share a different \((i,P(i))\) pair with each of the \(K\)
participants. If we know \(K\) shares, we can retrieve the full polynomial
using interpolation, and hence retrieve the secret.</p>

<p>In the case of our challenge, for one secret, the <a href="https://github.com/dsprenkels/sss">sss</a> library uses
32 polynomials with coefficients in the \(GF(2^8)\) space (which are themselves
polynomials). According to the <a href="https://github.com/dsprenkels/sss/blob/v0.1.0/hazmat.c#L93">source code of the
library</a>,
multiplication in \(GF(2^8)\) is reduced by this polynom: \(x^8 + x^4 + x^3 + x + 1\).
This means that, for this challenge, shares are polynomials, as
well as coefficients of the Shamir polynomial.</p>

<p>Moreover, for one secret, it uses 32 Shamir polynomials, because one Shamir
polynomial with coefficients in \(GF(2^8)\) can only <em>store</em> a secret of one byte
(aka 8 bits). Indeed, as we will <a href="#understanding-the-share-format">see below</a>,
the library encrypts the secret with a random 32-byte encryption key (which then
is the actual shared secret), hence the 32 polynomials.</p>

<h3 id="bitslicing">Bitslicing</h3>

<p>In order to make computations with these 32 polynomials efficient, the library
uses a technique called <em>bitslicing</em>. Instead of working with 32x8-bit integers
(each integer representing a polynomial over \(GF(2^8)\), it works with
8x32-bit integers. Each 32-bit integers representing the same coefficient of
the 32 polynomials. Thus, we can do 32 polynomials computation at once.</p>

<p>This bitslicing transformation can be seen as a transposition of the original
32x8 bit matrix, which is a linear operation in \(GF(2)^N\) (this is important
for what’s next).</p>

<h2 id="understanding-the-share-format">Understanding the share format</h2>

<p>The <a href="https://github.com/dsprenkels/sss/#technical-details">sss library’s
README</a> explains a little
bit what happens in the
<a href="https://github.com/dsprenkels/sss/blob/v0.1.0/sss.c#L61"><code class="language-plaintext highlighter-rouge">sss_create_shares</code></a>
function. Basically, a random 32-bytes key \(K\) is computed, then used to encrypt
and authenticate the original secret \(S\) with <a href="https://github.com/jedisct1/libsodium">libsodium</a>’s
<code class="language-plaintext highlighter-rouge">crypto_secretbox</code> function. The rational behind this is explained in the
aforementioned README.</p>

<p>The <a href="https://en.wikipedia.org/wiki/Shamir%27s_Secret_Sharing">SSS</a> algorithm is then applied on the key \(K\), creating in
our case three shares. The share values can then be used in the
<code class="language-plaintext highlighter-rouge">sss_combine_shares</code>, which recovers the key \(K\), and uses
<a href="https://github.com/jedisct1/libsodium">libsodium</a>’s <code class="language-plaintext highlighter-rouge">crypto_secretbox_open</code> to verify the integrity of the
encrypted data and recover the original secret \(S\).</p>

<p>Regarding the share format, analyzing the library’s source code teaches us
that the result of the <a href="https://en.wikipedia.org/wiki/Authenticated_encryption#Authenticated_encryption_with_associated_data_(AEAD)">Authenticated Encryption with Associated Data
(AEAD)</a>
of \(S\) with \(K\) is concatenated to every share. Moreover, each share, at
its beginning, have its share index encoded in one byte.</p>

<p>So, the final format of a share is:</p>

<ul>
  <li>First byte: share index (from 1 to 3 in our case)</li>
  <li>Next 32 bytes: the actual share value (representing the 32 polynomials)</li>
  <li>Remaining bytes: basically the output of <code class="language-plaintext highlighter-rouge">crypto_secretbox</code>, that encrypts
&amp; authenticate our original secret \(S\) with the random key \(K\)</li>
</ul>

<p>What we got from the server is a Base64 encoding of this. If we indeed take a
closer look at the two shares we received, we can see that the last bytes are
the same.</p>

<h2 id="the-problem-to-solve">The problem to solve</h2>

<p>With all these information, we can say that the problem to solve can be
summarized as such:</p>

<ul>
  <li>given two known shares \((KS_1,KS_2)\) (among the
original three shares \((KS_0,KS_1,KS_2)\)) of a secret (in our case the
encryption key \(K\))</li>
  <li>and given the function \(F(K) = (KS_0,KS_1,KS_2)\),</li>
</ul>

<p>can we retrieve \(K\) by only having \((KS_1,KS_2)\)?</p>

<p><em>Note: Once we got \(K\), we just need to use <a href="https://github.com/jedisct1/libsodium">libsodium</a> to retrieve the
original secret \(S\).</em></p>

<h2 id="bibliography">Bibliography</h2>

<p>This challenge has a very strong resemblance to this <a href="https://donjon.ledger.com/Stealing-all-HTC-Exodus-users/">recent blog post</a>,
and given that Jean-Baptiste Bédrune is now head of security of the Ledger’s
Donjon, this might not be just a coincidence :)</p>

<h1 id="figuring-out-the-vulnerability">Figuring out the vulnerability</h1>

<p>In theory, if <a href="sss_wiki">SSS</a> is properly implemented, that it isn’t possible to
recover this secret with only two shares out of the three. So there must be
some kind of vulnerability in the implementation of this scheme.</p>

<p>We can notice that a customized version of the <a href="https://github.com/dsprenkels/sss">sss</a> library
has been used. If we look at the differences, we can see that the major ones
are in the <code class="language-plaintext highlighter-rouge">randombytes.cpp</code> file. Here is part of its implementation:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define RANDOM_POOL_SIZE 128
</span><span class="k">static</span> <span class="kt">uint8_t</span> <span class="n">random_pool</span><span class="p">[</span><span class="n">RANDOM_POOL_SIZE</span><span class="p">];</span>

<span class="kt">void</span> <span class="nf">randominit</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">entropy</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">sgx_sha256_hash_t</span> <span class="n">digest</span><span class="p">;</span>
  
  <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">random_pool</span><span class="p">;</span>
  <span class="n">sgx_sha256_msg</span><span class="p">((</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">entropy</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="n">size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">digest</span><span class="p">);</span>

  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">digest</span><span class="p">,</span> <span class="n">SGX_SHA256_HASH_SIZE</span><span class="p">);</span>
    <span class="n">sgx_sha256_msg</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">SGX_SHA256_HASH_SIZE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">digest</span><span class="p">);</span>
    <span class="n">p</span> <span class="o">+=</span> <span class="n">SGX_SHA256_HASH_SIZE</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">randombytes</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>  

  <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="n">RANDOM_POOL_SIZE</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">random_pool</span><span class="p">,</span> <span class="n">RANDOM_POOL_SIZE</span><span class="p">);</span>
    <span class="n">data</span> <span class="o">+=</span> <span class="n">RANDOM_POOL_SIZE</span><span class="p">;</span>
    <span class="n">n</span> <span class="o">-=</span> <span class="n">RANDOM_POOL_SIZE</span><span class="p">;</span>
  <span class="p">}</span>  
  <span class="n">memcpy</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">random_pool</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span> 
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>One issue here is that the <code class="language-plaintext highlighter-rouge">randombytes</code> function will always return the
same bytes (looping over a buffer of 128 bytes). This means that, if we call
twice the <code class="language-plaintext highlighter-rouge">randombytes</code> function to get, say, 32 bytes, we get twice the
same random 32 bytes. Let’s see where this is used and how we can exploit this.</p>

<h2 id="constant-randomness-usage">Constant randomness usage</h2>

<h3 id="usage-1">Usage 1</h3>

<p>The first place where <code class="language-plaintext highlighter-rouge">randombytes</code> is used is
<a href="https://github.com/dsprenkels/sss/blob/v0.1.0/sss.c#L73"><code class="language-plaintext highlighter-rouge">sss_create_keyshares</code></a>.
The <code class="language-plaintext highlighter-rouge">randombytes</code> function is thus used
to compute the 32-bytes key that encrypts the data to share (see above).</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">sss_create_shares</span><span class="p">(</span><span class="n">sss_Share</span> <span class="o">*</span><span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
                       <span class="kt">uint8_t</span> <span class="n">n</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">k</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// ...</span>
  <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">key</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
  <span class="cm">/* Generate a random encryption key */</span>
  <span class="n">randombytes</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">key</span><span class="p">));</span>

  <span class="cm">/* AEAD encrypt the data with the key */</span>
  <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">[</span><span class="n">crypto_secretbox_ZEROBYTES</span><span class="p">],</span> <span class="n">data</span><span class="p">,</span> <span class="n">sss_MLEN</span><span class="p">);</span>
  <span class="n">crypto_secretbox</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">mlen</span><span class="p">,</span> <span class="n">nonce</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>

  <span class="cm">/* Generate KeyShares */</span>
  <span class="n">sss_create_keyshares</span><span class="p">(</span><span class="n">keyshares</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="usage-2">Usage 2</h3>

<p>The next place where <code class="language-plaintext highlighter-rouge">randombytes</code> is used is in
<a href="https://github.com/dsprenkels/sss/blob/v0.1.0/hazmat.c#L298"><code class="language-plaintext highlighter-rouge">sss_create_keyshares</code></a>
in order to generate the various set of polynomials involved:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span>
<span class="nf">sss_create_keyshares</span><span class="p">(</span><span class="n">sss_Keyshare</span> <span class="o">*</span><span class="n">out</span><span class="p">,</span>
                      <span class="k">const</span> <span class="kt">uint8_t</span> <span class="n">key</span><span class="p">[</span><span class="mi">32</span><span class="p">],</span>
                      <span class="kt">uint8_t</span> <span class="n">n</span><span class="p">,</span>
                      <span class="kt">uint8_t</span> <span class="n">k</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// ...</span>
  <span class="kt">uint32_t</span> <span class="n">poly0</span><span class="p">[</span><span class="mi">8</span><span class="p">],</span> <span class="n">poly</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">8</span><span class="p">];</span>

  <span class="cm">/* Put the secret in the bottom part of the polynomial */</span>
	<span class="n">bitslice</span><span class="p">(</span><span class="n">poly0</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>

  <span class="cm">/* Generate the other terms of the polynomial */</span>
  <span class="n">randombytes</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span> <span class="n">poly</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">poly</span><span class="p">));</span>
  <span class="c1">//...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>In our case, \(k\) (number of shares needed to retrieve the secret) is three,
as long as \(n\) (number of total shares).  We thus have 3 sets of 32
polynomials with coefficients in \(GF(2^8)\):</p>

<ul>
  <li>one \(P_0\) set, which is the key \(K\)</li>
  <li>two other ones \((P_1,P_2)\), which are chosen randomly using <code class="language-plaintext highlighter-rouge">randombytes</code>.</li>
</ul>

<p>With all these informations, let’s refine a little bit our problem to solve.</p>

<h2 id="the-refined-problem-to-solve">The refined problem to solve</h2>

<p>As the representation of a set of 32 polynomials is composed of 32 8-bit
integers (which means 32 bytes), due to the vulnerability <a href="#figuring-out-the-vulnerability">explained
above</a>, this means that the first set of
polynomials’ coefficients are directly tied to the 32-bytes random key \(K\).</p>

<p>This means that, from the description of the problem we gave above, we can
refine the problem as such:</p>

<ul>
  <li>with \(F\) a function that, given \((K,P_2)\), generates \((KS_1,KS_2)\), the problem is, knowing \((KS_1,KS_2)\), to retrieve \((K,P_2)\).</li>
  <li>stated differently, we want to solve the equation \(F(K,P_2) = (KS_1,KS_2)\) (knowing \((KS_1,KS_2)\)).</li>
</ul>

<p>We can also note that \((K,P_2)\) is \(32+32=64\) bytes, as well as
\((KS_1,KS_2)\). Let’s now take a closer look at \(F\).</p>

<h2 id="analyzing-f">Analyzing <code class="language-plaintext highlighter-rouge">F</code></h2>

<p>We can split the code of the <code class="language-plaintext highlighter-rouge">sss_create_keyshares</code> function, so that our function \(F\)
becomes more explicit:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">extern</span> <span class="s">"C"</span> <span class="kt">void</span>
<span class="nf">sss_create_keyshares_impl</span><span class="p">(</span><span class="n">sss_Keyshare</span> <span class="o">*</span><span class="n">out</span><span class="p">,</span>
    <span class="k">const</span> <span class="kt">uint8_t</span> <span class="n">key</span><span class="p">[</span><span class="mi">32</span><span class="p">],</span>
    <span class="k">const</span> <span class="kt">uint32_t</span><span class="o">*</span> <span class="n">poly</span><span class="p">,</span>
    <span class="kt">uint8_t</span> <span class="n">n</span><span class="p">,</span>
    <span class="kt">uint8_t</span> <span class="n">k</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">uint8_t</span> <span class="n">share_idx</span><span class="p">,</span> <span class="n">coeff_idx</span><span class="p">,</span> <span class="n">unbitsliced_x</span><span class="p">;</span>
  <span class="kt">uint32_t</span> <span class="n">poly0</span><span class="p">[</span><span class="mi">8</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">8</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="mi">8</span><span class="p">],</span> <span class="n">xpow</span><span class="p">[</span><span class="mi">8</span><span class="p">],</span> <span class="n">tmp</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>

  <span class="cm">/* Put the secret in the bottom part of the polynomial */</span>
  <span class="n">bitslice</span><span class="p">(</span><span class="n">poly0</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">share_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">share_idx</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">share_idx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* x value is in 1..n */</span>
    <span class="n">unbitsliced_x</span> <span class="o">=</span> <span class="n">share_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">out</span><span class="p">[</span><span class="n">share_idx</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">unbitsliced_x</span><span class="p">;</span>
    <span class="n">bitslice_setall</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">unbitsliced_x</span><span class="p">);</span>

    <span class="cm">/* Calculate y */</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">y</span><span class="p">));</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">xpow</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xpow</span><span class="p">));</span>
    <span class="n">xpow</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0</span><span class="p">;</span> 
    <span class="n">gf256_add</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">poly0</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">coeff_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">coeff_idx</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span> <span class="n">coeff_idx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">gf256_mul</span><span class="p">(</span><span class="n">xpow</span><span class="p">,</span> <span class="n">xpow</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span> 
      <span class="n">gf256_mul</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">xpow</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">poly</span><span class="p">[</span><span class="n">coeff_idx</span><span class="o">*</span><span class="mi">8</span><span class="p">]);</span>
      <span class="n">gf256_add</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
    <span class="p">}</span>   
    <span class="n">unbitslice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">out</span><span class="p">[</span><span class="n">share_idx</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">y</span><span class="p">);</span> 
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">sss_create_keyshares</span><span class="p">(</span><span class="n">sss_Keyshare</span> <span class="o">*</span><span class="n">out</span><span class="p">,</span>
                      <span class="k">const</span> <span class="kt">uint8_t</span> <span class="n">key</span><span class="p">[</span><span class="mi">32</span><span class="p">],</span>
                      <span class="kt">uint8_t</span> <span class="n">n</span><span class="p">,</span>
                      <span class="kt">uint8_t</span> <span class="n">k</span><span class="p">)</span>
<span class="p">{</span>

  <span class="kt">uint32_t</span> <span class="n">poly</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">8</span><span class="p">];</span>
  <span class="cm">/* Generate the other terms of the polynomial */</span>
  <span class="n">randombytes</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span> <span class="n">poly</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">poly</span><span class="p">));</span>

  <span class="n">sss_create_keyshares_impl</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">poly</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span> 
<span class="p">}</span>
</code></pre></div></div>

<p>In this code, \(F\) is <code class="language-plaintext highlighter-rouge">sss_create_keyshares_impl</code>, called with <code class="language-plaintext highlighter-rouge">n=3</code> and
<code class="language-plaintext highlighter-rouge">k=3</code>. Moreover, due to the <a href="#figuring-out-the-vulnerability">previously exposed
issue</a> the 32 bytes of key are the sames as
the first 32 bytes of <code class="language-plaintext highlighter-rouge">polys</code>. This function basically implements the
<a href="https://en.wikipedia.org/wiki/Shamir%27s_Secret_Sharing">SSS</a> protocol. As <a href="#shamirs-secret-sharing-and-its-implementation-in-sss">seen
before</a>, it’s using sets
of 32 polynomials with coefficients in the \(GF(2^8)\) space.</p>

<p>As discussed in <a href="#annex-a-gf28-versus-gf2n">Annex A</a>, multiplications by
constant polynomials and additions in \(GF(2^8)\) can also be represented as
linear functions in the \(GF(2)^8\) space. This can help us tell that the
function \(F\) is linear in the \(GF(2)^{512}\) space.</p>

<p>Indeed, let’s take a closer look at the computation of one byte of the \(i\)-th
share. This is basically evaluating a polynomial \(A\) of degree \(k-1=2\) (with coefficients
\(a_i\) in \(GF(2^8)\)) in \(i\). With \(C_i\) the polynomial representation of
\(i\) in \(GF(2^8)\) (e.g. here with \(i=3 \implies C_i = 1+x\)):</p>

\[\begin{align*}
A(C_i) &amp;= a_0 + a_1*C_i + a_2*C_i^2 \\
 &amp;= a_0 + a_1*(1+x) + a_2*(1+x)^2 \\
 &amp;= a_0 + a_1*(1+x) + a_2*(1+x^2) \\
 &amp;= (a_0+a_1+a_2) + a_1*x + a_2*x^2
\end{align*}\]

<p>With \(a_i = \sum_{j=0}^{7} (b_{i,j}*x^j)\), we end up with a polynomial in
\(GF(2^8)\), whose coefficients are linear combinations of \((b_{ij})\). So,
for this specific share, we can rewrite this operation in \(GF(2)^{8*3}\) as:</p>

\[M_i\times\begin{pmatrix}b_{0,0} \\ b_{0,1} \\ \dots \\ b_{0,7} \\ b_{1,0} \\ \dots \\ b_{2,7} \end{pmatrix}\]

<p>with \(M_i\) a \(24 \times 8\) bit matrix.</p>

<p>Moreover, as <a href="#bitslicing">said above</a>, the bitslicing part is <em>just</em> an
optimisation, and can also be seen as a linear function. We can notice that the
<code class="language-plaintext highlighter-rouge">sss_create_keyshares_impl</code> takes “unbitsliced” inputs, and returns
“unbitsliced” outputs. So, in the end, we don’t really have to take care about this
internal representation and optimisation.</p>

<p>Finally, we can say that our problem basically boils down to solving
a linear system in \(GF(2)^{512}\)! What we miss is the representation of \(F\)
in that space.</p>

<p><em>Note: we don’t necessary need to precisely understand all these things to
solve the challenge. We can make the assumption that \(F\) will be linear in
the \(GF(2)^{512}\) vector space, and quickly try if that’s the case (see the
<a href="https://github.com/aguinet/donjonctf_sssgx/blob/main/attack.py#L50">provided source
code</a> for
an example).</em></p>

<h1 id="exploiting-the-vulnerability-and-solving-the-challenge">Exploiting the vulnerability (and solving the challenge)</h1>

<p>Let’s recap what we have to do:</p>

<ul>
  <li>we know the key shares \((KS_1,KS_2)\), which are both 32-bytes long</li>
  <li>we have the function \(F\), which can be represented as a linear function
in the \(GF(2)^{512}\) vector space. We have the code of that function, so we
can evaluate it</li>
  <li>we have to retrieve the original secret by solving the equation \(F(K,P_2) == (KS_1,KS_2)\)</li>
</ul>

<p>As \(F\) is a linear function in \(GF(2)^{512}\), it can be represented by a
512 square bit matrix \(M\). Remember, \(GF(2)\) basically means \(\{0,1\}\) (it’s
a bit), and the size of \((K,P_2)\) and \((KS_1,KS_2)\) is 64 <strong>bytes</strong>.</p>

<p>So, in the end, we want to solve this equation:</p>

\[M\times\begin{pmatrix}K \\ P_2\end{pmatrix} = \begin{pmatrix}KS_1 \\ KS_2\end{pmatrix}\]

<p>Note that \(M\) might not be invertible, so it might not be “as simple”
as writing the inverse of \(F\) and compute it.</p>

<h2 id="computing-m-using-dragonffi">Computing \(M\) using DragonFFI</h2>

<p>One thing that remains is to compute the matrix \(M\). There are basically two ways to do this:</p>

<ul>
  <li>compute the matrix <em>by hand</em>, by composing all the various operations that
are happening in \(F\). This is a bit time consuming and potentially
error-prone.</li>
  <li>evaluate \(F\) 512 times to compute the values of the column of \(M\).
Indeed, if, for every column index \(i\) of \(M\), we compute \(F(V)\), with
V a bit vector with only the \(i\)-th index at 1 (and the others at zero), then
we directly get the vector of the column \(i\) of \(M\).</li>
</ul>

<p>Let’s go for the second option, and do that using <a href="https://github.com/aguinet/dragonffi/">DragonFFI</a> to directly
call <code class="language-plaintext highlighter-rouge">sss_create_keyshares_impl</code> from Python:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">pydffi</span>
<span class="n">FFI</span><span class="o">=</span><span class="n">pydffi</span><span class="p">.</span><span class="nc">FFI</span><span class="p">()</span>
<span class="n">CU</span><span class="o">=</span><span class="n">FFI</span><span class="p">.</span><span class="nf">cdef</span><span class="p">(</span><span class="sh">'''</span><span class="s">
#include &lt;stdint.h&gt;
void sss_create_keyshares_impl(uint8_t *out,
  const uint8_t* key,
  const uint8_t* poly, // was uint32_t*
  uint8_t n,
  uint8_t k);
</span><span class="sh">'''</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">polys_to_keyshares</span><span class="p">(</span><span class="n">polys</span><span class="p">):</span>
    <span class="nf">assert</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">polys</span><span class="p">)</span> <span class="o">==</span> <span class="n">LEN_POLYS</span><span class="p">)</span>
    <span class="c1"># This is due to the random generator reusing the same data (this is the vuln we are exploiting).
</span>    <span class="n">key</span> <span class="o">=</span> <span class="n">polys</span><span class="p">[:</span><span class="n">LEN_KEY</span><span class="p">]</span>
    <span class="n">out</span> <span class="o">=</span> <span class="nf">bytearray</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">LEN_KEYSHARES</span><span class="p">)</span>
    <span class="n">CU</span><span class="p">.</span><span class="n">funcs</span><span class="p">.</span><span class="nf">sss_create_keyshares_impl</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">polys</span><span class="p">,</span> <span class="n">NSHARES</span><span class="p">,</span> <span class="n">NSHARES</span><span class="p">)</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="n">out</span><span class="p">[:</span><span class="n">LEN_KEYSHARE</span><span class="p">],</span> <span class="n">out</span><span class="p">[</span><span class="n">LEN_KEYSHARE</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="n">LEN_KEYSHARE</span><span class="p">],</span> <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">LEN_KEYSHARE</span><span class="p">:])</span>
    <span class="k">return</span> <span class="n">ret</span>

<span class="k">def</span> <span class="nf">kss_to_F_output</span><span class="p">(</span><span class="n">kss</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">kss</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">kss</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">:]</span>

<span class="c1"># This is our function F. It takes 64 bytes as input (two polynoms), and
# returns the last two shares (2*32 bytes)
</span><span class="k">def</span> <span class="nf">F</span><span class="p">(</span><span class="n">in_</span><span class="p">):</span>
    <span class="n">kss</span> <span class="o">=</span> <span class="nf">polys_to_keyshares</span><span class="p">(</span><span class="n">in_</span><span class="p">)</span>
    <span class="k">return</span> <span class="nf">kss_to_F_output</span><span class="p">(</span><span class="n">kss</span><span class="p">)</span>

<span class="c1"># We work with vector of bits, so we choose a way to transform a list of bytes
# into a list of bits and vice versa. Any representation would work, as long as
# bytes2bits is the inverse of bits2bytes. Implementation is in the provided
# source code.
</span><span class="k">def</span> <span class="nf">bits2bytes</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
  <span class="c1"># ...
</span>
<span class="k">def</span> <span class="nf">bytes2bits</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
  <span class="c1"># ...
</span>
<span class="kn">from</span> <span class="n">sage.all</span> <span class="kn">import</span> <span class="n">Integers</span><span class="p">,</span> <span class="n">Matrix</span><span class="p">,</span> <span class="n">vector</span>
<span class="n">GF2</span><span class="o">=</span><span class="nc">Integers</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">computeFMatrix</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">input_nbits</span><span class="p">):</span>
    <span class="n">ret_cols</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">bin_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">input_nbits</span><span class="p">):</span>
        <span class="n">in_</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">NBITS</span>
        <span class="n">in_</span><span class="p">[</span><span class="n">bin_</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">in_</span> <span class="o">=</span> <span class="nf">bits2bytes</span><span class="p">(</span><span class="n">in_</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="nc">F</span><span class="p">(</span><span class="n">in_</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="nf">bytes2bits</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
        <span class="n">ret_cols</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
    <span class="k">return</span> <span class="nc">Matrix</span><span class="p">(</span><span class="n">GF2</span><span class="p">,</span> <span class="n">ret_cols</span><span class="p">).</span><span class="nf">transpose</span><span class="p">()</span>
<span class="n">NBITS</span><span class="o">=</span><span class="mi">64</span><span class="o">*</span><span class="mi">8</span>
<span class="n">M</span><span class="o">=</span><span class="nf">computeFMatrix</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">NBITS</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="solving-the-problem-with-sage">Solving the problem with sage</h2>

<p>Now that we got the matrix, it’s a matter of asking <a href="https://www.sagemath.org/">Sage</a> to solve the
problem for us.</p>

<p>The first thing we can verify is the size of the kernel of \(M\), that is the
number of vector \(X\) for which \(M \times X == 0\). This will basically gives us the
number of possible solutions to the problem:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">print</span><span class="p">(</span><span class="n">M</span><span class="p">.</span><span class="nf">kernel</span><span class="p">())</span>
</code></pre></div></div>

<p>which gives:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Vector space of degree 512 and dimension 2 over Ring of integers modulo 2
Basis matrix:
2 x 512 dense matrix over Ring of integers modulo 2
</code></pre></div></div>

<p>As the dimension of the result vector space is \(2\), we will have \(2^2 = 4\)
potential solutions, which is fine to bruteforce :)</p>

<p>Now, let’s ask <a href="https://www.sagemath.org/">Sage</a> to finally solve this:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Get all possible values of X in M*X = C thanks to Sage
</span><span class="k">def</span> <span class="nf">allsols</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">C</span><span class="p">):</span>
    <span class="n">S0</span> <span class="o">=</span> <span class="n">M</span><span class="p">.</span><span class="nf">solve_right</span><span class="p">(</span><span class="nf">vector</span><span class="p">(</span><span class="n">GF2</span><span class="p">,</span><span class="nf">bytes2bits</span><span class="p">(</span><span class="n">C</span><span class="p">)))</span>
    <span class="k">for</span> <span class="n">S</span> <span class="ow">in</span> <span class="n">M</span><span class="p">.</span><span class="nf">right_kernel</span><span class="p">():</span>
        <span class="k">yield</span> <span class="n">S</span> <span class="o">+</span> <span class="n">S0</span>

<span class="c1"># We extract the two shares from the mails we received
</span><span class="n">Fout</span> <span class="o">=</span> <span class="n">shares</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="n">shares</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="n">keys</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">for</span> <span class="n">S</span> <span class="ow">in</span> <span class="nf">allsols</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">Fout</span><span class="p">):</span>
    <span class="n">S</span> <span class="o">=</span> <span class="p">[</span><span class="nf">int</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">S</span><span class="p">]</span>
    <span class="c1"># The solution will give us the encryption K and the polynom P2. We only
</span>    <span class="c1"># care about K here.
</span>    <span class="n">key</span> <span class="o">=</span> <span class="nf">bits2bytes</span><span class="p">(</span><span class="n">S</span><span class="p">)[:</span><span class="mi">32</span><span class="p">]</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">[x] Possible key: %s</span><span class="sh">"</span> <span class="o">%</span> <span class="n">key</span><span class="p">.</span><span class="nf">hex</span><span class="p">())</span>
    <span class="n">keys</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="recovering-the-original-private-key">Recovering the original private key</h2>

<p>Last part is to bruteforce these 4 keys and retrieve the original secret:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
    <span class="n">out</span> <span class="o">=</span> <span class="nf">bytearray</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mi">64</span><span class="p">)</span>
    <span class="c1"># sss_decrypt is basically a wrapper around crypto_secretbox_open
</span>    <span class="c1"># added to the sss lib (source code in the provided repository)
</span>    <span class="k">if</span> <span class="nf">int</span><span class="p">(</span><span class="n">CU</span><span class="p">.</span><span class="n">funcs</span><span class="p">.</span><span class="nf">sss_decrypt</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">k</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">[+] Original secret found: %s</span><span class="sh">"</span> <span class="o">%</span> <span class="n">out</span><span class="p">.</span><span class="nf">hex</span><span class="p">())</span>
        <span class="n">sys</span><span class="p">.</span><span class="nf">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</code></pre></div></div>

<p>To get the flag, we just had to give the found secret to a script that would
verify that it is indeed the private key associated to the challenge’s wallet
public key, and output the flag as <code class="language-plaintext highlighter-rouge">CTF{secret_in_hex}</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  $ python ./check_flag.py 7d486b4cfdb1ede284802029e77ab292c35ab0d7b9d8c51a06b9222e5095e98c
  CTF{7d486b4cfdb1ede284802029e77ab292c35ab0d7b9d8c51a06b9222e5095e98c}
</code></pre></div></div>

<p>And that’s it!</p>

<h1 id="conclusion">Conclusion</h1>

<p>That was a very nice challenge, which showcases how a <em>simple</em> vulnerability in a random generator can break an apparently well designed system!</p>

<h1 id="acknowledgment">Acknowledgment</h1>

<p>Thanks to ssp for reviewing this writeup at 11PM, and the Donjon Ledger team for this CTF!</p>

<h1 id="annex-a-gf2n-versus-gf2n">Annex A: \(GF(2^N)\) versus \(GF(2)^N\)</h1>

<p>This annex explains why some operations in \(GF(2^N)\) can be represented as
linear operation in the vector space \(GF(2)^N\) (which means a vector space using
vectors of N bits).</p>

<p>\(GF(2^N)\) represents polynomials with coefficients in \(GF(2)\) (aka a bit).
For instance, for \(N = 8\): \(P(x) = a_0 + a_1*x + a_2*x^2 + ... + a_7*x^7\).
As each coefficient is a bit, we can also represent them as bits. Let’s call
that representation <code class="language-plaintext highlighter-rouge">bits(P)</code>.</p>

<p>Additions and multiplications are the usual ones. Addition of two polynomials A
and B gives:</p>

\[A(x) + B(x) = (a_0+b_0) + (a_1+b_1)*x + ... + (a_7+b_7)*x^7\]

<p>As coefficients are in \(GF(2)\), the addition can be seen as a simple XOR
operation. This means that \(A+B\) == <code class="language-plaintext highlighter-rouge">poly(bits(A)^bits(B))</code>. With \(BA\) and
\(BV\) in \(GF(2)^8\), this also means that this polynomial addition can also
be represented as a simple \(BA + BV\) vector addition in this vector space.</p>

<p>Multiplications in \(GF(2^N)\) are reduced to a fixed polynomial. Multiplying
a unknown polynomial \(X\) with a known polynomial \(C\) can also be represented as
a linear operation \(M_C \times X\) in \(GF(2)^N\) (with \(M_C\) an NxN bit matrix). Let’s
just take an example to give the intuition behind this, with \(N = 4\), \(C = 1+x^2\),
and \(x^4 + x + 1\) the reduction polynomial:</p>

\[\begin{align*}
A(x)*C &amp;= (a_0+a_1*x+a_2*x^2+a_3*x^3)*(1+x^2) \\
 &amp;= a_0 + a_1*x + (a_2 + a_0)*x^2 + (a_3 + a_1)*x^3 + a_2*x^4 + a_3*x^5
\end{align*}\]

<p>Reduced \(\pmod{x^4 + x + 1}\), we have</p>

\[\begin{align*}
  x^4 &amp;= x + 1   &amp; \pmod{x^4 + x + 1}\\
  x^5 &amp;= x^2 + x &amp; \pmod{x^4 + x + 1}
\end{align*}\]

<p>Which gives us:</p>

\[\begin{split}
&amp;A(x)*C \pmod{x^4 + x + 1} \\
&amp;   = a_0 + a_1*x + (a_2 + a_0)*x^2 + (a_3 + a_1)*x^3 + a_2*(x + 1) + a_3*(x^2 + x) \\
&amp;   = (a_0 + a_2) + (a_1 + a_2 + a_3)*x + (a_0 + a_2 + a_3)*x^2 + (a_1 + a_3)*x^3
\end{split}\]

<p>If we model \(A\) as a 4-bit vector in \(GF(2)^4\), we can represent \(A(x)*C\)
as a linear operation \(M_C \times A\), with \(M_C\) a 4x4-bit matrix:</p>

\[\begin{pmatrix}
1 &amp; 0 &amp; 1 &amp; 0 \\
0 &amp; 1 &amp; 1 &amp; 1 \\
1 &amp; 0 &amp; 1 &amp; 1 \\
0 &amp; 1 &amp; 0 &amp; 1
\end{pmatrix}
\times
\begin{pmatrix}
a_0 \\
a_1 \\
a_2 \\
a_3 \\
\end{pmatrix}\]]]></content><author><name>adrien_guinet</name></author><category term="blog" /><summary type="html"><![CDATA[This writeup presents a solution to the SSSGX Wallet stage of the 2020 Ledger Donjon’s CTF. It showcases a solution using a kind of generic method to exploit the issues that we are facing in this challenge, which can basically be reduced to solving a linear system in the vector space \(\{0,1\}^N\).]]></summary></entry><entry><title type="html">Lifting shared libraries &amp;amp; PIE binaries with DragonFFI (and LIEF)</title><link href="https://aguinet.github.io/blog/2020/10/05/dragonffi-library-lifting.html" rel="alternate" type="text/html" title="Lifting shared libraries &amp;amp; PIE binaries with DragonFFI (and LIEF)" /><published>2020-10-05T00:00:00+02:00</published><updated>2020-10-05T00:00:00+02:00</updated><id>https://aguinet.github.io/blog/2020/10/05/dragonffi-library-lifting</id><content type="html" xml:base="https://aguinet.github.io/blog/2020/10/05/dragonffi-library-lifting.html"><![CDATA[<p><a href="https://github.com/aguinet/dragonffi/releases/tag/dffi-0.6.0">Dragonffi 0.6.0</a>
comes with new APIs that can be leveraged to call arbitrary functions within a
shared library (or position independent (aka PIE) binaries).</p>

<p>This small post showcases how to use these new APIs to do so. Impatient readers
can directly <a href="#call-the-function-method-1">jump to the Python scripts</a>
achieving this feature.</p>

<p><em>DragonFFI’s python bindings can be installed using <code class="language-plaintext highlighter-rouge">pip install
pydffi</code>.  Wheels have been precompiled for OSX/Windows/Linux for x64. The 0.6.0
release is the first one where these packages have been fully built <a href="https://github.com/aguinet/dragonffi/blob/dffi-0.6.0/.github/workflows/dist_publish.yml">using
Github
Actions</a>!</em></p>

<h1 id="introduction">Introduction</h1>

<p>Let’s say we have a closed-source shared library (or a PIE binary). Calling
exported function from this library is supported by the (famous) combo <code class="language-plaintext highlighter-rouge">dlopen</code> +
<code class="language-plaintext highlighter-rouge">dlsym</code> (or <code class="language-plaintext highlighter-rouge">LoadLibrary</code> + <code class="language-plaintext highlighter-rouge">GetProcAddress</code> for Windows), and also easily
achievable from Python with FFI libraries like <a href="https://docs.python.org/3/library/ctypes.html">ctypes</a>, <a href="https://cffi.readthedocs.io/">cffi</a> and, obviously,
<a href="https://github.com/aguinet/dragonffi">DragonFFI</a>. Problems arise when we want to call a <strong>non exported</strong>
function from that binary, with the special bonus to do it directly from
Python.</p>

<p>The classical way to do this is:</p>

<ul>
  <li>load this library into the Python process</li>
  <li>find its loading base address</li>
  <li>compute the function address (thanks to the base address)</li>
  <li>call it using an FFI library, e.g. <a href="https://docs.python.org/3/library/ctypes.html">ctypes</a></li>
</ul>

<p>Let’s see how <a href="https://github.com/aguinet/dragonffi">DragonFFI</a> makes all of this an easy task through a
shared library example. <a href="#what-about-pie-binaries-linux-only">This section</a>
gives links for the extra necessary steps to dynamically load a PIE binary
under Linux (using <a href="https://lief.quarkslab.com">LIEF</a>).</p>

<h1 id="toy-library-example">Toy library example</h1>

<p>Let’s say we have a very elite library that decrypts and prints buffers:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdint.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span>
<span class="n">__attribute__</span><span class="p">((</span><span class="n">noinline</span><span class="p">))</span> <span class="k">static</span> <span class="kt">void</span> <span class="nf">decrypt</span><span class="p">(</span><span class="kt">uint8_t</span><span class="o">*</span> <span class="n">buf</span><span class="p">,</span> <span class="k">const</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="k">const</span> <span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">^=</span> <span class="n">key</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="n">__attribute__</span><span class="p">((</span><span class="n">visibility</span><span class="p">(</span><span class="s">"default"</span><span class="p">)))</span> <span class="kt">void</span> <span class="nf">decrypt_print</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="k">const</span><span class="o">*</span> <span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="k">const</span> <span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">decr</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">len</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buf</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
  <span class="n">decr</span><span class="p">[</span><span class="n">len</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">memcpy</span><span class="p">(</span><span class="n">decr</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
  <span class="n">decrypt</span><span class="p">(</span><span class="n">decr</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
  <span class="n">puts</span><span class="p">(</span><span class="n">decr</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Note the <code class="language-plaintext highlighter-rouge">__attribute__((noinline))</code> attribute for the <code class="language-plaintext highlighter-rouge">decrypt</code> function, so
that we are sure this function ends up in the compiled binary.</p>

<p>Let’s consider we are provided with only a binary version of this library,
compiled like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gcc -O2 -fvisibility=hidden mylib.c -fPIC -shared -o mylib.so -Wl,-strip-all
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">nm</code> tells us that the only exported symbol is <code class="language-plaintext highlighter-rouge">decrypt_print</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ nm -D --defined-only mylib.so
0000000000001150 T decrypt_print
</code></pre></div></div>

<p>Reverse engineering this library should give us the relative address of the
<code class="language-plaintext highlighter-rouge">decrypt</code> function. With the system used to write this post, this relative
address is <code class="language-plaintext highlighter-rouge">0x1130</code> in the resulting <code class="language-plaintext highlighter-rouge">mylib.so</code> file.</p>

<h1 id="load-the-library-and-get-its-base-address">Load the library and get its base address</h1>

<p><a href="https://github.com/aguinet/dragonffi">DragonFFI</a> provides the cross-platform <code class="language-plaintext highlighter-rouge">pydffi.dlopen</code> function to
load a shared library into the Python process:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">pydffi</span>
<span class="n">lib</span> <span class="o">=</span> <span class="n">pydffi</span><span class="p">.</span><span class="nf">dlopen</span><span class="p">(</span><span class="sh">"</span><span class="s">/path/to/mylib.so</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<p>Note that, on some system (e.g. Linux), a full path to the library must be
provided to <code class="language-plaintext highlighter-rouge">dlopen</code>.</p>

<p>The object returned by <code class="language-plaintext highlighter-rouge">dlopen</code> (<code class="language-plaintext highlighter-rouge">lib</code> in our example) have a <code class="language-plaintext highlighter-rouge">baseAddress</code>
property containing the base address where the library has been loaded:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">print</span><span class="p">(</span><span class="nf">hex</span><span class="p">(</span><span class="n">lib</span><span class="p">.</span><span class="n">baseAddress</span><span class="p">))</span>
</code></pre></div></div>

<p>This is supported for OSX/Windows/Linux. Note that, under OSX, <code class="language-plaintext highlighter-rouge">baseAddress</code>
can have a <a href="https://github.com/aguinet/dragonffi/blob/dffi-0.6.0/lib/dffi_api_osx.inc"><code class="language-plaintext highlighter-rouge">O(n)</code>
complexity</a>,
with <code class="language-plaintext highlighter-rouge">n</code> being the number of loaded libraries in the Python process.</p>

<p>Let’s see two methods to call the <code class="language-plaintext highlighter-rouge">decrypt</code> function from such a shared
library.</p>

<h1 id="call-the-function-method-1">Call the function, method 1</h1>

<p>The more straightforward method to call arbitrary function from that binary is
to dynamically add new symbols into <a href="https://github.com/aguinet/dragonffi">DragonFFI</a>’s runtime dynamic linker (which
is basically
<a href="https://github.com/aguinet/dragonffi/blob/dffi-0.6.0/lib/dffi_api.cpp#L105">LLVM’s</a>).</p>

<p>This can be achieved using the <code class="language-plaintext highlighter-rouge">pydffi.addSymbol</code> function, and then call the
<code class="language-plaintext highlighter-rouge">decrypt</code> function as we would <em>usually</em> do:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">pydffi</span>
<span class="c1"># Load the library into our current Python process
</span><span class="n">lib</span> <span class="o">=</span> <span class="n">pydffi</span><span class="p">.</span><span class="nf">dlopen</span><span class="p">(</span><span class="sh">"</span><span class="s">/path/to/mylib.so</span><span class="sh">"</span><span class="p">)</span>
<span class="n">BASE</span> <span class="o">=</span> <span class="n">lib</span><span class="p">.</span><span class="n">baseAddress</span>
<span class="c1"># TODO: put the offset for your library
</span><span class="n">DECRYPT_OFFSET</span> <span class="o">=</span> <span class="mh">0x1130</span>
 
<span class="c1"># Add the "decrypt" symbol to the dynamic linker
</span><span class="n">pydffi</span><span class="p">.</span><span class="nf">addSymbol</span><span class="p">(</span><span class="sh">"</span><span class="s">decrypt</span><span class="sh">"</span><span class="p">,</span> <span class="n">BASE</span><span class="o">+</span><span class="n">DECRYPT_OFFSET</span><span class="p">)</span>

<span class="c1"># Declare the "decrypt" function interface, as we would do with any other
# classical one
</span><span class="n">FFI</span> <span class="o">=</span> <span class="n">pydffi</span><span class="p">.</span><span class="nc">FFI</span><span class="p">()</span>
<span class="n">CU</span> <span class="o">=</span> <span class="n">FFI</span><span class="p">.</span><span class="nf">cdef</span><span class="p">(</span><span class="sh">'''</span><span class="s">
#include &lt;stdint.h&gt;
#include &lt;stdlib.h&gt;
void decrypt(uint8_t* buf, const size_t len, uint8_t const key);
</span><span class="sh">'''</span><span class="p">)</span>

<span class="c1"># Call the decrypt function
</span><span class="n">key</span> <span class="o">=</span> <span class="mh">0xAA</span>
<span class="n">buf</span> <span class="o">=</span> <span class="nf">bytearray</span><span class="p">(</span><span class="n">c</span><span class="o">^</span><span class="n">key</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="sa">b</span><span class="sh">"</span><span class="s">Hello World!</span><span class="sh">"</span><span class="p">)</span>
<span class="n">CU</span><span class="p">.</span><span class="n">funcs</span><span class="p">.</span><span class="nf">decrypt</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="n">key</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>
</code></pre></div></div>

<h1 id="call-the-function-method-2">Call the function, method 2</h1>

<p>Another way to call a function at an arbitrary address is to declare function
types, and instantiate them with an arbitrary address:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">pydffi</span>
<span class="c1"># Load the library into our current Python process
</span><span class="n">lib</span> <span class="o">=</span> <span class="n">pydffi</span><span class="p">.</span><span class="nf">dlopen</span><span class="p">(</span><span class="sh">"</span><span class="s">/path/to/mylib.so</span><span class="sh">"</span><span class="p">)</span>
<span class="n">BASE</span> <span class="o">=</span> <span class="n">lib</span><span class="p">.</span><span class="n">baseAddress</span>
<span class="n">DECRYPT_OFFSET</span> <span class="o">=</span> <span class="mh">0x1130</span>
 
<span class="c1"># Define the "decrypt" function type
</span><span class="n">FFI</span> <span class="o">=</span> <span class="n">pydffi</span><span class="p">.</span><span class="nc">FFI</span><span class="p">()</span>
<span class="n">CU</span> <span class="o">=</span> <span class="n">FFI</span><span class="p">.</span><span class="nf">cdef</span><span class="p">(</span><span class="sh">'''</span><span class="s">
#include &lt;stdint.h&gt;
// Note that we declare a function type, not a pointer-to-function type
typedef void(decrypt_functy)(uint8_t*, const size_t, uint8_t);
</span><span class="sh">'''</span><span class="p">)</span>

<span class="c1"># Create the decrypt function object
</span><span class="n">decrypt</span> <span class="o">=</span> <span class="p">(</span><span class="n">CU</span><span class="p">.</span><span class="n">types</span><span class="p">.</span><span class="n">decrypt_functy</span><span class="p">)(</span><span class="n">BASE</span><span class="o">+</span><span class="n">DECRYPT_OFFSET</span><span class="p">)</span>

<span class="c1"># Call the decrypt function
</span><span class="n">key</span> <span class="o">=</span> <span class="mh">0xAA</span>
<span class="n">buf</span> <span class="o">=</span> <span class="nf">bytearray</span><span class="p">(</span><span class="n">c</span><span class="o">^</span><span class="n">key</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="sa">b</span><span class="sh">"</span><span class="s">Hello World!</span><span class="sh">"</span><span class="p">)</span>
<span class="nf">decrypt</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="n">key</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>
</code></pre></div></div>

<h1 id="what-about-pie-binaries-linux-only">What about PIE binaries? (Linux only)</h1>

<p>PIE binaries are relocatable (by design), and we can trick <code class="language-plaintext highlighter-rouge">dlopen</code> to open
them.</p>

<p>Please note that doing this <a href="https://sourceware.org/bugzilla/show_bug.cgi?id=11754">isn’t fully supported by the Linux
loader</a>, and recent
version of glibc actually prevent us from doing so. That being said, the <a href="https://lief.quarkslab.com">LIEF
project</a> documentation has <a href="https://lief.quarkslab.com/doc/latest/tutorials/08_elf_bin2lib.html#warning-for-glic-2-29-users">a great
tutorial</a>
that shows how to patch the binary to circumvent this limitation.</p>

<h1 id="alternative-method-using-lief">Alternative method using LIEF</h1>

<p>Another way to fix our original problem is to use <a href="https://lief.quarkslab.com">LIEF</a> to statically
add exported symbols to our binary. This is covered in <a href="https://lief.quarkslab.com/doc/latest/tutorials/08_elf_bin2lib.html">this
tutorial</a>.</p>

<h1 id="conclusion">Conclusion</h1>

<p>There’s nothing really fundamentally new in this post, or, in other words,
nothing that you weren’t already able to do directly in C(++), or using
<code class="language-plaintext highlighter-rouge">ctypes</code> in Python. <a href="https://github.com/aguinet/dragonffi">DragonFFI</a> just makes this more straightforward
and portable across OSX, Linux and Windows.</p>

<h1 id="acknowledgment">Acknowledgment</h1>

<p>Thanks to <a href="https://github.com/serge-sans-paille/">serge-sans-paille</a> that took
the time to review this post while cleaning <a href="https://www.mangeons-local.bzh/wp-content/uploads/sac-kig-farz.jpg">his lovely Kig Ah Farz
bags</a>, and
toffan for various corrections.</p>]]></content><author><name>adrien_guinet</name></author><category term="blog" /><summary type="html"><![CDATA[Dragonffi 0.6.0 comes with new APIs that can be leveraged to call arbitrary functions within a shared library (or position independent (aka PIE) binaries).]]></summary></entry><entry><title type="html">Emulating NotPetya bootloader with Miasm</title><link href="https://aguinet.github.io/blog/2020/08/29/miasm-bootloader.html" rel="alternate" type="text/html" title="Emulating NotPetya bootloader with Miasm" /><published>2020-08-29T00:00:00+02:00</published><updated>2020-08-29T00:00:00+02:00</updated><id>https://aguinet.github.io/blog/2020/08/29/miasm-bootloader</id><content type="html" xml:base="https://aguinet.github.io/blog/2020/08/29/miasm-bootloader.html"><![CDATA[<p>NotPetya is a famous malware of the Petya family. It appeared in June 2017.
The part running from the Master Boot Record (MBR) has been statically and
dynamically studied, using for instance the Bochs debugger from IDA. Is
another approach possible? This article’s goal is to show that we can emulate
this bootloader using Miasm.</p>

<p><em>This article has been written by <a href="https://twitter.com/la_F0uin3">Jordan Bouyat
(@la_F0uin3)</a> and <a href="https://twitter.com/adriengnt">Adrien Guinet
(@adriengnt)</a>. It has originally been published
in the <a href="https://connect.ed-diamond.com/MISC/MISC-098/Emulation-du-bootloader-de-NotPetya-avec-Miasm">MISC magazine n°98</a> in French. This is a slightly updated and
English translation of this article.</em></p>

<h1 id="introduction">Introduction</h1>

<p>This Petya variant first appeared in June 2017 in Ukraine. According to Mikko
Hyppönen, Chief Research Officer at F-Secure, the infection vector would be
the update mechanism of the accountability software M.E.Doc, widely deployed
within Eastern countries.</p>

<p>This malware family has the particularity of overwriting the bootloader of the
compromised machine in order to encrypt parts of the hard drive when it reboots.
This article uses this bootloader as a pretext for a tutorial concerning the emulation
and reverse engineering of these little beasts thanks to the Miasm
framework. The associated code is available here:
<a href="https://github.com/aguinet/miasm-bootloader/">https://github.com/aguinet/miasm-bootloader/</a>. It contains a Python
implementation of a subset of the interfaces of a classic x86 PC BIOS. The code
was written in a way that is easily reusable for other cases, or even to
help the development / debugging of bootloaders in general.</p>

<h2 id="related-works">Related works</h2>

<p>Many articles have already studied the behaviour of the NotPetya MBR, as
well as its various cryptographic implementations and mechanisms (and their
faults). Here are some significant ones:</p>

<ul>
  <li>MISC n°86 : “Pleased to meet you, my name is Petya !”, written by Damien Schaeffer in July 2016</li>
  <li>MISC n°93 : “Petya or Not Petya, that is the question”, written by “Teddy and
Benjamin” in September 2017, with a very thorough static reverse
engineering of the bootloader.</li>
  <li>Crowdstrike : <a href="https://www.crowdstrike.com/blog/full-decryption-systems-encrypted-petya-notpetya/">Full Decryption of Systems Encrypted by Petya/NotPetya</a>. Study of an implementation error within the
Salsa20 algorithm embedded in the bootloader (more on that subject later in the article).</li>
</ul>

<h2 id="notpetya">NotPetya</h2>

<p>This section deals only in a very general way with the malware’s cycle of life. It allows us to highlight the part studied in this article.</p>

<p>Once NotPetya has run on the victim’s machine, it generates an AES encryption key
that will be used to achieve the first encryption phase. This key is itself
encrypted with an RSA public key.</p>

<p>The malware then checks that the system uses a classical partition scheme and,
if it has admin rights, enters its own data on the first sectors of the disc
(from 1 to 18, then 32 to 34), with its own MBR in the first sector. If the
system uses UEFI (with a GPT partition scheme), the malware skips this step.
The machine then is restarted and the NotPetya bootloader executed: a Salsa20
key and a nonce are generated. These secrets are used to encrypt the Master
File Table (MFT) <sup id="fnref:1"><a href="#fn:1" class="footnote" rel="footnote" role="doc-noteref">1</a></sup> of NTFS file system. This data structure contains the metadata
needed to find the data associated with each file. This operation looks like a
classical “chkdsk”. Once this operation is done, the machine restarts one last
time and then displays the ransom message.</p>

<h2 id="miasm">Miasm</h2>

<p>Miasm is a reverse engineering framework developed in Python. It has many
features, among which:</p>

<ul>
  <li>open, modify and generate binaries in PE, ELF 32, 64 LE, BE.</li>
  <li>assemble/disassemble x86, ARM, MIPS, SH4, PPC and MSP430 code.</li>
  <li>lift instruction semantics into a custom intermediate representation.</li>
  <li>emulate this intermediate representation, with various JIT (Just-in-time)
compilers to speed things up.</li>
  <li>simplify/modify this intermediate representation, to de-obfuscate code for instance.</li>
</ul>

<h2 id="why-emulate-notpetya-with-miasm">Why emulate NotPetya with Miasm?</h2>

<p><img src="/assets/2020-08-29-miasm-bootloader/crazy.gif" alt="" class="center-image" /></p>

<p>There are various ways to emulate a bootloader. A classical approach is to use
QEMU (or any other virtualization/emulation solution) by writing the bootloader
on a virtual hard disk, but it makes it difficult to instrument the bootloader
code.  Such a thing is however possible via IDA’s Bochs debugger. This approach
was adopted by Teddy and Benjamin in MISC No. 93, but also by Saurabh Sharma
<sup id="fnref:2"><a href="#fn:2" class="footnote" rel="footnote" role="doc-noteref">2</a></sup>. This method usually works well and makes debugging a bootloader an
easy task.</p>

<p>In the article associated with the presentation of his Miasm tool at SSTIC in
2012 <sup id="fnref:3"><a href="#fn:3" class="footnote" rel="footnote" role="doc-noteref">3</a></sup>, Fabrice Desclaux showed Miasm possibilities. One of the proposed
applications was the emulation of a bootloader.</p>

<p>The ability to fully emulate a bootloader (until the BIOS interruption) with a framework like Miasm gives a sharper control over what’s
happening, possibly allow de-obfuscation, and use all the tools developed in
Miasm for this task.  It becomes for example very simple to instrument the code
in order to see the data read/written on the disk, the secrets generated,
etc.</p>

<p>Eventually, NotPetya’s bootloader code is succinct, non-obfuscated and extremely
simple (it runs in real mode, in 16 bits and calls only a few BIOS
interruptions), so it is a nice case study to play with Miasm!</p>

<h1 id="pcx86-bootloader">PC/x86 bootloader</h1>

<h2 id="introduction-1">Introduction</h2>

<p>We will only discuss here the inner workings of “old-school” BIOS bootloaders.  We
will not talk about UEFI.</p>

<p>On x86 PCs, when the machine starts, the BIOS loads the first disk sector
(named Master Boot Record, or MBR) at <code class="language-plaintext highlighter-rouge">0x7C00</code>, and then jumps to this address.
The MBR hence contains the bootloader code. At this moment, the
processor only supports 16-bit instructions and can only address memory in real
mode <sup id="fnref:4"><a href="#fn:4" class="footnote" rel="footnote" role="doc-noteref">4</a></sup>.</p>

<p>As a reminder, one disk sector contains 512 bytes. Therefore,
it is not possible to store a lot of code on this sector only. That’s
why bootloaders are usually designed in several stages. Indeed, the code in
the first sector (the first stage) will load the stage 2 code from the hard drive ,
and then jump into it.</p>

<p>Below is the MBR’s structure written by NotPetya:</p>

<p><a name="fig:notpetya_mbr"></a>
<img src="/assets/2020-08-29-miasm-bootloader/mbr-structure.png" alt="" width="500px" class="center-image" /></p>

<h2 id="notpetya-case">NotPetya case</h2>

<p>NotPetya works exactly this way. The bootstrap code (in green in the <a href="#fig:notpetya_mbr">figure
above</a>) is the assembly code below. The code at address
<code class="language-plaintext highlighter-rouge">0x7C38</code> (that we named <code class="language-plaintext highlighter-rouge">disk_read_stage2</code>), writes data in sectors 2 to 34
(inclusive) in memory at <code class="language-plaintext highlighter-rouge">0x8000</code>, and then jumps to this address:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>seg000:7C00 cli
seg000:7C01 xor ax, ax
seg000:7C03 mov ds, ax
seg000:7C05 mov ss, ax
seg000:7C07 mov es, ax
seg000:7C09 lea sp, start
seg000:7C0D sti
seg000:7C0E mov eax, 32
seg000:7C14 mov byte ptr ds:word_7C93, dl
seg000:7C18 mov ebx, 1
seg000:7C1E mov cx, 8000h
seg000:7C21 call disk_read_stage2
seg000:7C24 dec eax
seg000:7C26 cmp eax, 0
seg000:7C2A jnz short loc_7C21
seg000:7C2C mov eax, dword ptr ds:8000h
seg000:7C30 jmp far ptr 0:8000h
</code></pre></div></div>

<h1 id="emulation-with-miasm">Emulation with Miasm</h1>

<h2 id="installation">Installation</h2>

<p>The system used for these tests is Linux-based. Windows 10 users
should be able to make it work by using Windows Subsystem for Linux
(WSL), by installing for example Ubuntu using the
Windows Store <sup id="fnref:5"><a href="#fn:5" class="footnote" rel="footnote" role="doc-noteref">5</a></sup>.</p>

<p>We recommend using the version of Miasm specified in the
<code class="language-plaintext highlighter-rouge">README</code> file from the GitHub repository. At the time of writing
lines, the version used is v0.1.1. To recover this
specific version, do:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git clone --depth=1 --branch=v0.1.1 https://github.com/cea-sec/miasm/
</code></pre></div></div>

<p>We use the LLVM-based Miasm JIT engine, which needs the <code class="language-plaintext highlighter-rouge">llvmlite</code> python
package. Other needed dependencies are installable directly through the
provided <code class="language-plaintext highlighter-rouge">requirements.txt</code> file:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ cd /path/to/src &amp;&amp; pip install -r requirements.txt
</code></pre></div></div>

<p>Then just install Miasm:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ cd /path/to/miasm &amp;&amp; pip install -r requirements.txt &amp;&amp; python ./setup.py install
</code></pre></div></div>

<h2 id="implementation">Implementation</h2>

<p>All the techniques described in this article can be tried thanks to the
<code class="language-plaintext highlighter-rouge">src/emulate_mbr.py</code> script in the aforementioned GitHub repository.</p>

<p>Multiple options are provided, some of them could be used to win some time
during your experiments:</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">--dry</code>: simulates the success of disk writings, but actually writes nothing.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">--skip-encryption</code>: the encryption function (which is the hottest one) will
be ignored (actually transforming it into a function that does nothing).</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">--verbose-bios-data</code>: dumps log messages from our BIOS implementation, with
a dump of read and written disk data.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">--verbose-bios</code>: same as <code class="language-plaintext highlighter-rouge">--verbose-bios-data</code>, without the read and written
disk data.</p>
  </li>
</ul>

<p>The <code class="language-plaintext highlighter-rouge">--help</code> flag can be used to have a more detailed list of available options.</p>

<p>The activation of Miasm’s logs can considerably slow down the performances of the
overall script. The <code class="language-plaintext highlighter-rouge">--log-miasm-newblocks</code> option only dumps blocks that have
never been “jitted” by Miasm.</p>

<h2 id="creation-of-a-test-disk">Creation of a test disk</h2>

<p>We performed our tests with virtual machines running Windows
XP and Windows 10. The underlying hypervisor does not matter (VMWare,
VirtualBox), as long as the disk created has a fixed size and is using
VMDK. The emulation of the bootloader is done directly on the virtual machine’s disk. An advantage to this method is that there is
no need to extract the bootloader from the original malware DLL or
from the generated VMDK.</p>

<p class="figure"><img src="/assets/2020-08-29-miasm-bootloader/setup.png" alt="" width="400px" class="center-image" />
Emulation scenario</p>

<p>The test scenario is the following:</p>

<ol>
  <li>voluntary infection of the virtual machine with NotPetya</li>
  <li>wait for at least 10s (the machine shouldn’t reboot by itself, or the
bootloader will actually launch its encryption code)</li>
  <li>shutdown the virtual machine: the MBR has been replaced</li>
  <li>run the emulation: the MFT is encrypted by the bootloader which then displays the ransom</li>
</ol>

<p>If your virtual machine is not using a flat VMDK representation, you can convert
it using QEMU:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ qemu-img convert -f vmdk mydisk.vmdk -O raw mydisk.raw
</code></pre></div></div>

<p>We also give a test image in the aforementioned Git repository (file
<code class="language-plaintext highlighter-rouge">disk.raw.bz2</code>). Once unzipped, it is a 1GB file, and contains a simple NTFS
partition with some test files.</p>

<p>We can now emulate the NotPetya bootloader. In order to do this, we need to
emulate a BIOS capable of:</p>

<ul>
  <li>reading/writing disk sectors</li>
  <li>showing characters on the screen</li>
  <li>capturing key strokes</li>
  <li>booting on an MBR (“light” boot/reboot)</li>
</ul>

<p>We are going to see how to implement this using Miasm.</p>

<h2 id="system-abstraction">System abstraction</h2>

<p>We implement an abstraction of a simple system as seen by the BIOS. It
contains:</p>

<ul>
  <li>a virtual disk (the <code class="language-plaintext highlighter-rouge">HardDrive</code> class)</li>
  <li>a video screen, which goes through a classical Unix terminal, using the <code class="language-plaintext highlighter-rouge">stdout</code> pipe</li>
  <li>a keyboard, which uses the <code class="language-plaintext highlighter-rouge">stdin</code> pipe to gather key strokes (functions in <code class="language-plaintext highlighter-rouge">async_kb.py</code>)</li>
</ul>

<p>Abstraction is implemented in the <code class="language-plaintext highlighter-rouge">System</code> class, of which one instance is used during the emulation. This instance is initialized alongside the Miasm
VM.</p>

<h2 id="miasm-virtual-machine-initialization">Miasm virtual machine initialization</h2>

<p>As explained in the introduction, the MBR code is loaded and executed by the
BIOS at the address <code class="language-plaintext highlighter-rouge">0x7C00</code>. Then, this code will load and write its second stage
at the address <code class="language-plaintext highlighter-rouge">0x8000</code>. The left space is dedicated to the stack. It begins at
the address <code class="language-plaintext highlighter-rouge">0x500</code> and ends at the address <code class="language-plaintext highlighter-rouge">0x07C00</code>. Therefore, the corresponding
space is <code class="language-plaintext highlighter-rouge">[0x00000500:0x00007BFF]</code>.</p>

<p>First, we need to declare these memory spaces to the Miasm virtual machine:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">HD0</span> <span class="o">=</span> <span class="nc">HardDrive</span><span class="p">(</span><span class="n">hd_path</span><span class="p">)</span>
<span class="n">sys_</span> <span class="o">=</span> <span class="nc">System</span><span class="p">([</span><span class="n">HD0</span><span class="p">])</span>
<span class="n">mbr</span> <span class="o">=</span> <span class="n">HD0</span><span class="p">.</span><span class="nf">read_sector</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">stage1_addr</span> <span class="o">=</span> <span class="mh">0x07C00</span>
<span class="n">stage2_addr</span> <span class="o">=</span> <span class="mh">0x08000</span>
<span class="n">jitter</span><span class="p">.</span><span class="n">vm</span><span class="p">.</span><span class="nf">add_memory_page</span><span class="p">(</span><span class="n">stage1_addr</span><span class="p">,</span> <span class="n">PAGE_READ</span> <span class="o">|</span> <span class="n">PAGE_WRITE</span> <span class="o">|</span> <span class="n">PAGE_EXEC</span><span class="p">,</span> <span class="n">mbr</span><span class="p">,</span> <span class="sh">"</span><span class="s">NotPetyaS1</span><span class="sh">"</span><span class="p">)</span>
<span class="n">jitter</span><span class="p">.</span><span class="n">vm</span><span class="p">.</span><span class="nf">add_memory_page</span><span class="p">(</span><span class="n">stage2_addr</span><span class="p">,</span> <span class="n">PAGE_READ</span> <span class="o">|</span> <span class="n">PAGE_WRITE</span> <span class="o">|</span> <span class="n">PAGE_EXEC</span><span class="p">,</span> <span class="sh">"</span><span class="se">\x00</span><span class="sh">"</span><span class="o">*</span><span class="n">SECTOR_LEN</span><span class="o">*</span><span class="mi">32</span><span class="p">,</span> <span class="sh">"</span><span class="s">NotPetyaS2</span><span class="sh">"</span><span class="p">)</span>
<span class="n">jitter</span><span class="p">.</span><span class="n">vm</span><span class="p">.</span><span class="nf">add_memory_page</span><span class="p">(</span><span class="mh">0x500</span><span class="p">,</span> <span class="n">PAGE_READ</span> <span class="o">|</span> <span class="n">PAGE_WRITE</span><span class="p">,</span> <span class="sh">"</span><span class="se">\x00</span><span class="sh">"</span><span class="o">*</span><span class="p">(</span><span class="mh">0x7C00</span><span class="o">-</span><span class="mh">0x500</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="sh">"</span><span class="s">Stack</span><span class="sh">"</span><span class="p">)</span>
<span class="c1"># Pretty print of the memory layout
</span><span class="nf">print</span><span class="p">(</span><span class="n">jitter</span><span class="p">.</span><span class="n">vm</span><span class="p">)</span>
</code></pre></div></div>

<p>Now, the memory layout of the Miasm virtual machine is the following:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Addr               Size               Access Comment 
0x500              0x7700             RW_    Stack 
0x7C00             0x200              RWX    NotPetyaS1 
0x8000             0x4000             RWX    NotPetyaS2
</code></pre></div></div>

<p>NotPetya loads 32 sectors from the disk to the memory when executing the first stage.
This is why the allocated memory for the second stage is 32 sectors long (32*512 bytes).</p>

<h2 id="bios-interruption-handling-in-miasm">BIOS interruption handling in Miasm</h2>

<p>Miasm allows us to specify an interruption handler which will be called
whenever an <code class="language-plaintext highlighter-rouge">INT</code> instruction is executed. To do so, we have to tell Miasm to
call our BIOS interruption handler <code class="language-plaintext highlighter-rouge">exception_int</code> with the help of
<code class="language-plaintext highlighter-rouge">add_exception_handler</code> of the current used jitter:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">jitter</span><span class="p">.</span><span class="nf">add_exception_handler</span><span class="p">(</span><span class="n">EXCEPT_INT_XX</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">jitter</span><span class="p">:</span> <span class="nf">exception_int</span><span class="p">(</span><span class="n">jitter</span><span class="p">,</span> <span class="n">sys_</span><span class="p">))</span>
</code></pre></div></div>

<h2 id="interruption-support">Interruption support</h2>

<p>Now, we have to implement the different BIOS interruption handlers. We can split them into four main families :</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">INT 10h</code> : access to the screen (write characters, change colors…),</li>
  <li><code class="language-plaintext highlighter-rouge">INT 13h</code> : access to the disk (read/write sectors, get disk geometry…),</li>
  <li><code class="language-plaintext highlighter-rouge">INT 16h</code> : access to the keyboard (read keystroke…),</li>
  <li><code class="language-plaintext highlighter-rouge">INT 19h</code> : boot on the disk’s MBR.</li>
</ul>

<h3 id="int-13h">INT 13h</h3>

<p>Here is an example of the <code class="language-plaintext highlighter-rouge">INT 13h</code> interruption, with the <code class="language-plaintext highlighter-rouge">0x43</code> code function
(<code class="language-plaintext highlighter-rouge">Extended Read Sectors From Drive</code>). This code implements the instruction to load
multiple sectors from the disk to the memory:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@func</span><span class="p">(</span><span class="n">disk_interrupts</span><span class="p">,</span> <span class="mh">0x42</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">extended_read_sectors</span><span class="p">(</span><span class="n">jitter</span><span class="p">,</span> <span class="n">sys_</span><span class="p">):</span>
    <span class="n">drive_idx</span> <span class="o">=</span> <span class="nf">get_xl</span><span class="p">(</span><span class="n">jitter</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">DX</span><span class="p">)</span>
    <span class="k">print</span> <span class="sh">"</span><span class="s">Extended read sectors, drive idx 0x%x</span><span class="sh">"</span> <span class="o">%</span> <span class="n">drive_idx</span>

    <span class="n">dap</span> <span class="o">=</span> <span class="n">jitter</span><span class="p">.</span><span class="n">vm</span><span class="p">.</span><span class="nf">get_mem</span><span class="p">((</span><span class="n">jitter</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">DS</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span><span class="o">+</span><span class="n">jitter</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">SI</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>
    <span class="n">dap_size</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">num_sect</span><span class="p">,</span> <span class="n">buff_addr</span><span class="p">,</span> <span class="n">abs_sect</span> <span class="o">=</span> <span class="n">struct</span><span class="p">.</span><span class="nf">unpack</span><span class="p">(</span><span class="sh">"</span><span class="s">&lt;BBHIQ</span><span class="sh">"</span><span class="p">,</span> <span class="n">dap</span><span class="p">)</span>

    <span class="n">hd</span> <span class="o">=</span> <span class="n">sys_</span><span class="p">.</span><span class="nf">hd</span><span class="p">(</span><span class="n">drive_idx</span><span class="p">)</span>

    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">  Read %d sectors from sector %d</span><span class="sh">"</span> <span class="o">%</span> <span class="p">(</span><span class="n">num_sect</span><span class="p">,</span> <span class="n">abs_sect</span><span class="p">))</span>
    <span class="n">size</span> <span class="o">=</span> <span class="n">num_sect</span> <span class="o">*</span> <span class="n">SECTOR_LEN</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">hd</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="n">abs_sect</span> <span class="o">*</span> <span class="n">SECTOR_LEN</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>

    <span class="n">jitter</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">cf</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># No error
</span>    <span class="c1"># AL is the number of sectors read
</span>    <span class="c1"># AH is the return code, 0 = successful completion 
</span>    <span class="n">jitter</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">AX</span> <span class="o">=</span> <span class="nf">set_16bit_reg</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="nf">int</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">/</span> <span class="n">SECTOR_LEN</span><span class="p">),</span> <span class="n">high</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">jitter</span><span class="p">.</span><span class="n">vm</span><span class="p">.</span><span class="nf">set_mem</span><span class="p">(</span><span class="n">buff_addr</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
</code></pre></div></div>

<p>Note: this Python code doesn’t include error management for readability
reasons. The <code class="language-plaintext highlighter-rouge">sys_</code> object is the system abstraction explained in
<a href="#system-abstraction">System abstraction</a>.</p>

<p>Sectors can be loaded from disk in two different ways by using a different kind of
addressing mechanism for the same <code class="language-plaintext highlighter-rouge">INT 13h</code> interruption:</p>

<ol>
  <li>
    <p>CHS (Cylinder, Head, Sector) addressing mechanism, used by the <code class="language-plaintext highlighter-rouge">02h</code>/<code class="language-plaintext highlighter-rouge">03h</code>
codes. It can read/write one or many sectors by specifying the index of the
cylinder and the head,</p>
  </li>
  <li>
    <p>LBA (Logical Bloc Addressing) addressing mechanism, used by the <code class="language-plaintext highlighter-rouge">42h</code>/<code class="language-plaintext highlighter-rouge">43h</code>
codes. It can read/write one or several sectors by specifying the corresponding
sector in a absolute way, i.e. by specifying the offset from the
first sector number on the disk regardless of heads/cylinders.</p>
  </li>
</ol>

<p>NotPetya uses the LBA addressing mechanism. This method needs to fill a DAP
(Disk Address Packet) structure. This structure describes which sectors to
read/write and where to read/write them into live memory.</p>

<p>One can see that an extended LBA structure exists to read or write multiple
sectors at the same time:</p>

<table>
  <tbody>
    <tr>
      <td>0</td>
      <td>1</td>
      <td>Packet size</td>
    </tr>
    <tr>
      <td>1</td>
      <td>1</td>
      <td>Zeroed field</td>
    </tr>
    <tr>
      <td>2</td>
      <td>2</td>
      <td>Number of sectors to load</td>
    </tr>
    <tr>
      <td>4</td>
      <td>4</td>
      <td>Buffer address to load sectors to (seg:off)</td>
    </tr>
    <tr>
      <td>8</td>
      <td>8</td>
      <td>Absolute offset of the first sector to read</td>
    </tr>
  </tbody>
</table>

<p>To sum up:</p>

<ol>
  <li>the DAP is parsed,</li>
  <li>data is read from the virtual disk,</li>
  <li>the read data is stored in the corresponding memory page of the
instantiated Miasm virtual machine.</li>
</ol>

<p>The writing mechanism is the exact opposite: the specified buffer address in the
DAP contains the data to write.</p>

<h3 id="int-19h">INT 19h</h3>

<p>The second chosen example is the <code class="language-plaintext highlighter-rouge">INT 19h</code> interruption (diskboot). It
reboots the machine <sup id="fnref:7"><a href="#fn:7" class="footnote" rel="footnote" role="doc-noteref">6</a></sup><sup id="fnref:8"><a href="#fn:8" class="footnote" rel="footnote" role="doc-noteref">7</a></sup> and is used in two locations :</p>

<ol>
  <li>at address <code class="language-plaintext highlighter-rouge">0x892E</code>, which is called if a fatal error occurs,</li>
  <li>at address <code class="language-plaintext highlighter-rouge">0x820D</code>, when the machine reboots after the MFT encryption.</li>
</ol>

<p>The <code class="language-plaintext highlighter-rouge">INT 19h</code> interruption is called right after the POST (Power On Self Test)
procedure by the BIOS. After that, the MBR code is loaded into live memory at
<code class="language-plaintext highlighter-rouge">Ox7C00</code>. Then, the BIOS jumps at this address.</p>

<p>So we can say here that it is used as a sort of <em>soft reboot</em> because the reboot is
not a complete one. This instruction is part of the boot process after BIOS execution. Some BIOS can handle boot medium priority while others
just loop over available mediums and boot on the first one it can.</p>

<p>Here, we will emulate this instruction simply by loading again the MBR code
into the memory page dedicated to it (stage 1), and then jump onto it (at 
address <code class="language-plaintext highlighter-rouge">0x7C00</code>):</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">diskboot_interrupts</span> <span class="o">=</span> <span class="nc">FuncTable</span><span class="p">(</span><span class="sh">"</span><span class="s">INT 19h (diskboot)</span><span class="sh">"</span><span class="p">)</span>
<span class="nd">@func</span><span class="p">(</span><span class="n">diskboot_interrupts</span><span class="p">,</span> <span class="mh">0x02</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">reboot</span><span class="p">(</span><span class="n">jitter</span><span class="p">,</span> <span class="n">sys_</span><span class="p">):</span>
    <span class="c1"># Here, we assume only one bootable disk (index 0)
</span>    <span class="n">hd</span> <span class="o">=</span> <span class="n">sys_</span><span class="p">.</span><span class="nf">hd</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">mbr</span> <span class="o">=</span> <span class="n">hd</span><span class="p">.</span><span class="nf">read_sector</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">jitter</span><span class="p">.</span><span class="n">vm</span><span class="p">.</span><span class="nf">set_mem</span><span class="p">(</span><span class="mh">0x7C00</span><span class="p">,</span> <span class="n">mbr</span><span class="p">)</span>
    <span class="n">jitter</span><span class="p">.</span><span class="n">pc</span> <span class="o">=</span> <span class="mh">0x7C00</span>
</code></pre></div></div>

<h2 id="for-a-few-more-hacks">For a few more hacks…</h2>

<p>The <code class="language-plaintext highlighter-rouge">STI</code> (<em>Set Interrupt Flag</em>) instruction is used at address <code class="language-plaintext highlighter-rouge">0x7C0D</code>. It can
activate masked interruptions (<em>flag</em> <code class="language-plaintext highlighter-rouge">IF</code> and offset 9 of the <code class="language-plaintext highlighter-rouge">FLAGS</code> register).
This <em>flag</em> doesn’t have any effect on non-maskable interruptions. Because
hardware interruptions are fully emulated, Miasm doesn’t contain (legitimately)
semantics for this instruction.</p>

<p>So we simply decided to ignore it by setting a breakpoint at its corresponding
address:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">jitter</span><span class="p">.</span><span class="nf">add_breakpoint</span><span class="p">(</span><span class="mh">0x7C0D</span><span class="p">,</span> <span class="n">handle_sti</span><span class="p">)</span>
</code></pre></div></div>

<p>Then, we redirect the execution flow to the next instruction. Because this
instruction is only 1 byte long, a simple incrementation of the program
counter does the trick:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">handle_sti</span><span class="p">(</span><span class="n">jitter</span><span class="p">):</span>
    <span class="n">jitter</span><span class="p">.</span><span class="n">pc</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="bp">True</span>
</code></pre></div></div>

<h2 id="yippie-kay-yay-motherfucker-">Yippie kay yay motherfucker !</h2>

<p>Now that the useful handlers are implemented and the MBR code is loaded and
mapped in Miasm virtual machine, emulation of NotPetya can begin:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">jitter</span><span class="p">.</span><span class="nf">init_run</span><span class="p">(</span><span class="n">stage1_addr</span><span class="p">)</span>
<span class="n">jitter</span><span class="p">.</span><span class="nf">continue_run</span><span class="p">()</span>
</code></pre></div></div>

<p>If the <code class="language-plaintext highlighter-rouge">--verbose-bios-data</code> flag is set (see
<a href="#implementation">Implementation</a>), output of the script prints the content
of the various read and write operations on the disk.  For example, here is the
content of the second sector (of the 32 loaded sectors by the bootloader at
<code class="language-plaintext highlighter-rouge">0x8000</code>):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Extended read sectors, drive idx 0x0
  Read 1 sectors from sector 2
00000000: 50 FF 76 04 E8 91 0A 83  C4 0A E8 3B 07 CD 19 5E  P.v........;...^
00000010: C9 C3 6A 0E E8 39 07 5B  68 70 9C E8 C0 03 5B C3  ..j..9.[hp....[.
00000020: C8 04 04 00 56 6A 00 6A  01 6A 00 6A 20 8D 86 FC  ....Vj.j.j.j ...
00000030: FD 50 8A 46 06 50 E8 21  0A 83 C4 0C 6A 00 68 8E  .P.F.P.!....j.h.
[...]
</code></pre></div></div>

<p>The loaded code matchs stage 2. Also, one can easily see the
content loaded from sector 32:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Extended read sectors, drive idx 0x80
  Read 1 sectors from sector 32
00000000: 00 AA 92 E7 82 11 15 D3  20 96 A7 75 51 C0 36 08  ........ ..uQ.6.
00000010: E8 65 42 8C 73 9F 06 53  77 CB C5 95 60 C8 38 69  .eB.s..Sw...`.8i
00000020: 9B 0D A4 99 E0 13 12 30  79 31 4D 7A 37 31 35 33  .......0y1Mz7153
00000030: 48 4D 75 78 58 54 75 52  32 52 31 74 37 38 6D 47  HMuxXTuR2R1t78mG
00000040: 53 64 7A 61 41 74 4E 62  42 57 58 00 00 00 00 00  SdzaAtNbBWX.....
00000050: 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  ................
00000060: 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  ................
00000070: 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  ................
00000080: 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  ................
00000090: 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  ................
000000A0: 00 00 00 00 00 00 00 00  00 48 34 79 5A 73 77 56  .........H4yZswV
000000B0: 54 64 43 6B 43 77 55 68  72 31 4D 52 6D 4A 65 69  TdCkCwUhr1MRmJei
000000C0: 76 31 34 46 4B 39 6A 5A  6A 4D 36 36 4C 44 79 65  v14FK9jZjM66LDye
000000D0: 71 52 4C 64 6B 38 53 58  53 53 73 53 53 45 78 34  qRLdk8SXSSsSSEx4
000000E0: 44 51 57 4E 47 00 00 00  00 00 00 00 00 00 00 00  DQWNG...........
000000F0: 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  ................
[...]
000001F0: 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  ...............
</code></pre></div></div>

<p>This sector is where NotPetya stores data. According to the description
done in <a href="https://boutique.ed-diamond.com/numeros-deja-parus/1268-misc-93.html">MISC 805
n°93</a>, we can deduct its content :</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">0x00</code> is the encrypted disk flag,</li>
  <li><code class="language-plaintext highlighter-rouge">AA 92 E7 82 11 15 D3 20 96 A7 75 51 C0 36 08 E8 65 42 8C 73 9F 06 53 77 CB C5
95 60 C8 38 69</code> is the 32 bytes long Salsa20 key,</li>
  <li><code class="language-plaintext highlighter-rouge">0D A4 99 E0 13 12 30 79</code> is a 8 bytes long nonce,</li>
  <li>next data is the random string printed when the malware was
executed on Windows at the beginning.</li>
</ul>

<p>After the encryption is done by the bootloader, key and nonce are
erased from disk with 32 successive writings of zeros.</p>

<p>Moreover, we can see that sector 35 is used to store the number of total
encrypted MFT entries. For example, here is the content of sector 35 right
after the MFT header encryption:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Extended write sectors, drive idx 0x80
  Write 1 sectors at offset 35 (from memory at 0x5C74)
00000000: 01 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  ................
[...]
</code></pre></div></div>

<h2 id="retrieving-secrets-in-memory">Retrieving secrets in memory</h2>

<p>One of the advantages of emulation is the ability to easily analyze memory pages.
In our case, it is possible to retrieve the Salsa20 key used, even after
the MFT table has been encrypted (during the “false chkdsk”, see <a href="#notpetya">NotPetya</a>).</p>

<p>In fact, as explained in section <a href="#int-19h">INT 19h</a>; after the encryption is
over, the bootloader executes a “soft reboot” with the help of the interruption
<code class="language-plaintext highlighter-rouge">INT 19h</code>. It doesn’t reboot completely the computer therefore the BIOS is not
executed again. The data present in memory before the “soft reboot”
is not tampered with. If the computer goes through hard reboot or reset, there
would be great chances for the BIOS to overwrite data present on the
stack with its own, including the precious Salsa20 key.</p>

<p>So, if the computer has not been rebooted or reset, it is pretty interesting
to see if the Salsa20 key is still in memory. To do so, we simply read the key
written in sector 32 (see <a href="#yippie-kay-yay-motherfucker-">this section</a>) and
store its value. Then, we place a breakpoint on the instructions in
charge to show the ransom message, at address <code class="language-plaintext highlighter-rouge">0x85AF</code>:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">key</span> <span class="o">=</span> <span class="n">HD0</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="mi">32</span><span class="o">*</span><span class="n">SECTOR_LEN</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span> 
<span class="n">jitter</span><span class="p">.</span><span class="nf">add_breakpoint</span><span class="p">(</span><span class="mh">0x85AF</span><span class="p">,</span> <span class="n">functools</span><span class="p">.</span><span class="nf">partial</span><span class="p">(</span><span class="n">find_key_in_mem</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">))</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">find_key_in_mem</code> function browses the virtual machine memory to find the
key stored in the previous step:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">find_key_in_mem</span><span class="p">(</span><span class="n">jitter</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
    <span class="c1"># Find if the salsa20 key is still in memory!
</span>    <span class="n">mem</span> <span class="o">=</span> <span class="n">jitter</span><span class="p">.</span><span class="n">vm</span><span class="p">.</span><span class="nf">get_all_memory</span><span class="p">()</span>
      <span class="k">print</span> <span class="o">&gt;&gt;</span><span class="n">sys</span><span class="p">.</span><span class="n">stderr</span><span class="p">,</span> <span class="sh">"</span><span class="se">\n</span><span class="s">[+] Looking for key %s in memory...</span><span class="sh">"</span> <span class="o">%</span> <span class="n">key</span><span class="p">.</span><span class="nf">encode</span><span class="p">(</span><span class="sh">"</span><span class="s">hex</span><span class="sh">"</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">addr</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">mem</span><span class="p">.</span><span class="nf">iteritems</span><span class="p">():</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="sh">'</span><span class="s">data</span><span class="sh">'</span><span class="p">].</span><span class="nf">find</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">print</span> <span class="o">&gt;&gt;</span><span class="n">sys</span><span class="p">.</span><span class="n">stderr</span><span class="p">,</span> <span class="sh">"</span><span class="s">[+] Key found at address %s!</span><span class="sh">"</span> <span class="o">%</span> <span class="nf">hex</span><span class="p">(</span><span class="n">addr</span> <span class="o">+</span> <span class="n">idx</span><span class="p">)</span>
        <span class="k">break</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">print</span> <span class="o">&gt;&gt;</span><span class="n">sys</span><span class="p">.</span><span class="n">stderr</span><span class="p">,</span> <span class="sh">"</span><span class="s">[-] Key not found in memory!</span><span class="sh">"</span>
    <span class="k">return</span> <span class="bp">True</span>
</code></pre></div></div>

<p>This operation can be activated in the script using <code class="language-plaintext highlighter-rouge">--hook=find_key</code> option, like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ python ./emulate-mbr.py --hook=find_key disk.raw

Repairing file system on C:
[... encryption happends here ...]

[+] Looking for key [your salsa20 key] in memory...
[+] Key found at address 0x674a!
</code></pre></div></div>

<p>To speed up the process, the <code class="language-plaintext highlighter-rouge">--skip-encryption</code> option can be used (see
<a href="#implementation">Implementation</a>). Be careful, even if this option is used, the
encryption flag in sector 32 is still set. The flag <code class="language-plaintext highlighter-rouge">--dry</code> prevents
this behaviour.</p>

<p>Because we know the address where the key is stored (<code class="language-plaintext highlighter-rouge">0x674A</code>), we can put a
breakpoint on a write access at this location, allowing us to know which part
of the bootloader writes this key:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">print_ip</span><span class="p">(</span><span class="n">jitter</span><span class="p">):</span>
    <span class="nf">print</span><span class="p">(</span><span class="nf">hex</span><span class="p">(</span><span class="n">jitter</span><span class="p">.</span><span class="n">pc</span><span class="p">))</span>
    <span class="k">return</span> <span class="bp">False</span>

<span class="n">jitter</span><span class="p">.</span><span class="n">exceptions_handler</span><span class="p">.</span><span class="n">callbacks</span><span class="p">[</span><span class="n">EXCEPT_BREAKPOINT_MEMORY</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">jitter</span><span class="p">.</span><span class="nf">add_exception_handler</span><span class="p">(</span><span class="n">EXCEPT_BREAKPOINT_MEMORY</span><span class="p">,</span> <span class="n">print_ip</span><span class="p">)</span>
<span class="n">jitter</span><span class="p">.</span><span class="n">vm</span><span class="p">.</span><span class="nf">add_memory_breakpoint</span><span class="p">(</span><span class="mh">0x674a</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">PAGE_WRITE</span><span class="p">)</span>
</code></pre></div></div>

<p>Because there is no ASLR or equivalent mechanism, this address will always be
the same!</p>

<h2 id="bootloader-modification-to-decrypt-the-mft">Bootloader modification to decrypt the MFT</h2>

<p>If we have a mechanism to write directly into the memory of the machine (for
example by using a PCI Express card <sup id="fnref:9"><a href="#fn:9" class="footnote" rel="footnote" role="doc-noteref">8</a></sup>, or other interfaces like FireWire or
Thunderbolt <sup id="fnref:10"><a href="#fn:10" class="footnote" rel="footnote" role="doc-noteref">9</a></sup>), it is possible to decrypt the MFT data. The attack
consists in patching the bootloader memory so that its uses the remaining key on
the stack. This section simulates this attack using Miasm.</p>

<p>To do so, we will inject some code at address <code class="language-plaintext highlighter-rouge">0x82A8</code>. This function checks
that the key entered is the expected one. Given that it has been erased from
the hard drive, and that the ransom text is completely random <sup id="fnref:11"><a href="#fn:11" class="footnote" rel="footnote" role="doc-noteref">10</a></sup>, the
bootloader has in theory no way to know if the entered key is the right one. This
function will always return 0 (incorrect key). The injected code will copy the
key Salsa20 from the <code class="language-plaintext highlighter-rouge">0x674A</code> address to a specific location on the stack, so
that the decryption function at <code class="language-plaintext highlighter-rouge">0x835A</code> will use this key.  We will then jump
on this function.</p>

<p>Associated assembly code is the following:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    ; Save registers on the stack
    PUSHA
    LEA DI, WORD PTR [BP-0x44]
    LEA BX, WORD PTR [key_addr]
    XOR CX,CX

    ; Copy the key that remains on the stack to [bp-0x44]
loop:
    MOV EAX, DWORD PTR [BX]
    MOV DWORD PTR [DI], EAX 
    ADD DI, 4
    ADD BX, 4
    INC CX
    CMP CX,8
    JNZ loop

    ; Restore previously saved registers
    POPA
    ; Jump on the decryption function (CS:OFFSET =&gt; using an absolute address)
    JMP 0000:0x835A
</code></pre></div></div>

<p>We use Miasm to assemble it using the following function:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">asm_shellcode</span><span class="p">(</span><span class="n">asm</span><span class="p">,</span> <span class="n">labels</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
    <span class="n">machine</span> <span class="o">=</span> <span class="nc">Machine</span><span class="p">(</span><span class="sh">"</span><span class="s">x86_16</span><span class="sh">"</span><span class="p">)</span>
    <span class="n">symbol_pool</span> <span class="o">=</span> <span class="n">asmblock</span><span class="p">.</span><span class="nc">AsmSymbolPool</span><span class="p">()</span>

    <span class="c1"># Assemble
</span>    <span class="n">blocks</span><span class="p">,</span> <span class="n">symbol_pool</span> <span class="o">=</span> <span class="n">parse_asm</span><span class="p">.</span><span class="nf">parse_txt</span><span class="p">(</span><span class="n">machine</span><span class="p">.</span><span class="n">mn</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="n">asm</span><span class="p">,</span> <span class="n">symbol_pool</span><span class="p">)</span>

    <span class="c1"># Set custom labels
</span>    <span class="k">if</span> <span class="ow">not</span> <span class="n">labels</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span><span class="n">value</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">.</span><span class="nf">iteritems</span><span class="p">():</span>
            <span class="n">sym</span> <span class="o">=</span> <span class="n">symbol_pool</span><span class="p">.</span><span class="nf">getby_name</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="n">symbol_pool</span><span class="p">.</span><span class="nf">set_offset</span><span class="p">(</span><span class="n">sym</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="c1"># Resolve all the labels
</span>    <span class="n">patches</span> <span class="o">=</span> <span class="n">asmblock</span><span class="p">.</span><span class="nf">asm_resolve_final</span><span class="p">(</span><span class="n">machine</span><span class="p">.</span><span class="n">mn</span><span class="p">,</span>
                                         <span class="n">blocks</span><span class="p">,</span>
                                         <span class="n">symbol_pool</span><span class="p">)</span>

    <span class="c1"># Patch the final code with the label values
</span>    <span class="n">shellcode</span> <span class="o">=</span> <span class="nc">StrPatchwork</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">offset</span><span class="p">,</span> <span class="n">raw</span> <span class="ow">in</span> <span class="n">patches</span><span class="p">.</span><span class="nf">items</span><span class="p">():</span>
        <span class="n">shellcode</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span> <span class="o">=</span> <span class="n">raw</span>
    <span class="k">return</span> <span class="nf">str</span><span class="p">(</span><span class="n">shellcode</span><span class="p">)</span>
</code></pre></div></div>

<p>Let’s take a look at this function. The code is first assembled using an x86
16-bit assembler.  Given labels are then associated to concrete values using the <code class="language-plaintext highlighter-rouge">symbol_pool.set_offset</code> function.  Remaining labels (in our case
<code class="language-plaintext highlighter-rouge">loop</code>) are resolved with the <code class="language-plaintext highlighter-rouge">asmblock.asm_resolve_final</code> function, which
returns assembly code for each block.  We finally use the <code class="language-plaintext highlighter-rouge">StrPatchwork</code>
function to assemble the final “shellcode”.</p>

<p>The <code class="language-plaintext highlighter-rouge">read_key_and_patch</code> function loads the key in memory, dumps it and writes
the freshly assembled code in memory:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">read_key_and_patch</span><span class="p">(</span><span class="n">jitter</span><span class="p">):</span>
    <span class="c1"># Key is still in the stack, at 0x674A. You can find this value by activating the
</span>    <span class="c1"># find_key_in_mem breakpoint!
</span>    <span class="n">key_addr</span> <span class="o">=</span> <span class="mh">0x674A</span>
    <span class="n">key</span> <span class="o">=</span> <span class="n">jitter</span><span class="p">.</span><span class="n">vm</span><span class="p">.</span><span class="nf">get_mem</span><span class="p">(</span><span class="n">key_addr</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>
    <span class="k">print</span> <span class="o">&gt;&gt;</span><span class="n">sys</span><span class="p">.</span><span class="n">stderr</span><span class="p">,</span> <span class="sh">"</span><span class="se">\n</span><span class="s">[+] Key from memory: %s</span><span class="sh">"</span> <span class="o">%</span> <span class="n">key</span><span class="p">.</span><span class="nf">encode</span><span class="p">(</span><span class="sh">"</span><span class="s">hex</span><span class="sh">"</span><span class="p">)</span>

    <span class="c1"># Assemble our "shellcode" thanks to Miasm!
</span>    <span class="n">shellcode</span> <span class="o">=</span> <span class="sh">"""</span><span class="s">
</span><span class="gp">...</span>
    <span class="sh">"""</span>
    <span class="n">shellcode</span> <span class="o">=</span> <span class="nf">asm_shellcode</span><span class="p">(</span><span class="n">shellcode</span><span class="p">,</span> <span class="p">{</span><span class="sh">"</span><span class="s">key_addr</span><span class="sh">"</span><span class="p">:</span> <span class="n">key_addr</span><span class="p">})</span>

    <span class="c1"># Patch the bootloader in memory to decrypt using the key
</span>    <span class="n">jitter</span><span class="p">.</span><span class="n">vm</span><span class="p">.</span><span class="nf">set_mem</span><span class="p">(</span><span class="mh">0x82A8</span><span class="p">,</span> <span class="n">shellcode</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">True</span>
</code></pre></div></div>

<p>The remaining thing to do is to put a breakpoint at the same address as in section
<a href="#retrieving-secrets-in-memory">Retrieving secrets in memory</a> (<code class="language-plaintext highlighter-rouge">0x85AF</code>) to call this function:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">jitter</span><span class="p">.</span><span class="nf">add_breakpoint</span><span class="p">(</span><span class="mh">0x85AF</span><span class="p">,</span> <span class="n">read_key_and_patch</span><span class="p">)</span>
</code></pre></div></div>

<p>Everything is now set up. When the bootloader asks for the decryption key, user will just have to press <code class="language-plaintext highlighter-rouge">enter</code>.
<code class="language-plaintext highlighter-rouge">--hook=patch_bootloader</code> flag of the
<code class="language-plaintext highlighter-rouge">emulate_mbr</code> script performs this attack.</p>

<p>It is worth mentioning that <a href="https://airbus-seclab.github.io/ilo/Whitepaper-Defeating_NotPetya_from_your_iLO4-guinet-perigaud-gazet-czarny.pdf">we actually tried
this</a>
at <a href="https://synacktiv.com">Synacktiv</a>’s headquarters using vulnerabilities in
HP’s iLO4 to gather the Salsa20 key from memory, patch the bootloader and
decrypt MFT data.</p>

<h2 id="encryption-keystream-study">Encryption keystream study</h2>

<p>The encryption algorithm used is Salsa20 stream cipher. The general
principle is: a random data flow based on a key - commonly called the
keystream - is generated, and this stream is XORed with the data which will be
encrypted. An advantage of stream ciphers is that the data to be encrypted do not
need to be padded. On the other hand, one needs to be careful not to use the
same parts of this stream twice.</p>

<p class="figure"><img src="/assets/2020-08-29-miasm-bootloader/s20-expand.png" alt="" width="400px" class="center-image" />
Data encryption with Salsa20</p>

<p>We can verify this using Miasm, by looking at the data before and after
encryption, and by showing their XOR difference.</p>

<p>In order to do this, we already know how to put breakpoints. The beginning of
the encryption function is at address <code class="language-plaintext highlighter-rouge">0x9798</code>, and the end at address
<code class="language-plaintext highlighter-rouge">0x9877</code>. We are going to out the first breakpoint just after ‘enter<code class="language-plaintext highlighter-rouge">
instruction, and the second just before </code>leave` statement, in order to have
the stack properly aligned to recover data before and after encryption. The
associated code is the following:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">_last_buf</span> <span class="o">=</span> <span class="bp">None</span>
<span class="k">def</span> <span class="nf">encrypt_start</span><span class="p">(</span><span class="n">jitter</span><span class="p">,</span> <span class="n">options</span><span class="p">):</span>
    <span class="k">global</span> <span class="n">_last_buf</span>
    <span class="n">buf_ptr</span>  <span class="o">=</span> <span class="nf">upck16</span><span class="p">(</span><span class="n">jitter</span><span class="p">.</span><span class="n">vm</span><span class="p">.</span><span class="nf">get_mem</span><span class="p">((</span><span class="n">jitter</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">SS</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="n">jitter</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">BP</span> <span class="o">+</span> <span class="mh">0xC</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">buf_size</span> <span class="o">=</span> <span class="nf">upck16</span><span class="p">(</span><span class="n">jitter</span><span class="p">.</span><span class="n">vm</span><span class="p">.</span><span class="nf">get_mem</span><span class="p">((</span><span class="n">jitter</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">SS</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="n">jitter</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">BP</span> <span class="o">+</span> <span class="mh">0xE</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">_last_buf</span> <span class="o">=</span> <span class="n">jitter</span><span class="p">.</span><span class="n">vm</span><span class="p">.</span><span class="nf">get_mem</span><span class="p">((</span><span class="n">jitter</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">DS</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="n">buf_ptr</span><span class="p">,</span> <span class="n">buf_size</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">True</span>

<span class="k">def</span> <span class="nf">encrypt_end</span><span class="p">(</span><span class="n">jitter</span><span class="p">,</span> <span class="n">options</span><span class="p">):</span>
    <span class="k">global</span> <span class="n">_last_buf</span>
    <span class="n">buf_ptr</span>  <span class="o">=</span> <span class="nf">upck16</span><span class="p">(</span><span class="n">jitter</span><span class="p">.</span><span class="n">vm</span><span class="p">.</span><span class="nf">get_mem</span><span class="p">((</span><span class="n">jitter</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">SS</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="n">jitter</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">BP</span> <span class="o">+</span> <span class="mh">0xC</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">buf_size</span> <span class="o">=</span> <span class="nf">upck16</span><span class="p">(</span><span class="n">jitter</span><span class="p">.</span><span class="n">vm</span><span class="p">.</span><span class="nf">get_mem</span><span class="p">((</span><span class="n">jitter</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">SS</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="n">jitter</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">BP</span> <span class="o">+</span> <span class="mh">0xE</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">encr_buf</span> <span class="o">=</span> <span class="n">jitter</span><span class="p">.</span><span class="n">vm</span><span class="p">.</span><span class="nf">get_mem</span><span class="p">((</span><span class="n">jitter</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">DS</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="n">buf_ptr</span><span class="p">,</span> <span class="n">buf_size</span><span class="p">)</span>
    <span class="n">keystream</span> <span class="o">=</span> <span class="sh">''</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="nf">chr</span><span class="p">(</span><span class="nf">ord</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">^</span><span class="nf">ord</span><span class="p">(</span><span class="n">b</span><span class="p">))</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span> <span class="ow">in</span> <span class="nf">zip</span><span class="p">(</span><span class="n">_last_buf</span><span class="p">,</span><span class="n">encr_buf</span><span class="p">)).</span><span class="nf">encode</span><span class="p">(</span><span class="sh">"</span><span class="s">hex</span><span class="sh">"</span><span class="p">)</span>
    <span class="n">keystream</span> <span class="o">=</span> <span class="sh">'</span><span class="s"> </span><span class="sh">'</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="n">keystream</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">4</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nf">len</span><span class="p">(</span><span class="n">keystream</span><span class="p">),</span><span class="mi">4</span><span class="p">))</span>
    <span class="k">print</span> <span class="o">&gt;&gt;</span><span class="n">sys</span><span class="p">.</span><span class="n">stderr</span><span class="p">,</span> <span class="sh">"</span><span class="s">Keystream for next 2 sectors: %s</span><span class="sh">"</span> <span class="o">%</span> <span class="n">keystream</span>
    <span class="k">return</span> <span class="bp">True</span>

<span class="n">jitter</span><span class="p">.</span><span class="nf">add_breakpoint</span><span class="p">(</span><span class="mh">0x979C</span><span class="p">,</span> <span class="n">functools</span><span class="p">.</span><span class="nf">partial</span><span class="p">(</span><span class="n">encrypt_start</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="n">options</span><span class="p">))</span>
<span class="n">jitter</span><span class="p">.</span><span class="nf">add_breakpoint</span><span class="p">(</span><span class="mh">0x9876</span><span class="p">,</span> <span class="n">functools</span><span class="p">.</span><span class="nf">partial</span><span class="p">(</span><span class="n">encrypt_end</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="n">options</span><span class="p">))</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">--dump-keystream</code> flag of the <code class="language-plaintext highlighter-rouge">emulate_mbr</code> script enables this.</p>

<p>By looking at the output, we can see that between two sectors
(<code class="language-plaintext highlighter-rouge">2*512</code> bytes), the keystream is only shifted by two bytes, instead of the
normally required <code class="language-plaintext highlighter-rouge">2*512</code> bytes. This shift is schematized in the image below:</p>

<p><img src="/assets/2020-08-29-miasm-bootloader/keystream.png" alt="" width="400px" class="center-image" /></p>

<p>We can also see that on a screenshot of the output of the <code class="language-plaintext highlighter-rouge">emulate_mbr</code> script
below:</p>

<p class="figure"><img src="/assets/2020-08-29-miasm-bootloader/keystream_screenshot.png" alt="" />
Screenshot of the keystream</p>

<p>Thus, parts of the keystream are reused between sectors, which may help to
recover some of its original data.</p>

<p>Indeed, if we consider <code class="language-plaintext highlighter-rouge">p</code> to be the clear text,<code class="language-plaintext highlighter-rouge"> k</code> the keystream and <code class="language-plaintext highlighter-rouge">c</code> the
encrypted text, then the encryption function <code class="language-plaintext highlighter-rouge">E</code> is defined as<code class="language-plaintext highlighter-rouge"> E (p) = p xor k
= c</code>. A part of the MFT structures being invariant and known, it is therefore
possible, in two sectors, to find part of the keystream used for these two
sectors. This one is reused for the two following sectors by being simply
shifted by two bytes, so some of the clear text from these other areas can be
found.</p>

<p>This vulnerability in the Salsa20 implementation of the bootloader has been
exploited by <a href="https://www.crowdstrike.com/blog/full-decryption-systems-encrypted-petya-notpetya/">CrowdStrike</a> to recover a large portion of MFT’s
original data (between 98.10% and 99.97% depending on the method).</p>

<h1 id="conclusion">Conclusion</h1>

<p>Emulation of the NotPetya bootloader code allows the verification of various
assumptions and the understanding, in a very tangible way, of the different
steps related to the encryption of MFT entries. In addition, it allows to
easily find the bias in the Salsa20 keystream implementation (without having
to statically reverse the algorithm), or to simulate the recovery of the key, which
remains in memory after the encryption.</p>

<p>This article only shows a small subset of Miasm’s possibilities, and
we hope that the approach adopted in this article will encourage uninitiated
readers to try and play with it :).</p>

<h1 id="acknowledgments">Acknowledgments</h1>

<p>We would like to thank gapz for his initial encouragement. Big thanks also to
Camille Mougey and Fabrice Desclaux for their help and thorough reviews of this
article! Thanks to Thomas Chauchefoin and zerk for their comments, and to Yseult for her help with the English translation.</p>

<h1 id="appendix-application-using-vulnerabilities-in-hp-ilo-4">Appendix: application using vulnerabilities in HP iLO 4</h1>

<p>With Alexandre Gazet &amp; <a href="https://twitter.com/0xf4b">Fabien Perigaud</a>, we spent
some time in <a href="https://synacktiv.com">Synacktiv</a>’s offices to combine the
attacks described in this article with <a href="https://github.com/airbus-seclab/ilo4_toolbox">vulnerabilities they
found</a> with <a href="https://twitter.com/_Sn0rkY">Joffrey
Czarny</a> on HP iLO 4’s management engine. These
vulnerabilities allowed us to read and write the memory of an infected server
stuck at NotPetya’s bootloader stage, so that we were able to recover the
encryption key and patch the bootloader in order to decrypt the MFT.</p>

<p>A full write up of the experiment can be read on <a href="https://airbus-seclab.github.io/ilo/Whitepaper-Defeating_NotPetya_from_your_iLO4-guinet-perigaud-gazet-czarny.pdf">Airbus seclab
website</a>.</p>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1">
      <p><a href="https://fr.wikipedia.org/wiki/Master_File_Table">https://fr.wikipedia.org/wiki/Master_File_Table</a> <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2">
      <p><a href="https://shasaurabh.blogspot.fr/2017/07/debugging-mbr-ida-pro-and-bochs-emulator.html">https://shasaurabh.blogspot.fr/2017/07/debugging-mbr-ida-pro-and-bochs-emulator.html</a> <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3">
      <p><a href="https://www.sstic.org/2012/presentation/miasm_framework_de_reverse_engineering/">https://www.sstic.org/2012/presentation/miasm_framework_de_reverse_engineering/</a> <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:4">
      <p><a href="https://fr.wikipedia.org/wiki/Mode_r%C3%A9el">https://fr.wikipedia.org/wiki/Mode_r%C3%A9el</a> <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:5">
      <p><a href="https://docs.microsoft.com/en-us/windows/wsl/install-win10">https://docs.microsoft.com/en-us/windows/wsl/install-win10</a> <a href="#fnref:5" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:7">
      <p><a href="https://wiki.osdev.org/ATA_in_x86_RealMode_(BIOS))">https://wiki.osdev.org/ATA_in_x86_RealMode_(BIOS))</a> <a href="#fnref:7" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:8">
      <p><a href="http://webpages.charter.net/danrollins/techhelp/0243.HTM">http://webpages.charter.net/danrollins/techhelp/0243.HTM</a> <a href="#fnref:8" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:9">
      <p><a href="https://www.sstic.org/media/SSTIC2011/SSTIC-actes/attaques_dma_peer-to-peer_et_contremesures/SSTIC2011-Article-attaques_dma_peer-to-peer_et_contremesures-lone-sang_duflot_nicomette_deswarte.pdf">https://www.sstic.org/media/SSTIC2011/SSTIC-actes/attaques_dma_peer-to-peer_et_contremesures/SSTIC2011-Article-attaques_dma_peer-to-peer_et_contremesures-lone-sang_duflot_nicomette_deswarte.pdf</a> <a href="#fnref:9" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:10">
      <p><a href="https://github.com/carmaa/inception">https://github.com/carmaa/inception</a> <a href="#fnref:10" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:11">
      <p><a href="https://www.crowdstrike.com/blog/petrwrap-ransomware-technical-analysis-triple-threat-file-encryption-mft-encryption-credential-theft/">https://www.crowdstrike.com/blog/petrwrap-ransomware-technical-analysis-triple-threat-file-encryption-mft-encryption-credential-theft/</a> <a href="#fnref:11" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name>adrien_guinet, jordan_bouyat</name></author><category term="blog" /><summary type="html"><![CDATA[NotPetya is a famous malware of the Petya family. It appeared in June 2017. The part running from the Master Boot Record (MBR) has been statically and dynamically studied, using for instance the Bochs debugger from IDA. Is another approach possible? This article’s goal is to show that we can emulate this bootloader using Miasm.]]></summary></entry></feed>