<!DOCTYPE html>
<html lang="en"><!--
 __  __                __                                     __
/\ \/\ \              /\ \             __                    /\ \
\ \ \_\ \   __  __    \_\ \      __   /\_\      __       ___ \ \ \/'\
 \ \  _  \ /\ \/\ \   /'_` \   /'__`\ \/\ \   /'__`\    /'___\\ \ , <
  \ \ \ \ \\ \ \_\ \ /\ \L\ \ /\  __/  \ \ \ /\ \L\.\_ /\ \__/ \ \ \\`\
   \ \_\ \_\\/`____ \\ \___,_\\ \____\ _\ \ \\ \__/.\_\\ \____\ \ \_\ \_\
    \/_/\/_/ `/___/> \\/__,_ / \/____//\ \_\ \\/__/\/_/ \/____/  \/_/\/_/
                /\___/                \ \____/
                \/__/                  \/___/

Powered by Hydejack v9.2.1 <https://hydejack.com/>
--><head><title>Donjon CTF SSSGX write-up: linear functions strike back |</title><meta name="description" content="This writeup presents a solution to the SSSGX Wallet stage of the 2020 Ledger Donjon’s CTF. It showcases a solution using a kind of generic method to exploit the issues that we are facing in this challenge, which can basically be reduced to solving a linear system in the vector space \(\{0,1\}^N\). "><link rel="canonical" href="https://aguinet.github.io/blog/2020/11/22/donjon-ctf-sssgx.html"><meta name="color-scheme" content="light"><meta name="theme-color" content="rgb(0,0,0)"><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content=""><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="application-name" content=""><meta name="generator" content="Hydejack v9.2.1" /><link rel="alternate" href="https://aguinet.github.io/blog/2020/11/22/donjon-ctf-sssgx.html" hreflang="en"><link type="application/atom+xml" rel="alternate" href="https://aguinet.github.io/feed.xml" title="" /><link rel="shortcut icon" href="/assets/icons/favicon.ico"><link rel="apple-touch-icon" href="/assets/icons/icon-192x192.png"><link rel="manifest" href="/assets/site.webmanifest"><link rel="preload" href="/assets/img/swipe.svg" as="image" id="_hrefSwipeSVG"> <script>((r,a)=>{function d(e,t,n,o){e.addEventListener?e.addEventListener(t,n,o):e.attachEvent?e.attachEvent("on"+t,n):e["on"+t]=n}r.loadJS=function(e,t){var n=a.createElement("script"),e=(n.src=e,t&&d(n,"load",t,{once:!0}),a.scripts[0]);return e.parentNode.insertBefore(n,e),n},r._loaded=!1,r.loadJSDeferred=function(e,t){var n=a.createElement("script");function o(){r._loaded=!0,t&&d(n,"load",t,{once:!0});var e=a.scripts[0];e.parentNode.insertBefore(n,e)}return n.src=e,r._loaded?o():d(r,"load",o,{once:!0}),n},r.setRel=r.setRelStylesheet=function(e){d(a.getElementById(e),"load",function(){this.rel="stylesheet"},{once:!0})}})(window,document); !function(a){"use strict";var b=function(b,c,d){function e(a){return h.body?a():void setTimeout(function(){e(a)})}function f(){i.addEventListener&&i.removeEventListener("load",f),i.media=d||"all"}var g,h=a.document,i=h.createElement("link");if(c)g=c;else{var j=(h.body||h.getElementsByTagName("head")[0]).childNodes;g=j[j.length-1]}var k=h.styleSheets;i.rel="stylesheet",i.href=b,i.media="only x",e(function(){g.parentNode.insertBefore(i,c?g:g.nextSibling)});var l=function(a){for(var b=i.href,c=k.length;c--;)if(k[c].href===b)return a();setTimeout(function(){l(a)})};return i.addEventListener&&i.addEventListener("load",f),i.onloadcssdefined=l,l(f),i};"undefined"!=typeof exports?exports.loadCSS=b:a.loadCSS=b}("undefined"!=typeof global?global:this); !function(a){if(a.loadCSS){var b=loadCSS.relpreload={};if(b.support=function(){try{return a.document.createElement("link").relList.supports("preload")}catch(b){return!1}},b.poly=function(){for(var b=a.document.getElementsByTagName("link"),c=0;c<b.length;c++){var d=b[c];"preload"===d.rel&&"style"===d.getAttribute("as")&&(a.loadCSS(d.href,d,d.getAttribute("media")),d.rel=null)}},!b.support()){b.poly();var c=a.setInterval(b.poly,300);a.addEventListener&&a.addEventListener("load",function(){b.poly(),a.clearInterval(c)}),a.attachEvent&&a.attachEvent("onload",function(){a.clearInterval(c)})}}}(this); !function(w) { w._baseURL = '/'; w._publicPath = '/assets/js/'; w._noPushState = false; w._noDrawer = true; w._noNavbar = true; w._noToc = false; w._noSearch = false; w._search = { DATA_URL: '/assets/sitedata.json?no-cache', STORAGE_KEY: 'mini-search/', INDEX_KEY: 'index--2025-09-28T16:42:06+02:00', }; w._clapButton = false; }(window);</script> <script async src="/assets/bower_components/MathJax/es5/tex-mml-chtml.js" id="_MathJax"></script> <!--[if gt IE 8]><!----><style id="_styleInline"> .clearfix,.sidebar-social::after{content:"";display:table;clear:both}.color-transition,.content .avatar,.nav-btn,.nav-btn-bar,.navbar,.message,.note-sm,#markdown-toc,.note,.hr-bottom,.hr-after::after,hr,.hr,p,body{transition:none}#_dark-mode{font-size:1.25rem}@media screen{body,body.light-mode{--body-color: #333;--body-bg: #fff;--border-color: #ebebeb;--gray: #777;--gray-bg: rgba(0, 0, 0, 0.025);--gray-text: #666;--menu-text: #bbb;--inv-body-color: #ccc;--inv-body-bg: var(--dark-mode-body-bg)}body .content,body.light-mode .content{-webkit-font-smoothing:initial;-moz-osx-font-smoothing:initial}body.dark-mode{--body-color: #ccc;--body-bg: var(--dark-mode-body-bg);--border-color: var(--dark-mode-border-color);--gray: rgba(255,255,255,.5);--gray-bg: rgba(255,255,255,.033);--gray-text: rgba(255,255,255,.625);--menu-text: rgba(255,255,255,.25);--inv-body-color: #333;--inv-body-bg: #fff}body.dark-mode .content{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}}html{--font-family: system-ui, -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Oxygen, Ubuntu, Cantarell, Fira Sans, Droid Sans, Helvetica Neue, Arial, sans-serif;--font-family-heading: system-ui, -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Oxygen, Ubuntu, Cantarell, Fira Sans, Droid Sans, Helvetica Neue, Arial, sans-serif;--code-font-family: ui-monospace, Menlo, Monaco, Cascadia Mono, Segoe UI Mono, Roboto Mono, Oxygen Mono, Ubuntu Mono, Source Code Pro, Fira Mono, Droid Sans Mono, Consolas, Courier New, monospace;--root-font-size: 15px;--root-font-size-medium: 16px;--root-font-size-large: 17px;--root-font-size-print: 8pt;--root-line-height: 1.75;--font-weight: 400;--font-weight-bold: 700;--font-weight-heading: 900;--content-width-5: 54rem;--content-margin-5: 4rem;--sidebar-width: 21rem;--half-content: 31rem;--break-point-3: 64em;--break-point-5: 86em;--break-point-dynamic: 104rem}*{box-sizing:border-box}html,body{margin:0;padding:0}html{font-family:var(--font-family);font-size:var(--root-font-size);line-height:var(--root-line-height)}body{color:var(--body-color);background-color:var(--body-bg);font-weight:var(--font-weight);overflow-y:scroll}.content img,.img,.content video,.video{max-width:100%;height:auto}.lead{margin-left:-1rem;margin-right:-1rem;margin-bottom:1.5rem}img.lead,video.lead{display:block;max-width:calc(100% + 2rem);width:calc(100% + 2rem);height:auto}.heading,.f6,h6,.h6,.f5,h5,.h5,.f4,.sidebar-nav-item,h4,.h4,.post-date,.f3,h3,.h3,.f2,h2,.h2,.f1,h1,.h1{font-family:var(--font-family-heading);font-weight:var(--font-weight-heading)}.f1,h1,.h1{font-size:2rem;line-height:1.3}.f2,h2,.h2{font-size:1.5rem;line-height:1.4}.f3,h3,.h3{font-size:1.2em;line-height:1.5}.f4,.sidebar-nav-item,h4,.h4,.post-date{font-size:1.08rem;line-height:1.6}.f5,h5,.h5{font-size:1.04rem;line-height:1.7}.f6,h6,.h6{font-size:1rem}.content h1>a,.content .h1>a{text-decoration:none;border-bottom:none}@media screen and (max-width: 42em){.content h1,.content .h1{font-size:1.7rem;line-height:1.35}}@media screen and (min-width: 86em){.content h1,.content .h1{font-size:2.4rem;line-height:1.25}}@media screen and (min-width: 104rem){body:not(.no-large-headings) .content h1,body:not(.no-large-headings) .content .h1{width:calc(100% + 50vw - 32rem);font-size:3rem;line-height:1.2}}@media screen and (min-width: 124em){body:not(.no-large-headings) .content h1,body:not(.no-large-headings) .content .h1{font-size:4rem;line-height:1.1}}h1,h2,h3,.h1,.h2,.h3{margin:4rem 0 1rem}h4,h5,h6,.h4,.post-date,.h5,.h6{margin:3rem 0 .5rem}p{margin-top:0;margin-bottom:1rem}p.lead{font-size:1.2em;margin-top:1.5rem;margin-bottom:1.5rem;padding:0 1rem}ul,ol,dl{margin-top:0;margin-bottom:1rem}ul,ol{padding-left:1.25rem}hr,.hr{border:0;margin:1rem 0;border-top:1px solid var(--border-color)}.hr-after::after{content:"";display:block;margin:1rem 0;border-top:1px solid var(--border-color)}.hr-bottom{border-bottom:1px solid var(--border-color);padding-bottom:.75rem;margin-bottom:1rem}.page{margin-bottom:3em}.page li+li{margin-top:.25rem}.page>header{position:relative;margin-bottom:2rem}@media screen and (min-width: 104rem){body:not(.no-third-column) .page>header>.lead+.note-sm,body:not(.no-third-column) .page>header>.lead+#markdown-toc,body:not(.no-third-column) .page>header>.lead+.note,body:not(.no-third-column) .page>header>a.no-hover+.note-sm,body:not(.no-third-column) .page>header>a.no-hover+#markdown-toc,body:not(.no-third-column) .page>header>a.no-hover+.note{position:absolute;right:-25rem;width:21rem;bottom:0;margin-bottom:0}}.page-title,.post-title{margin-top:0}.post-date{display:flex;justify-content:space-between;margin-top:-0.6rem;height:2rem;margin-bottom:.85rem;color:var(--gray)}.post-date>.ellipsis,.post-date#breadcrumbs>ul{cursor:pointer}.post-date [class^=icon-]{display:inline-block;font-size:smaller;margin-right:.25rem}.related-posts{padding-left:0;list-style:none;margin-bottom:2rem}.related-posts>li,.related-posts>li+li{margin-top:1rem}.message,.note-sm,#markdown-toc,.note{margin-bottom:1rem;padding:1rem;color:var(--gray-text);background-color:var(--gray-bg);margin-left:-1rem;margin-right:-1rem}.note-sm,#markdown-toc,.note{background:rgba(0,0,0,0);color:var(--body-color);font-size:smaller;border-left:1px solid var(--border-color);padding:1.2rem 1rem 0 1rem;margin:1rem -1rem;position:relative}.note-sm:before,#markdown-toc:before,.note:before{font-size:.667rem;font-weight:bold;font-style:normal;letter-spacing:.025rem;text-transform:uppercase;color:var(--menu-text);position:absolute;top:0}.note-sm[title]:before,[title]#markdown-toc:before,[title].note:before{content:attr(title) !important}.note{font-size:1rem}@media screen{body::before{content:"";width:.5rem;background:var(--gray-bg);position:fixed;left:0;top:0;bottom:0}}@media(min-width: 64em){body::before{width:21rem}}@media(min-width: 104rem){body::before{width:calc(50% - 31rem)}}@media screen and (min-width: 42em){html{font-size:var(--root-font-size-medium)}}@media screen and (min-width: 124em){html{font-size:var(--root-font-size-large)}}#breadcrumbs>ul{height:1rem;margin:-1.5rem 0 .5rem;padding:0;font-size:.667rem;color:var(--menu-text);text-transform:uppercase;width:100%;list-style:none}#breadcrumbs>ul>li{display:inline}#breadcrumbs>ul>li a{color:var(--gray);text-decoration:none;border-bottom:none}.fl{float:left}.fr{float:right}.mb4{margin-bottom:4rem}.mb6{margin-bottom:6rem}.mt0{margin-top:0}.mt1{margin-top:1rem}.mt2{margin-top:2rem}.mt3{margin-top:3rem}.mt4{margin-top:4rem}.pb0{padding-bottom:0}.ml1{margin-left:1rem}.mr1{margin-right:1rem}.sixteen-nine{position:relative}.sixteen-nine::before{display:block;content:"";width:100%;padding-top:56.25%}.sixteen-nine>*{position:absolute;top:0;left:0;right:0;bottom:0}.sixteen-ten{position:relative}.sixteen-ten::before{display:block;content:"";width:100%;padding-top:62.5%}.sixteen-ten>*{position:absolute;top:0;left:0;right:0;bottom:0}.four-three{position:relative}.four-three::before{display:block;content:"";width:100%;padding-top:75%}.four-three>*{position:absolute;top:0;left:0;right:0;bottom:0}.sr-only{display:none}.larger{font-size:larger}.smaller{font-size:smaller}.clearfix,.sidebar-social::after{content:"";display:table;clear:both}.ellipsis,#breadcrumbs>ul{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.border{border:1px solid var(--border-color)}@media(min-width: 42em){.border-radius,.lead,.page .aspect-ratio.sixteen-nine.lead{border-radius:.5rem}}.fallback-img{background-position:center;background-repeat:no-repeat;background-image:url("data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPHN2ZyB3aWR0aD0iMTYwIiBoZWlnaHQ9IjkwIiB2aWV3Qm94PSIwIDAgMTYwIDkwIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgogIDxnIHRyYW5zZm9ybT0ibWF0cml4KDAuMDQ4ODI4LCAwLCAwLCAwLjA0Nzk5MSwgNTQuOTk5OTczLCAyMC40MjgxNDgpIj4KICAgIDxwYXRoIHN0eWxlPSJmaWxsOnJnYmEoMTI4LDEyOCwxMjgsLjMzKSIgZD0iTTk1OS44ODQgMTI4YzAuMDQwIDAuMDM0IDAuMDgyIDAuMDc2IDAuMTE2IDAuMTE2djc2Ny43N2MtMC4wMzQgMC4wNDAtMC4wNzYgMC4wODItMC4xMTYgMC4xMTZoLTg5NS43N2MtMC4wNDAtMC4wMzQtMC4wODItMC4wNzYtMC4xMTQtMC4xMTZ2LTc2Ny43NzJjMC4wMzQtMC4wNDAgMC4wNzYtMC4wODIgMC4xMTQtMC4xMTRoODk1Ljc3ek05NjAgNjRoLTg5NmMtMzUuMiAwLTY0IDI4LjgtNjQgNjR2NzY4YzAgMzUuMiAyOC44IDY0IDY0IDY0aDg5NmMzNS4yIDAgNjQtMjguOCA2NC02NHYtNzY4YzAtMzUuMi0yOC44LTY0LTY0LTY0djB6Ii8+CiAgICA8cGF0aCBzdHlsZT0iZmlsbDpyZ2JhKDEyOCwxMjgsMTI4LC4zMykiIGQ9Ik04MzIgMjg4YzAgNTMuMDIwLTQyLjk4IDk2LTk2IDk2cy05Ni00Mi45OC05Ni05NiA0Mi45OC05NiA5Ni05NiA5NiA0Mi45OCA5NiA5NnoiLz4KICAgIDxwYXRoIHN0eWxlPSJmaWxsOnJnYmEoMTI4LDEyOCwxMjgsLjMzKSIgZD0iTTg5NiA4MzJoLTc2OHYtMTI4bDIyNC0zODQgMjU2IDMyMGg2NGwyMjQtMTkyeiIvPgogIDwvZz4KPC9zdmc+")}hy-push-state a{color:var(--body-color)}@supports not ((text-decoration-thickness: initial) and (text-underline-offset: initial)){hy-push-state a{text-decoration:none;border-bottom:2px solid}}@supports(text-decoration-thickness: initial) and (text-underline-offset: initial){hy-push-state a{text-decoration-style:solid;text-underline-offset:.35rem;text-decoration-thickness:2px}}hy-push-state a.no-hover{border-bottom:none;text-decoration-thickness:unset;text-underline-offset:unset}@supports(text-decoration-thickness: initial) and (text-underline-offset: initial){.content a:not(.btn):not(.no-hover){text-decoration-color:var(--accent-color-faded)}}.content a:not(.btn):not(.no-hover){border-color:var(--accent-color-faded)}.content .aspect-ratio{overflow:hidden}.content .aspect-ratio img{margin:0;width:100%;height:100%;background-color:var(--gray-bg)}hy-drawer{width:100%;position:relative;overflow:hidden;display:block;z-index:4}@media screen and (min-width: 64em){hy-drawer{position:fixed;width:21rem;top:0;left:0;bottom:0;margin-left:0}hy-drawer.cover{position:relative;width:100%}}@media screen and (min-width: 104rem){hy-drawer{width:calc(50% - 31rem)}}.sidebar{position:relative;display:flex;justify-content:center;align-items:center;color:hsla(0,0%,100%,.75);text-align:center;min-height:100vh}.sidebar.invert{color:rgba(32,32,32,.75)}.sidebar a{color:#fff;border-bottom-color:hsla(0,0%,100%,.2);text-decoration-color:hsla(0,0%,100%,.2)}.sidebar.invert a{color:#222;border-bottom-color:rgba(32,32,32,.2);text-decoration-color:rgba(32,32,32,.2)}.sidebar-bg{position:absolute;top:0;left:calc(50% - 50vw);width:100vw;height:100%;background:#202020 center/cover}.sidebar-bg::after{content:"";position:absolute;top:0;left:0;bottom:0;right:0;background:rgba(0,0,0,.05)}.sidebar-bg.sidebar-overlay::after{background:linear-gradient(to bottom, rgba(32, 32, 32, 0) 0%, rgba(32, 32, 32, 0.5) 50%, rgba(32, 32, 32, 0) 100%)}.sidebar-sticky{position:relative;z-index:3;max-width:21rem;padding:1.5rem;contain:content}.sidebar-about .avatar{margin-bottom:1.5rem}.sidebar-about>a.sidebar-title{text-decoration:none}.sidebar-about>a.sidebar-title>h2{margin:0;padding-bottom:.5rem}.sidebar-about>a.sidebar-title::after{content:"";display:block;border-bottom:2px solid;margin:0 auto .5rem;width:4rem;border-color:hsla(0,0%,100%,.2);transition:border-color 250ms}.sidebar-about>a.sidebar-title:hover::after{border-color:#fff;transition:border-color 50ms}.sidebar.invert .sidebar-about>a.sidebar-title::after{border-color:rgba(32,32,32,.2)}.sidebar.invert .sidebar-about>a.sidebar-title:hover::after{border-color:#222}.sidebar-nav>ul{list-style:none;padding-left:0}.sidebar-nav-item{display:inline-block;margin-bottom:.5rem}@media(min-width: 64em){#_main.no-drawer #_menu{display:none}#_main.no-drawer .nav-btn-bar>:nth-child(2){border:none}}.sidebar-social>ul{display:inline-block;list-style:none;padding-left:0;margin-bottom:0}.sidebar-social>ul>li{float:left}.sidebar-social>ul>li>a{display:inline-block;text-align:center;font-size:1.4rem;width:3rem;height:4rem;padding:.5rem 0;line-height:3rem;text-decoration:none;border-bottom-width:2px;border-bottom-style:solid}.sidebar-social>ul li+li{margin-top:0}.fixed-common,.fixed-bottom,.fixed-top{position:fixed;left:0;width:100%;z-index:2}.fixed-top{top:0}.fixed-bottom{bottom:0}.navbar>.content{position:relative;padding-top:0;padding-bottom:0;min-height:0;max-height:5rem}.nav-btn-bar{margin:0 -1rem;background-color:#fff;background-color:var(--body-bg);height:5rem;display:flex;align-items:center;position:relative}.nav-btn-bar>:first-child,.nav-btn-bar>:last-child{border:none}.nav-btn{background:none;border:none;text-decoration:none;display:flex;align-items:center;justify-content:center;width:3.25rem;height:5rem;color:var(--menu-text);border-right:1px solid var(--border-color);border-left:1px solid var(--border-color);margin-left:-1px}#markdown-toc{margin:2rem -1rem 2rem calc(-1rem + 1px);padding-left:2.5rem;padding-bottom:.5rem}#markdown-toc:before{left:1rem}@media screen and (min-width: 104rem){body:not(.no-toc) #markdown-toc{position:absolute;z-index:4;width:20.5rem;right:0;margin:auto;overflow:auto}}@media screen and (min-width: 104rem){body.no-break-layout:not(.no-toc) #markdown-toc{width:calc(50% - 31rem)}}.content{margin-left:auto;margin-right:auto;padding:8rem 1rem 12rem}@media screen{.content{padding-left:1.5rem;min-height:100vh}}@media screen and (min-width: 42em){.content{max-width:42rem}}@media screen and (min-width: 54em){.content{max-width:48rem}}@media screen and (min-width: 64em){.content{padding-left:1rem;margin-left:24rem;margin-right:3rem}}@media screen and (min-width: 86em){.content{padding-top:9rem;margin-left:25rem;margin-right:4rem;max-width:54rem}}@media screen and (min-width: 104rem){.content{margin:auto}}.large-only{display:none}@media screen and (min-width: 104rem){.large-only{display:block}}.avatar{width:7rem;height:7rem;border-radius:100%;overflow:hidden;display:inline-block}.avatar img{width:100%}.content .avatar{float:right;box-sizing:content-box;border:1rem solid var(--body-bg);transition:border-color 1s ease;margin-top:-1.5rem;margin-right:-1rem}.center-image{margin:0 auto;display:block}.note:before{content:"Note"}.page>header>.note-sm:before,.page>header>.note:before,.page>header>#markdown-toc:before{content:"Description"}#markdown-toc:before{content:"Table of Contents"}.layout-resume .note-sm:before,.layout-resume .note:before,.layout-resume #markdown-toc:before{content:"Summary"}</style><link rel="preload" as="style" href="/assets/css/hydejack-9.2.1.css" id="_stylePreload"><link rel="preload" as="style" href="/assets/icomoon/style.css" id="_iconsPreload"> <script> setRel('_stylePreload'); setRel('_iconsPreload'); /**/ </script> <noscript><link rel="stylesheet" href="/assets/css/hydejack-9.2.1.css"><link rel="stylesheet" href="/assets/icomoon/style.css"> </noscript><style id="_pageStyle"> html{--accent-color: rgb(0,0,0);--accent-color-faded: rgba(0, 0, 0, 0.5);--accent-color-highlight: rgba(0, 0, 0, 0.1);--accent-color-darkened: black;--theme-color: rgb(0,0,0);--dark-mode-body-bg: hsl(0, 0%, 17.5%);--dark-mode-border-color: hsl(0, 0%, 22.5%)}</style><!--<![endif]--><body class="no-break-layout no-drawer"> <hy-push-state id="_pushState" replace-selector="#_main" link-selector="a[href]:not([href^='/assets/']):not(.external):not(.no-push-state)" script-selector="script" duration="500" hashchange ><main id="_main" class="content layout-post" role="main" ><nav id="breadcrumbs" class="screen-only"><ul><li><a href="/">home</a><li> <span>/</span> <a href="/blog/">blog</a><li> <span>/</span> <a href="/blog/2020/">2020</a><li> <span>/</span> <a href="/blog/2020/11/">11</a><li> <span>/</span> <a href="/blog/2020/11/22/">22</a><li> <span>/</span> <span>donjon-ctf-sssgx.html</span></ul></nav><article id="post-blog-2020-11-22-donjon-ctf-sssgx" class="page post mb6" role="article"><header><h1 class="post-title flip-project-title"> Donjon CTF SSSGX write-up: linear functions strike back</h1><div class="post-date"> <span class="ellipsis mr1"> <time datetime="2020-11-22T00:00:00+01:00">22 Nov 2020</time> in <span>Blog</span> </span></div><div class="hr pb0"></div></header><p>This writeup presents a solution to the SSSGX Wallet stage of the <a href="https://donjon-ctf.io/">2020 Ledger Donjon’s CTF</a>. It showcases a solution using a kind of generic method to exploit the issues that we are facing in this challenge, which can basically be reduced to solving a linear system in the vector space \(\{0,1\}^N\).<p>We will first <a href="#introduction">describe the challenge</a>, then <a href="#figuring-out-the-problem-to-solve">the generic problem to solve</a>, the <a href="#figuring-out-the-vulnerability">vulnerability to exploit</a>, and finally <a href="#exploiting-the-vulnerability-and-solving-the-challenge">how to solve the challenge</a> using <a href="https://www.sagemath.org/">Sage</a> and <a href="https://github.com/aguinet/dragonffi/">DragonFFI</a>!<p>The full code of this solution is <a href="https://github.com/aguinet/donjonctf_sssgx">available on Github</a>.<p><img src="/assets/2020-11-22-donjon-ctf-sssgx/sssgx_chall.png" alt="" class="center-image" /><h1 id="introduction">Introduction</h1><p>For this challenge, we had access to a web-browser based wallet service (and its source code), on which we can create or restore accounts, and digitally sign messages with that account.<p><img src="/assets/2020-11-22-donjon-ctf-sssgx/sssgx_create.png" alt="Create Wallet" class="center-image" /><p>This system also has the particularity of allowing the user to split the secret associated to his account in three “shares”, and to send two of them to two other persons, so that he’ll be able to recover his account if the three shares are put back together.<p><img src="/assets/2020-11-22-donjon-ctf-sssgx/sssgx_restore.png" alt="Restore Wallet" class="center-image" /><p>In the challenge’s data, we are also given a copy of the local storage SQLite database of a browser that has been using this service. Indeed, once an account has been created on this platform, we can see that a “backup” local storage entry appears, with information linked to our account.<p><img src="/assets/2020-11-22-donjon-ctf-sssgx/sssgx_backup_local_storage.png" alt="Local storage" class="center-image" /><p>The goal of the challenge is to retrieve the secret associated to that account.<p>As we have the source code, let’s take a look at it to understand what are these data, especially the <code class="language-plaintext highlighter-rouge">backup</code> field.<h2 id="service-architecture">Service architecture</h2><p>The service has actually a quite interesting <a href="https://en.wikipedia.org/wiki/Software_Guard_Extensions">Intel SGX</a>-based architecture. What happens when an account is created is:<ul><li>a random 32-bytes secret \(S\) is generated in an SGX container. It is later used to sign messages using <a href="https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm">ECDSA</a><li>this secret is encrypted and authenticated in the very same container, alongside with the email information and the users’ PIN<li>the result is sent back to the user that stores it in its browser local storage</ul><p>When a user asks to sign a message, he has to enter its PIN. The complete request, containing the message, the PIN and the encrypted backup, is forwarded to the SGX container, which:<ul><li>decrypts the backup<li>verifies the users’ PIN<li>signs the message</ul><p>The signature is then sent back to the user.<p>If the user wants to send its shares to two of his friends, he just send his encrypted backup alongside with the two recipients’ mail address. This is the only API we can use with the backup that have been provided in the challenge, because the PIN isn’t requested and checked here.<h1 id="figuring-out-the-problem-to-solve">Figuring out the problem to solve</h1><h2 id="what-data-do-we-have">What data do we have</h2><p>It looks like solving this challenge would imply using the two shares that the server is willing to send us. Using the SQLite database we are provided with, we inject it into the browser of our choice, and ask the interface to send the shares to two email addresses we control:<p><img src="/assets/2020-11-22-donjon-ctf-sssgx/sssgx_share.png" alt="Send shares" class="center-image" /><p>For the sake of history, the two resulting shares are available in the <a href="https://github.com/aguinet/donjonctf_sssgx/blob/main/shares.txt">repository of the solution</a>.<p>Now, let’s go back to the code and look at the “data flow” between our victim’s secret (what we are looking for) and the two shares we have. Given the name of the challenge, we are expecting to find some sharing scheme, like the <a href="https://en.wikipedia.org/wiki/Shamir%27s_Secret_Sharing">Shamir’s Secret Sharing (SSS)</a> one.<h2 id="what-function-computes-them">What function computes them</h2><p>We are interested in isolating the function that computes these two shares from the original secret.<p>From the code, in the file <code class="language-plaintext highlighter-rouge">src/wallet/libwallet/Enclave/Enclave.cpp</code>, the function <code class="language-plaintext highlighter-rouge">share_user_seed</code> looks interesting. It is indeed declared as a “public endpoint” of the enclave in <code class="language-plaintext highlighter-rouge">src/wallet/libwallet/Enclave/Enclave.edl</code>, is wrapped in the function <code class="language-plaintext highlighter-rouge">wallet_share_seed</code>, which itself is called by the Node.js server by the <code class="language-plaintext highlighter-rouge">/share</code> public REST API, all through of bunch of bindings we don’t describe here. The shares we got by email have thus been generated by the <code class="language-plaintext highlighter-rouge">share_user_seed</code> function, which looks like this (stripped down for readability):<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sgx_status_t</span> <span class="nf">share_user_seed</span><span class="p">(</span><span class="n">share_t</span> <span class="n">contact_shares</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">blob</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">blob_size</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">password</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">email1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">email2</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">sgx_status_t</span> <span class="n">status</span><span class="p">;</span>
    <span class="n">sss_Share</span> <span class="n">shares</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
    <span class="n">user_data_t</span> <span class="n">user_data</span><span class="p">;</span>
    <span class="kt">uint8_t</span> <span class="n">entropy</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>

    <span class="c1">// No need to check the password, as one share will always be sent to the owner email address.</span>
    <span class="c1">// We can assume access to the mail account is enough.</span>
    <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">password</span><span class="p">;</span>

    <span class="n">unseal_user_data</span><span class="p">(</span><span class="n">blob</span><span class="p">,</span> <span class="n">blob_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">user_data</span><span class="p">);</span>
    <span class="n">sgx_read_rand</span><span class="p">(</span><span class="n">entropy</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">entropy</span><span class="p">));</span>
    <span class="n">randominit</span><span class="p">(</span><span class="n">entropy</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">entropy</span><span class="p">));</span>

    <span class="kt">uint8_t</span> <span class="n">msg</span><span class="p">[</span><span class="n">sss_MLEN</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">user_data</span><span class="p">.</span><span class="n">key</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">user_data</span><span class="p">.</span><span class="n">key</span><span class="p">));</span>
    <span class="n">sss_create_shares</span><span class="p">(</span><span class="n">shares</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span> 

    <span class="p">[...]</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="n">contact_shares</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">data</span><span class="p">,</span> <span class="n">shares</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">sss_SHARE_LEN</span><span class="p">);</span>
    <span class="p">}</span>   
    <span class="k">return</span> <span class="n">SGX_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div><p>It is indeed using <a href="https://en.wikipedia.org/wiki/Shamir%27s_Secret_Sharing">Shamir’s Secret Sharing (SSS)</a> protocol, splitting the secret in three shares and requiring the three of them to recover the secret. The core function that creates these shares is <code class="language-plaintext highlighter-rouge">sss_create_shares</code>, which is from the <a href="https://github.com/dsprenkels/sss">sss library</a> by <a href="https://dsprenkels.com/">Daan Sprenkels</a>. This function takes as input the user’s secret key (which we are interested in), and returns three shares. Given these three shares, it is possible to do the inverse operation, <em>i.e.</em> recompute the original user’s secret. As a reminder, we only have two of these shares.<h2 id="shamirs-secret-sharing-and-its-implementation-in-sss">Shamir’s Secret Sharing, and its implementation in <a href="https://github.com/dsprenkels/sss">sss</a></h2><p><a href="https://en.wikipedia.org/wiki/Shamir%27s_Secret_Sharing">Shamir’s Secret Sharing</a> scheme is a <a href="https://en.wikipedia.org/wiki/Secret_sharing">secret sharing</a> scheme. The goal is to share a secret between \(n\) participants, and require at least \(k\) participants to retrieve it.<p><a href="https://en.wikipedia.org/wiki/Shamir%27s_Secret_Sharing">SSS</a> implements this using polynomials. This is best described by the <a href="https://en.wikipedia.org/wiki/Shamir%27s_Secret_Sharing#Shamir's_secret_sharing_scheme">Wikipedia’s article</a> on the matter:<blockquote><p>The essential idea of Adi Shamir’s threshold scheme is that 2 points are sufficient to define a line, 3 points are sufficient to define a parabola, 4 points to define a cubic curve and so forth. That is, it takes \(k\) points to define a polynomial of degree \(k-1\).</blockquote><p>The degree of the polynomial \(P\) will thus be \(k-1\). We embed the secret into this polynomial, for instance by setting its constant coefficient \(P(0)\) to the secret, and the rest to random values. We then evaluate this polynomial in \(N\) points, and share a different \((i,P(i))\) pair with each of the \(K\) participants. If we know \(K\) shares, we can retrieve the full polynomial using interpolation, and hence retrieve the secret.<p>In the case of our challenge, for one secret, the <a href="https://github.com/dsprenkels/sss">sss</a> library uses 32 polynomials with coefficients in the \(GF(2^8)\) space (which are themselves polynomials). According to the <a href="https://github.com/dsprenkels/sss/blob/v0.1.0/hazmat.c#L93">source code of the library</a>, multiplication in \(GF(2^8)\) is reduced by this polynom: \(x^8 + x^4 + x^3 + x + 1\). This means that, for this challenge, shares are polynomials, as well as coefficients of the Shamir polynomial.<p>Moreover, for one secret, it uses 32 Shamir polynomials, because one Shamir polynomial with coefficients in \(GF(2^8)\) can only <em>store</em> a secret of one byte (aka 8 bits). Indeed, as we will <a href="#understanding-the-share-format">see below</a>, the library encrypts the secret with a random 32-byte encryption key (which then is the actual shared secret), hence the 32 polynomials.<h3 id="bitslicing">Bitslicing</h3><p>In order to make computations with these 32 polynomials efficient, the library uses a technique called <em>bitslicing</em>. Instead of working with 32x8-bit integers (each integer representing a polynomial over \(GF(2^8)\), it works with 8x32-bit integers. Each 32-bit integers representing the same coefficient of the 32 polynomials. Thus, we can do 32 polynomials computation at once.<p>This bitslicing transformation can be seen as a transposition of the original 32x8 bit matrix, which is a linear operation in \(GF(2)^N\) (this is important for what’s next).<h2 id="understanding-the-share-format">Understanding the share format</h2><p>The <a href="https://github.com/dsprenkels/sss/#technical-details">sss library’s README</a> explains a little bit what happens in the <a href="https://github.com/dsprenkels/sss/blob/v0.1.0/sss.c#L61"><code class="language-plaintext highlighter-rouge">sss_create_shares</code></a> function. Basically, a random 32-bytes key \(K\) is computed, then used to encrypt and authenticate the original secret \(S\) with <a href="https://github.com/jedisct1/libsodium">libsodium</a>’s <code class="language-plaintext highlighter-rouge">crypto_secretbox</code> function. The rational behind this is explained in the aforementioned README.<p>The <a href="https://en.wikipedia.org/wiki/Shamir%27s_Secret_Sharing">SSS</a> algorithm is then applied on the key \(K\), creating in our case three shares. The share values can then be used in the <code class="language-plaintext highlighter-rouge">sss_combine_shares</code>, which recovers the key \(K\), and uses <a href="https://github.com/jedisct1/libsodium">libsodium</a>’s <code class="language-plaintext highlighter-rouge">crypto_secretbox_open</code> to verify the integrity of the encrypted data and recover the original secret \(S\).<p>Regarding the share format, analyzing the library’s source code teaches us that the result of the <a href="https://en.wikipedia.org/wiki/Authenticated_encryption#Authenticated_encryption_with_associated_data_(AEAD)">Authenticated Encryption with Associated Data (AEAD)</a> of \(S\) with \(K\) is concatenated to every share. Moreover, each share, at its beginning, have its share index encoded in one byte.<p>So, the final format of a share is:<ul><li>First byte: share index (from 1 to 3 in our case)<li>Next 32 bytes: the actual share value (representing the 32 polynomials)<li>Remaining bytes: basically the output of <code class="language-plaintext highlighter-rouge">crypto_secretbox</code>, that encrypts &amp; authenticate our original secret \(S\) with the random key \(K\)</ul><p>What we got from the server is a Base64 encoding of this. If we indeed take a closer look at the two shares we received, we can see that the last bytes are the same.<h2 id="the-problem-to-solve">The problem to solve</h2><p>With all these information, we can say that the problem to solve can be summarized as such:<ul><li>given two known shares \((KS_1,KS_2)\) (among the original three shares \((KS_0,KS_1,KS_2)\)) of a secret (in our case the encryption key \(K\))<li>and given the function \(F(K) = (KS_0,KS_1,KS_2)\),</ul><p>can we retrieve \(K\) by only having \((KS_1,KS_2)\)?<p><em>Note: Once we got \(K\), we just need to use <a href="https://github.com/jedisct1/libsodium">libsodium</a> to retrieve the original secret \(S\).</em><h2 id="bibliography">Bibliography</h2><p>This challenge has a very strong resemblance to this <a href="https://donjon.ledger.com/Stealing-all-HTC-Exodus-users/">recent blog post</a>, and given that Jean-Baptiste Bédrune is now head of security of the Ledger’s Donjon, this might not be just a coincidence :)<h1 id="figuring-out-the-vulnerability">Figuring out the vulnerability</h1><p>In theory, if <a href="sss_wiki">SSS</a> is properly implemented, that it isn’t possible to recover this secret with only two shares out of the three. So there must be some kind of vulnerability in the implementation of this scheme.<p>We can notice that a customized version of the <a href="https://github.com/dsprenkels/sss">sss</a> library has been used. If we look at the differences, we can see that the major ones are in the <code class="language-plaintext highlighter-rouge">randombytes.cpp</code> file. Here is part of its implementation:<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define RANDOM_POOL_SIZE 128
</span><span class="k">static</span> <span class="kt">uint8_t</span> <span class="n">random_pool</span><span class="p">[</span><span class="n">RANDOM_POOL_SIZE</span><span class="p">];</span>

<span class="kt">void</span> <span class="nf">randominit</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">entropy</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">sgx_sha256_hash_t</span> <span class="n">digest</span><span class="p">;</span>
  
  <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">random_pool</span><span class="p">;</span>
  <span class="n">sgx_sha256_msg</span><span class="p">((</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">entropy</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="n">size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">digest</span><span class="p">);</span>

  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">digest</span><span class="p">,</span> <span class="n">SGX_SHA256_HASH_SIZE</span><span class="p">);</span>
    <span class="n">sgx_sha256_msg</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">SGX_SHA256_HASH_SIZE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">digest</span><span class="p">);</span>
    <span class="n">p</span> <span class="o">+=</span> <span class="n">SGX_SHA256_HASH_SIZE</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">randombytes</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>  

  <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="n">RANDOM_POOL_SIZE</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">random_pool</span><span class="p">,</span> <span class="n">RANDOM_POOL_SIZE</span><span class="p">);</span>
    <span class="n">data</span> <span class="o">+=</span> <span class="n">RANDOM_POOL_SIZE</span><span class="p">;</span>
    <span class="n">n</span> <span class="o">-=</span> <span class="n">RANDOM_POOL_SIZE</span><span class="p">;</span>
  <span class="p">}</span>  
  <span class="n">memcpy</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">random_pool</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span> 
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div><p>One issue here is that the <code class="language-plaintext highlighter-rouge">randombytes</code> function will always return the same bytes (looping over a buffer of 128 bytes). This means that, if we call twice the <code class="language-plaintext highlighter-rouge">randombytes</code> function to get, say, 32 bytes, we get twice the same random 32 bytes. Let’s see where this is used and how we can exploit this.<h2 id="constant-randomness-usage">Constant randomness usage</h2><h3 id="usage-1">Usage 1</h3><p>The first place where <code class="language-plaintext highlighter-rouge">randombytes</code> is used is <a href="https://github.com/dsprenkels/sss/blob/v0.1.0/sss.c#L73"><code class="language-plaintext highlighter-rouge">sss_create_keyshares</code></a>. The <code class="language-plaintext highlighter-rouge">randombytes</code> function is thus used to compute the 32-bytes key that encrypts the data to share (see above).<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">sss_create_shares</span><span class="p">(</span><span class="n">sss_Share</span> <span class="o">*</span><span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
                       <span class="kt">uint8_t</span> <span class="n">n</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">k</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// ...</span>
  <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">key</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
  <span class="cm">/* Generate a random encryption key */</span>
  <span class="n">randombytes</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">key</span><span class="p">));</span>

  <span class="cm">/* AEAD encrypt the data with the key */</span>
  <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">[</span><span class="n">crypto_secretbox_ZEROBYTES</span><span class="p">],</span> <span class="n">data</span><span class="p">,</span> <span class="n">sss_MLEN</span><span class="p">);</span>
  <span class="n">crypto_secretbox</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">mlen</span><span class="p">,</span> <span class="n">nonce</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>

  <span class="cm">/* Generate KeyShares */</span>
  <span class="n">sss_create_keyshares</span><span class="p">(</span><span class="n">keyshares</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>
</code></pre></div></div><h3 id="usage-2">Usage 2</h3><p>The next place where <code class="language-plaintext highlighter-rouge">randombytes</code> is used is in <a href="https://github.com/dsprenkels/sss/blob/v0.1.0/hazmat.c#L298"><code class="language-plaintext highlighter-rouge">sss_create_keyshares</code></a> in order to generate the various set of polynomials involved:<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span>
<span class="nf">sss_create_keyshares</span><span class="p">(</span><span class="n">sss_Keyshare</span> <span class="o">*</span><span class="n">out</span><span class="p">,</span>
                      <span class="k">const</span> <span class="kt">uint8_t</span> <span class="n">key</span><span class="p">[</span><span class="mi">32</span><span class="p">],</span>
                      <span class="kt">uint8_t</span> <span class="n">n</span><span class="p">,</span>
                      <span class="kt">uint8_t</span> <span class="n">k</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// ...</span>
  <span class="kt">uint32_t</span> <span class="n">poly0</span><span class="p">[</span><span class="mi">8</span><span class="p">],</span> <span class="n">poly</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">8</span><span class="p">];</span>

  <span class="cm">/* Put the secret in the bottom part of the polynomial */</span>
	<span class="n">bitslice</span><span class="p">(</span><span class="n">poly0</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>

  <span class="cm">/* Generate the other terms of the polynomial */</span>
  <span class="n">randombytes</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span> <span class="n">poly</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">poly</span><span class="p">));</span>
  <span class="c1">//...</span>
<span class="p">}</span>
</code></pre></div></div><p>In our case, \(k\) (number of shares needed to retrieve the secret) is three, as long as \(n\) (number of total shares). We thus have 3 sets of 32 polynomials with coefficients in \(GF(2^8)\):<ul><li>one \(P_0\) set, which is the key \(K\)<li>two other ones \((P_1,P_2)\), which are chosen randomly using <code class="language-plaintext highlighter-rouge">randombytes</code>.</ul><p>With all these informations, let’s refine a little bit our problem to solve.<h2 id="the-refined-problem-to-solve">The refined problem to solve</h2><p>As the representation of a set of 32 polynomials is composed of 32 8-bit integers (which means 32 bytes), due to the vulnerability <a href="#figuring-out-the-vulnerability">explained above</a>, this means that the first set of polynomials’ coefficients are directly tied to the 32-bytes random key \(K\).<p>This means that, from the description of the problem we gave above, we can refine the problem as such:<ul><li>with \(F\) a function that, given \((K,P_2)\), generates \((KS_1,KS_2)\), the problem is, knowing \((KS_1,KS_2)\), to retrieve \((K,P_2)\).<li>stated differently, we want to solve the equation \(F(K,P_2) = (KS_1,KS_2)\) (knowing \((KS_1,KS_2)\)).</ul><p>We can also note that \((K,P_2)\) is \(32+32=64\) bytes, as well as \((KS_1,KS_2)\). Let’s now take a closer look at \(F\).<h2 id="analyzing-f">Analyzing <code class="language-plaintext highlighter-rouge">F</code></h2><p>We can split the code of the <code class="language-plaintext highlighter-rouge">sss_create_keyshares</code> function, so that our function \(F\) becomes more explicit:<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">extern</span> <span class="s">"C"</span> <span class="kt">void</span>
<span class="nf">sss_create_keyshares_impl</span><span class="p">(</span><span class="n">sss_Keyshare</span> <span class="o">*</span><span class="n">out</span><span class="p">,</span>
    <span class="k">const</span> <span class="kt">uint8_t</span> <span class="n">key</span><span class="p">[</span><span class="mi">32</span><span class="p">],</span>
    <span class="k">const</span> <span class="kt">uint32_t</span><span class="o">*</span> <span class="n">poly</span><span class="p">,</span>
    <span class="kt">uint8_t</span> <span class="n">n</span><span class="p">,</span>
    <span class="kt">uint8_t</span> <span class="n">k</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">uint8_t</span> <span class="n">share_idx</span><span class="p">,</span> <span class="n">coeff_idx</span><span class="p">,</span> <span class="n">unbitsliced_x</span><span class="p">;</span>
  <span class="kt">uint32_t</span> <span class="n">poly0</span><span class="p">[</span><span class="mi">8</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">8</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="mi">8</span><span class="p">],</span> <span class="n">xpow</span><span class="p">[</span><span class="mi">8</span><span class="p">],</span> <span class="n">tmp</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>

  <span class="cm">/* Put the secret in the bottom part of the polynomial */</span>
  <span class="n">bitslice</span><span class="p">(</span><span class="n">poly0</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">share_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">share_idx</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">share_idx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* x value is in 1..n */</span>
    <span class="n">unbitsliced_x</span> <span class="o">=</span> <span class="n">share_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">out</span><span class="p">[</span><span class="n">share_idx</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">unbitsliced_x</span><span class="p">;</span>
    <span class="n">bitslice_setall</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">unbitsliced_x</span><span class="p">);</span>

    <span class="cm">/* Calculate y */</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">y</span><span class="p">));</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">xpow</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xpow</span><span class="p">));</span>
    <span class="n">xpow</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0</span><span class="p">;</span> 
    <span class="n">gf256_add</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">poly0</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">coeff_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">coeff_idx</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span> <span class="n">coeff_idx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">gf256_mul</span><span class="p">(</span><span class="n">xpow</span><span class="p">,</span> <span class="n">xpow</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span> 
      <span class="n">gf256_mul</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">xpow</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">poly</span><span class="p">[</span><span class="n">coeff_idx</span><span class="o">*</span><span class="mi">8</span><span class="p">]);</span>
      <span class="n">gf256_add</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
    <span class="p">}</span>   
    <span class="n">unbitslice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">out</span><span class="p">[</span><span class="n">share_idx</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">y</span><span class="p">);</span> 
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">sss_create_keyshares</span><span class="p">(</span><span class="n">sss_Keyshare</span> <span class="o">*</span><span class="n">out</span><span class="p">,</span>
                      <span class="k">const</span> <span class="kt">uint8_t</span> <span class="n">key</span><span class="p">[</span><span class="mi">32</span><span class="p">],</span>
                      <span class="kt">uint8_t</span> <span class="n">n</span><span class="p">,</span>
                      <span class="kt">uint8_t</span> <span class="n">k</span><span class="p">)</span>
<span class="p">{</span>

  <span class="kt">uint32_t</span> <span class="n">poly</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">8</span><span class="p">];</span>
  <span class="cm">/* Generate the other terms of the polynomial */</span>
  <span class="n">randombytes</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span> <span class="n">poly</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">poly</span><span class="p">));</span>

  <span class="n">sss_create_keyshares_impl</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">poly</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span> 
<span class="p">}</span>
</code></pre></div></div><p>In this code, \(F\) is <code class="language-plaintext highlighter-rouge">sss_create_keyshares_impl</code>, called with <code class="language-plaintext highlighter-rouge">n=3</code> and <code class="language-plaintext highlighter-rouge">k=3</code>. Moreover, due to the <a href="#figuring-out-the-vulnerability">previously exposed issue</a> the 32 bytes of key are the sames as the first 32 bytes of <code class="language-plaintext highlighter-rouge">polys</code>. This function basically implements the <a href="https://en.wikipedia.org/wiki/Shamir%27s_Secret_Sharing">SSS</a> protocol. As <a href="#shamirs-secret-sharing-and-its-implementation-in-sss">seen before</a>, it’s using sets of 32 polynomials with coefficients in the \(GF(2^8)\) space.<p>As discussed in <a href="#annex-a-gf28-versus-gf2n">Annex A</a>, multiplications by constant polynomials and additions in \(GF(2^8)\) can also be represented as linear functions in the \(GF(2)^8\) space. This can help us tell that the function \(F\) is linear in the \(GF(2)^{512}\) space.<p>Indeed, let’s take a closer look at the computation of one byte of the \(i\)-th share. This is basically evaluating a polynomial \(A\) of degree \(k-1=2\) (with coefficients \(a_i\) in \(GF(2^8)\)) in \(i\). With \(C_i\) the polynomial representation of \(i\) in \(GF(2^8)\) (e.g. here with \(i=3 \implies C_i = 1+x\)): \[\begin{align*} A(C_i) &amp;= a_0 + a_1*C_i + a_2*C_i^2 \\ &amp;= a_0 + a_1*(1+x) + a_2*(1+x)^2 \\ &amp;= a_0 + a_1*(1+x) + a_2*(1+x^2) \\ &amp;= (a_0+a_1+a_2) + a_1*x + a_2*x^2 \end{align*}\]<p>With \(a_i = \sum_{j=0}^{7} (b_{i,j}*x^j)\), we end up with a polynomial in \(GF(2^8)\), whose coefficients are linear combinations of \((b_{ij})\). So, for this specific share, we can rewrite this operation in \(GF(2)^{8*3}\) as: \[M_i\times\begin{pmatrix}b_{0,0} \\ b_{0,1} \\ \dots \\ b_{0,7} \\ b_{1,0} \\ \dots \\ b_{2,7} \end{pmatrix}\]<p>with \(M_i\) a \(24 \times 8\) bit matrix.<p>Moreover, as <a href="#bitslicing">said above</a>, the bitslicing part is <em>just</em> an optimisation, and can also be seen as a linear function. We can notice that the <code class="language-plaintext highlighter-rouge">sss_create_keyshares_impl</code> takes “unbitsliced” inputs, and returns “unbitsliced” outputs. So, in the end, we don’t really have to take care about this internal representation and optimisation.<p>Finally, we can say that our problem basically boils down to solving a linear system in \(GF(2)^{512}\)! What we miss is the representation of \(F\) in that space.<p><em>Note: we don’t necessary need to precisely understand all these things to solve the challenge. We can make the assumption that \(F\) will be linear in the \(GF(2)^{512}\) vector space, and quickly try if that’s the case (see the <a href="https://github.com/aguinet/donjonctf_sssgx/blob/main/attack.py#L50">provided source code</a> for an example).</em><h1 id="exploiting-the-vulnerability-and-solving-the-challenge">Exploiting the vulnerability (and solving the challenge)</h1><p>Let’s recap what we have to do:<ul><li>we know the key shares \((KS_1,KS_2)\), which are both 32-bytes long<li>we have the function \(F\), which can be represented as a linear function in the \(GF(2)^{512}\) vector space. We have the code of that function, so we can evaluate it<li>we have to retrieve the original secret by solving the equation \(F(K,P_2) == (KS_1,KS_2)\)</ul><p>As \(F\) is a linear function in \(GF(2)^{512}\), it can be represented by a 512 square bit matrix \(M\). Remember, \(GF(2)\) basically means \(\{0,1\}\) (it’s a bit), and the size of \((K,P_2)\) and \((KS_1,KS_2)\) is 64 <strong>bytes</strong>.<p>So, in the end, we want to solve this equation: \[M\times\begin{pmatrix}K \\ P_2\end{pmatrix} = \begin{pmatrix}KS_1 \\ KS_2\end{pmatrix}\]<p>Note that \(M\) might not be invertible, so it might not be “as simple” as writing the inverse of \(F\) and compute it.<h2 id="computing-m-using-dragonffi">Computing \(M\) using DragonFFI</h2><p>One thing that remains is to compute the matrix \(M\). There are basically two ways to do this:<ul><li>compute the matrix <em>by hand</em>, by composing all the various operations that are happening in \(F\). This is a bit time consuming and potentially error-prone.<li>evaluate \(F\) 512 times to compute the values of the column of \(M\). Indeed, if, for every column index \(i\) of \(M\), we compute \(F(V)\), with V a bit vector with only the \(i\)-th index at 1 (and the others at zero), then we directly get the vector of the column \(i\) of \(M\).</ul><p>Let’s go for the second option, and do that using <a href="https://github.com/aguinet/dragonffi/">DragonFFI</a> to directly call <code class="language-plaintext highlighter-rouge">sss_create_keyshares_impl</code> from Python:<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">pydffi</span>
<span class="n">FFI</span><span class="o">=</span><span class="n">pydffi</span><span class="p">.</span><span class="nc">FFI</span><span class="p">()</span>
<span class="n">CU</span><span class="o">=</span><span class="n">FFI</span><span class="p">.</span><span class="nf">cdef</span><span class="p">(</span><span class="sh">'''</span><span class="s">
#include &lt;stdint.h&gt;
void sss_create_keyshares_impl(uint8_t *out,
  const uint8_t* key,
  const uint8_t* poly, // was uint32_t*
  uint8_t n,
  uint8_t k);
</span><span class="sh">'''</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">polys_to_keyshares</span><span class="p">(</span><span class="n">polys</span><span class="p">):</span>
    <span class="nf">assert</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">polys</span><span class="p">)</span> <span class="o">==</span> <span class="n">LEN_POLYS</span><span class="p">)</span>
    <span class="c1"># This is due to the random generator reusing the same data (this is the vuln we are exploiting).
</span>    <span class="n">key</span> <span class="o">=</span> <span class="n">polys</span><span class="p">[:</span><span class="n">LEN_KEY</span><span class="p">]</span>
    <span class="n">out</span> <span class="o">=</span> <span class="nf">bytearray</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">LEN_KEYSHARES</span><span class="p">)</span>
    <span class="n">CU</span><span class="p">.</span><span class="n">funcs</span><span class="p">.</span><span class="nf">sss_create_keyshares_impl</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">polys</span><span class="p">,</span> <span class="n">NSHARES</span><span class="p">,</span> <span class="n">NSHARES</span><span class="p">)</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="n">out</span><span class="p">[:</span><span class="n">LEN_KEYSHARE</span><span class="p">],</span> <span class="n">out</span><span class="p">[</span><span class="n">LEN_KEYSHARE</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="n">LEN_KEYSHARE</span><span class="p">],</span> <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">LEN_KEYSHARE</span><span class="p">:])</span>
    <span class="k">return</span> <span class="n">ret</span>

<span class="k">def</span> <span class="nf">kss_to_F_output</span><span class="p">(</span><span class="n">kss</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">kss</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">kss</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">:]</span>

<span class="c1"># This is our function F. It takes 64 bytes as input (two polynoms), and
# returns the last two shares (2*32 bytes)
</span><span class="k">def</span> <span class="nf">F</span><span class="p">(</span><span class="n">in_</span><span class="p">):</span>
    <span class="n">kss</span> <span class="o">=</span> <span class="nf">polys_to_keyshares</span><span class="p">(</span><span class="n">in_</span><span class="p">)</span>
    <span class="k">return</span> <span class="nf">kss_to_F_output</span><span class="p">(</span><span class="n">kss</span><span class="p">)</span>

<span class="c1"># We work with vector of bits, so we choose a way to transform a list of bytes
# into a list of bits and vice versa. Any representation would work, as long as
# bytes2bits is the inverse of bits2bytes. Implementation is in the provided
# source code.
</span><span class="k">def</span> <span class="nf">bits2bytes</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
  <span class="c1"># ...
</span>
<span class="k">def</span> <span class="nf">bytes2bits</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
  <span class="c1"># ...
</span>
<span class="kn">from</span> <span class="n">sage.all</span> <span class="kn">import</span> <span class="n">Integers</span><span class="p">,</span> <span class="n">Matrix</span><span class="p">,</span> <span class="n">vector</span>
<span class="n">GF2</span><span class="o">=</span><span class="nc">Integers</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">computeFMatrix</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">input_nbits</span><span class="p">):</span>
    <span class="n">ret_cols</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">bin_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">input_nbits</span><span class="p">):</span>
        <span class="n">in_</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">NBITS</span>
        <span class="n">in_</span><span class="p">[</span><span class="n">bin_</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">in_</span> <span class="o">=</span> <span class="nf">bits2bytes</span><span class="p">(</span><span class="n">in_</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="nc">F</span><span class="p">(</span><span class="n">in_</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="nf">bytes2bits</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
        <span class="n">ret_cols</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
    <span class="k">return</span> <span class="nc">Matrix</span><span class="p">(</span><span class="n">GF2</span><span class="p">,</span> <span class="n">ret_cols</span><span class="p">).</span><span class="nf">transpose</span><span class="p">()</span>
<span class="n">NBITS</span><span class="o">=</span><span class="mi">64</span><span class="o">*</span><span class="mi">8</span>
<span class="n">M</span><span class="o">=</span><span class="nf">computeFMatrix</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">NBITS</span><span class="p">)</span>
</code></pre></div></div><h2 id="solving-the-problem-with-sage">Solving the problem with sage</h2><p>Now that we got the matrix, it’s a matter of asking <a href="https://www.sagemath.org/">Sage</a> to solve the problem for us.<p>The first thing we can verify is the size of the kernel of \(M\), that is the number of vector \(X\) for which \(M \times X == 0\). This will basically gives us the number of possible solutions to the problem:<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">print</span><span class="p">(</span><span class="n">M</span><span class="p">.</span><span class="nf">kernel</span><span class="p">())</span>
</code></pre></div></div><p>which gives:<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Vector space of degree 512 and dimension 2 over Ring of integers modulo 2
Basis matrix:
2 x 512 dense matrix over Ring of integers modulo 2
</code></pre></div></div><p>As the dimension of the result vector space is \(2\), we will have \(2^2 = 4\) potential solutions, which is fine to bruteforce :)<p>Now, let’s ask <a href="https://www.sagemath.org/">Sage</a> to finally solve this:<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Get all possible values of X in M*X = C thanks to Sage
</span><span class="k">def</span> <span class="nf">allsols</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">C</span><span class="p">):</span>
    <span class="n">S0</span> <span class="o">=</span> <span class="n">M</span><span class="p">.</span><span class="nf">solve_right</span><span class="p">(</span><span class="nf">vector</span><span class="p">(</span><span class="n">GF2</span><span class="p">,</span><span class="nf">bytes2bits</span><span class="p">(</span><span class="n">C</span><span class="p">)))</span>
    <span class="k">for</span> <span class="n">S</span> <span class="ow">in</span> <span class="n">M</span><span class="p">.</span><span class="nf">right_kernel</span><span class="p">():</span>
        <span class="k">yield</span> <span class="n">S</span> <span class="o">+</span> <span class="n">S0</span>

<span class="c1"># We extract the two shares from the mails we received
</span><span class="n">Fout</span> <span class="o">=</span> <span class="n">shares</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="n">shares</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="n">keys</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">for</span> <span class="n">S</span> <span class="ow">in</span> <span class="nf">allsols</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">Fout</span><span class="p">):</span>
    <span class="n">S</span> <span class="o">=</span> <span class="p">[</span><span class="nf">int</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">S</span><span class="p">]</span>
    <span class="c1"># The solution will give us the encryption K and the polynom P2. We only
</span>    <span class="c1"># care about K here.
</span>    <span class="n">key</span> <span class="o">=</span> <span class="nf">bits2bytes</span><span class="p">(</span><span class="n">S</span><span class="p">)[:</span><span class="mi">32</span><span class="p">]</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">[x] Possible key: %s</span><span class="sh">"</span> <span class="o">%</span> <span class="n">key</span><span class="p">.</span><span class="nf">hex</span><span class="p">())</span>
    <span class="n">keys</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
</code></pre></div></div><h2 id="recovering-the-original-private-key">Recovering the original private key</h2><p>Last part is to bruteforce these 4 keys and retrieve the original secret:<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
    <span class="n">out</span> <span class="o">=</span> <span class="nf">bytearray</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mi">64</span><span class="p">)</span>
    <span class="c1"># sss_decrypt is basically a wrapper around crypto_secretbox_open
</span>    <span class="c1"># added to the sss lib (source code in the provided repository)
</span>    <span class="k">if</span> <span class="nf">int</span><span class="p">(</span><span class="n">CU</span><span class="p">.</span><span class="n">funcs</span><span class="p">.</span><span class="nf">sss_decrypt</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">k</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">[+] Original secret found: %s</span><span class="sh">"</span> <span class="o">%</span> <span class="n">out</span><span class="p">.</span><span class="nf">hex</span><span class="p">())</span>
        <span class="n">sys</span><span class="p">.</span><span class="nf">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</code></pre></div></div><p>To get the flag, we just had to give the found secret to a script that would verify that it is indeed the private key associated to the challenge’s wallet public key, and output the flag as <code class="language-plaintext highlighter-rouge">CTF{secret_in_hex}</code>:<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  $ python ./check_flag.py 7d486b4cfdb1ede284802029e77ab292c35ab0d7b9d8c51a06b9222e5095e98c
  CTF{7d486b4cfdb1ede284802029e77ab292c35ab0d7b9d8c51a06b9222e5095e98c}
</code></pre></div></div><p>And that’s it!<h1 id="conclusion">Conclusion</h1><p>That was a very nice challenge, which showcases how a <em>simple</em> vulnerability in a random generator can break an apparently well designed system!<h1 id="acknowledgment">Acknowledgment</h1><p>Thanks to ssp for reviewing this writeup at 11PM, and the Donjon Ledger team for this CTF!<h1 id="annex-a-gf2n-versus-gf2n">Annex A: \(GF(2^N)\) versus \(GF(2)^N\)</h1><p>This annex explains why some operations in \(GF(2^N)\) can be represented as linear operation in the vector space \(GF(2)^N\) (which means a vector space using vectors of N bits).<p>\(GF(2^N)\) represents polynomials with coefficients in \(GF(2)\) (aka a bit). For instance, for \(N = 8\): \(P(x) = a_0 + a_1*x + a_2*x^2 + ... + a_7*x^7\). As each coefficient is a bit, we can also represent them as bits. Let’s call that representation <code class="language-plaintext highlighter-rouge">bits(P)</code>.<p>Additions and multiplications are the usual ones. Addition of two polynomials A and B gives: \[A(x) + B(x) = (a_0+b_0) + (a_1+b_1)*x + ... + (a_7+b_7)*x^7\]<p>As coefficients are in \(GF(2)\), the addition can be seen as a simple XOR operation. This means that \(A+B\) == <code class="language-plaintext highlighter-rouge">poly(bits(A)^bits(B))</code>. With \(BA\) and \(BV\) in \(GF(2)^8\), this also means that this polynomial addition can also be represented as a simple \(BA + BV\) vector addition in this vector space.<p>Multiplications in \(GF(2^N)\) are reduced to a fixed polynomial. Multiplying a unknown polynomial \(X\) with a known polynomial \(C\) can also be represented as a linear operation \(M_C \times X\) in \(GF(2)^N\) (with \(M_C\) an NxN bit matrix). Let’s just take an example to give the intuition behind this, with \(N = 4\), \(C = 1+x^2\), and \(x^4 + x + 1\) the reduction polynomial: \[\begin{align*} A(x)*C &amp;= (a_0+a_1*x+a_2*x^2+a_3*x^3)*(1+x^2) \\ &amp;= a_0 + a_1*x + (a_2 + a_0)*x^2 + (a_3 + a_1)*x^3 + a_2*x^4 + a_3*x^5 \end{align*}\]<p>Reduced \(\pmod{x^4 + x + 1}\), we have \[\begin{align*} x^4 &amp;= x + 1 &amp; \pmod{x^4 + x + 1}\\ x^5 &amp;= x^2 + x &amp; \pmod{x^4 + x + 1} \end{align*}\]<p>Which gives us: \[\begin{split} &amp;A(x)*C \pmod{x^4 + x + 1} \\ &amp; = a_0 + a_1*x + (a_2 + a_0)*x^2 + (a_3 + a_1)*x^3 + a_2*(x + 1) + a_3*(x^2 + x) \\ &amp; = (a_0 + a_2) + (a_1 + a_2 + a_3)*x + (a_0 + a_2 + a_3)*x^2 + (a_1 + a_3)*x^3 \end{split}\]<p>If we model \(A\) as a 4-bit vector in \(GF(2)^4\), we can represent \(A(x)*C\) as a linear operation \(M_C \times A\), with \(M_C\) a 4x4-bit matrix: \[\begin{pmatrix} 1 &amp; 0 &amp; 1 &amp; 0 \\ 0 &amp; 1 &amp; 1 &amp; 1 \\ 1 &amp; 0 &amp; 1 &amp; 1 \\ 0 &amp; 1 &amp; 0 &amp; 1 \end{pmatrix} \times \begin{pmatrix} a_0 \\ a_1 \\ a_2 \\ a_3 \\ \end{pmatrix}\]</article><hr class="dingbat related mb6" /><aside class="related mb4" role="complementary"><h2 class="hr-bottom">Related Posts</h2><ul class="related-posts"><li class="h4"> <a href="/blog/2022/01/30/decryption-ch.html" class="flip-title"><span>Breaking decryption.ch: the CTF that wasn't meant to be</span></a> <time class="faded fine" datetime="2022-01-30T00:00:00+01:00">30 Jan 2022</time><li class="h4"> <a href="/blog/2020/10/05/dragonffi-library-lifting.html" class="flip-title"><span>Lifting shared libraries & PIE binaries with DragonFFI (and LIEF)</span></a> <time class="faded fine" datetime="2020-10-05T00:00:00+02:00">05 Oct 2020</time><li class="h4"> <a href="/blog/2020/08/29/miasm-bootloader.html" class="flip-title"><span>Emulating NotPetya bootloader with Miasm</span></a> <time class="faded fine" datetime="2020-08-29T00:00:00+02:00">29 Aug 2020</time></ul></aside><footer class="content" role="contentinfo"><hr/><p><small class="copyright">© 2024. All rights reserved. </small><p><small>Powered by <a class="external" href="https://hydejack.com/">Hydejack</a> v<span id="_version">9.2.1</span></small><hr class="sr-only"/></footer></main><hy-drawer id="_drawer" class="" side="left" threshold="10" noscroll ><header id="_sidebar" class="sidebar" role="banner"><div class="sidebar-bg " style="background-color:rgb(0,0,0);"></div><div class="sidebar-sticky"><nav class="sidebar-nav heading" role="navigation"> <span class="sr-only">Navigation:</span><ul><li> <a id="_drawer--opened" href="/blog/" class="sidebar-nav-item " > Blog </a><li> <a href="/software/" class="sidebar-nav-item " > Software </a><li> <a href="/pubs/" class="sidebar-nav-item " > Publications </a></ul></nav><div class="sidebar-social"> <span class="sr-only">Social</span><ul><li> <a href="https://twitter.com/adriengnt" title="Twitter" class="no-mark-external"> <span class="icon-twitter"></span> <span class="sr-only">Twitter</span> </a><li> <a href="https://github.com/aguinet" title="GitHub" class="no-mark-external"> <span class="icon-github"></span> <span class="sr-only">GitHub</span> </a></ul></div></div></header></hy-drawer><hr class="sr-only" hidden /> </hy-push-state> <!--[if gt IE 10]><!----> <script nomodule>(()=>{var t,n=document.createElement("script");!("noModule"in n)&&"onbeforeload"in n&&(t=!1,document.addEventListener("beforeload",function(e){if(e.target===n)t=!0;else if(!e.target.hasAttribute("nomodule")||!t)return;e.preventDefault()},!0),n.type="module",n.src=".",document.head.appendChild(n),n.remove())})(); </script> <script src="/assets/js/hydejack-9.2.1.js" type="module"></script> <script src="/assets/js/LEGACY-hydejack-9.2.1.js" nomodule defer></script> <!--<![endif]--><div hidden><h2 class="sr-only">Templates:</h2><template id="_animation-template"><div class="animation-main fixed-top"><nav id="breadcrumbs" class="screen-only"><ul></ul></nav><div class="content"><div class="page"></div></div></div></template> <template id="_loading-template"><div class="loading nav-btn fr"> <span class="sr-only">Loading…</span> <span class="icon-cog"></span></div></template> <template id="_error-template"><div class="page"><h1 class="page-title">Error</h1><p class="lead"> Sorry, an error occurred while loading: <a class="this-link" href=""></a>.</div></template> <template id="_permalink-template"> <a href="#" class="permalink"> <span class="sr-only">Permalink</span> <span class="content-hash"></span> </a> </template></div></html>
