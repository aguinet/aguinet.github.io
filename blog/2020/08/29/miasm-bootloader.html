<!DOCTYPE html>
<html lang="en"><!--
 __  __                __                                     __
/\ \/\ \              /\ \             __                    /\ \
\ \ \_\ \   __  __    \_\ \      __   /\_\      __       ___ \ \ \/'\
 \ \  _  \ /\ \/\ \   /'_` \   /'__`\ \/\ \   /'__`\    /'___\\ \ , <
  \ \ \ \ \\ \ \_\ \ /\ \L\ \ /\  __/  \ \ \ /\ \L\.\_ /\ \__/ \ \ \\`\
   \ \_\ \_\\/`____ \\ \___,_\\ \____\ _\ \ \\ \__/.\_\\ \____\ \ \_\ \_\
    \/_/\/_/ `/___/> \\/__,_ / \/____//\ \_\ \\/__/\/_/ \/____/  \/_/\/_/
                /\___/                \ \____/
                \/__/                  \/___/

Powered by Hydejack v9.1.4 <https://hydejack.com/>
--><head><title>Emulating NotPetya bootloader with Miasm |</title><meta name="description" content="NotPetya is a famous malware of the Petya family. It appeared in June 2017. The part running from the Master Boot Record (MBR) has been statically and dynamically studied, using for instance the Bochs debugger from IDA. Is another approach possible? This article’s goal is to show that we can emulate this bootloader using Miasm. "><link rel="canonical" href="https://aguinet.github.io/blog/2020/08/29/miasm-bootloader.html"><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content=""><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="application-name" content=""><meta name="theme-color" content="rgb(0,0,0)"><meta name="generator" content="Hydejack v9.1.4" /><link rel="alternate" href="https://aguinet.github.io/blog/2020/08/29/miasm-bootloader.html" hreflang="en"><link type="application/atom+xml" rel="alternate" href="https://aguinet.github.io/feed.xml" title="" /><link rel="shortcut icon" href="/assets/icons/favicon.ico"><link rel="apple-touch-icon" href="/assets/icons/icon-192x192.png"><link rel="manifest" href="/assets/site.webmanifest"><link rel="dns-prefetch" href="https://fonts.googleapis.com"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preload" href="/assets/img/swipe.svg" as="image" id="_hrefSwipeSVG"> <script>!function(r,c){"use strict";function a(e,t,n,o){e.addEventListener?e.addEventListener(t,n,o):e.attachEvent?e.attachEvent("on"+t,n):e["on"+t]=n}r.loadJS=function(e,t){var n=c.createElement("script");n.src=e,t&&a(n,"load",t,{once:!0});t=c.scripts[0];return t.parentNode.insertBefore(n,t),n},r._loaded=!1,r.loadJSDeferred=function(e,t){var n=c.createElement("script");function o(){r._loaded=!0,t&&a(n,"load",t,{once:!0});var e=c.scripts[0];e.parentNode.insertBefore(n,e)}return n.src=e,r._loaded?o():a(r,"load",o,{once:!0}),n},r.setRel=r.setRelStylesheet=function(e){a(c.getElementById(e),"load",function(){this.rel="stylesheet"},{once:!0})}}(window,document); !function(a){"use strict";var b=function(b,c,d){function e(a){return h.body?a():void setTimeout(function(){e(a)})}function f(){i.addEventListener&&i.removeEventListener("load",f),i.media=d||"all"}var g,h=a.document,i=h.createElement("link");if(c)g=c;else{var j=(h.body||h.getElementsByTagName("head")[0]).childNodes;g=j[j.length-1]}var k=h.styleSheets;i.rel="stylesheet",i.href=b,i.media="only x",e(function(){g.parentNode.insertBefore(i,c?g:g.nextSibling)});var l=function(a){for(var b=i.href,c=k.length;c--;)if(k[c].href===b)return a();setTimeout(function(){l(a)})};return i.addEventListener&&i.addEventListener("load",f),i.onloadcssdefined=l,l(f),i};"undefined"!=typeof exports?exports.loadCSS=b:a.loadCSS=b}("undefined"!=typeof global?global:this); !function(a){if(a.loadCSS){var b=loadCSS.relpreload={};if(b.support=function(){try{return a.document.createElement("link").relList.supports("preload")}catch(b){return!1}},b.poly=function(){for(var b=a.document.getElementsByTagName("link"),c=0;c<b.length;c++){var d=b[c];"preload"===d.rel&&"style"===d.getAttribute("as")&&(a.loadCSS(d.href,d,d.getAttribute("media")),d.rel=null)}},!b.support()){b.poly();var c=a.setInterval(b.poly,300);a.addEventListener&&a.addEventListener("load",function(){b.poly(),a.clearInterval(c)}),a.attachEvent&&a.attachEvent("onload",function(){a.clearInterval(c)})}}}(this); !function(w) { w._baseURL = '/'; w._publicPath = '/assets/js/'; w._noPushState = false; w._noDrawer = true; w._noNavbar = true; w._noToc = false; w._noSearch = false; w._search = { DATA_URL: '/assets/sitedata.json?no-cache', STORAGE_KEY: 'mini-search/', INDEX_KEY: 'index--2022-01-30T20:24:52+01:00', }; w._clapButton = false; }(window);</script> <script async src="/assets/bower_components/MathJax/es5/tex-mml-chtml.js" id="_MathJax"></script> <!--[if gt IE 8]><!----><style id="_styleInline"> .clearfix,.sidebar-social::after{content:"";display:table;clear:both}.color-transition,.content .avatar,.nav-btn,.nav-btn-bar,.navbar,.message,.note-sm,#markdown-toc,.note,.hr-bottom,.hr-after::after,hr,.hr,p,body{transition:none}html{--font-family: Noto Sans,Helvetica,Arial,sans-serif;--font-family-heading: Roboto Slab,Helvetica,Arial,sans-serif;--code-font-family: ui-monospace,Menlo,Monaco,Cascadia Mono,Segoe UI Mono,Roboto Mono,Oxygen Mono,Ubuntu Monospace,Source Code Pro,Fira Mono,Droid Sans Mono,Courier New,monospace;--body-color: #333;--body-bg: #fff;--border-color: #ebebeb;--gray: #777;--gray-bg: rgba(0,0,0,0.025);--gray-text: #666;--menu-text: #bbb;--inv-body-color: #ccc;--inv-body-bg: #282828;--root-font-size: 15px;--root-font-size-medium: 16px;--root-font-size-large: 17px;--root-font-size-print: 8pt;--root-line-height: 1.75;--font-weight: 400;--font-weight-bold: 700;--font-weight-heading: 700;--content-width-5: 54rem;--content-margin-5: 4rem;--sidebar-width: 21rem;--half-content: 31rem;--break-point-3: 64em;--break-point-5: 86em;--break-point-dynamic: 1664px}html .content{-webkit-font-smoothing:initial;-moz-osx-font-smoothing:initial}*{box-sizing:border-box}html,body{margin:0;padding:0}html{font-family:var(--font-family);font-size:var(--root-font-size);line-height:var(--root-line-height)}body{color:var(--body-color);background-color:var(--body-bg);font-weight:var(--font-weight);overflow-y:scroll}.content img,.img,.content video,.video{max-width:100%;height:auto}.lead{margin-left:-1rem;margin-right:-1rem;margin-bottom:1.5rem}img.lead,video.lead{display:block;max-width:calc(100% + 2rem);width:calc(100% + 2rem);height:auto}.heading,.f6,h6,.h6,.f5,h5,.h5,.f4,.sidebar-nav-item,h4,.h4,.post-date,.f3,h3,.h3,.f2,h2,.h2,.f1,h1,.h1{font-family:var(--font-family-heading);font-weight:var(--font-weight-heading)}.f1,h1,.h1{font-size:2rem;line-height:1.3}.f2,h2,.h2{font-size:1.5rem;line-height:1.4}.f3,h3,.h3{font-size:1.2em;line-height:1.5}.f4,.sidebar-nav-item,h4,.h4,.post-date{font-size:1.08rem;line-height:1.6}.f5,h5,.h5{font-size:1.04rem;line-height:1.7}.f6,h6,.h6{font-size:1rem}.content h1>a,.content .h1>a{text-decoration:none;border-bottom:none}@media screen and (max-width: 42em){.content h1,.content .h1{font-size:1.7rem;line-height:1.35}}@media screen and (min-width: 86em){.content h1,.content .h1{font-size:2.4rem;line-height:1.25}}@media screen and (min-width: 1664px){body:not(.no-large-headings) .content h1,body:not(.no-large-headings) .content .h1{width:calc(100% + 50vw - 32rem);font-size:3rem;line-height:1.2}}@media screen and (min-width: 124em){body:not(.no-large-headings) .content h1,body:not(.no-large-headings) .content .h1{font-size:4rem;line-height:1.1}}h1,h2,h3,.h1,.h2,.h3{margin:4rem 0 1rem}h4,h5,h6,.h4,.post-date,.h5,.h6{margin:3rem 0 .5rem}p{margin-top:0;margin-bottom:1rem}p.lead{font-size:1.2em;margin-top:1.5rem;margin-bottom:1.5rem;padding:0 1rem}ul,ol,dl{margin-top:0;margin-bottom:1rem}ul,ol{padding-left:1.25rem}hr,.hr{border:0;margin:1rem 0;border-top:1px solid var(--border-color)}.hr-after::after{content:"";display:block;margin:1rem 0;border-top:1px solid var(--border-color)}.hr-bottom{border-bottom:1px solid var(--border-color);padding-bottom:.75rem;margin-bottom:1rem}.page{margin-bottom:3em}.page li+li{margin-top:.25rem}.page>header{position:relative;margin-bottom:1.5rem}@media screen and (min-width: 1664px){body:not(.no-third-column) .page>header>.lead+.note-sm,body:not(.no-third-column) .page>header>.lead+#markdown-toc,body:not(.no-third-column) .page>header>.lead+.note,body:not(.no-third-column) .page>header>a.no-hover+.note-sm,body:not(.no-third-column) .page>header>a.no-hover+#markdown-toc,body:not(.no-third-column) .page>header>a.no-hover+.note{position:absolute;right:-25rem;width:21rem;bottom:0;margin-bottom:0}}.page-title,.post-title{margin-top:0}.post-date{display:flex;justify-content:space-between;margin-top:-.6rem;height:2rem;margin-bottom:.85rem;color:var(--gray)}.post-date>.ellipsis,#breadcrumbs.post-date>ul{cursor:pointer}.post-date [class^="icon-"]{display:inline-block;font-size:smaller;margin-right:.25rem}.related-posts{padding-left:0;list-style:none;margin-bottom:2rem}.related-posts>li,.related-posts>li+li{margin-top:1rem}.message,.note-sm,#markdown-toc,.note{margin-bottom:1rem;padding:1rem;color:var(--gray-text);background-color:var(--gray-bg);margin-left:-1rem;margin-right:-1rem}.note-sm,#markdown-toc,.note{background:transparent;color:var(--body-color);font-size:smaller;border-left:1px solid var(--border-color);padding:1.2rem 1rem 0 1rem;margin:1rem -1rem;position:relative}.note-sm:before,#markdown-toc:before,.note:before{font-size:0.667rem;font-weight:bold;font-style:normal;letter-spacing:.025rem;text-transform:uppercase;color:var(--menu-text);position:absolute;top:0}.note-sm[title]:before,#markdown-toc[title]:before,.note[title]:before{content:attr(title) !important}.note{font-size:1rem}@media screen{body::before{content:'';width:.5rem;background:var(--gray-bg);position:fixed;left:0;top:0;bottom:0}}@media (min-width: 64em){body::before{width:21rem}}@media (min-width: 1664px){body::before{width:calc(50% - 31rem)}}@media screen and (min-width: 42em){html{font-size:var(--root-font-size-medium)}}@media screen and (min-width: 124em){html{font-size:var(--root-font-size-large)}}#breadcrumbs>ul{height:1rem;margin:-1.5rem 0 .5rem;padding:0;font-size:.667rem;color:var(--menu-text);text-transform:uppercase;width:100%;list-style:none}#breadcrumbs>ul>li{display:inline}#breadcrumbs>ul>li a{color:var(--gray);text-decoration:none;border-bottom:none}.fl{float:left}.fr{float:right}.mb4{margin-bottom:4rem}.mb6{margin-bottom:6rem}.mt0{margin-top:0}.mt1{margin-top:1rem}.mt2{margin-top:2rem}.mt3{margin-top:3rem}.mt4{margin-top:4rem}.pb0{padding-bottom:0}.ml1{margin-left:1rem}.mr1{margin-right:1rem}.sixteen-nine{position:relative}.sixteen-nine::before{display:block;content:"";width:100%;padding-top:56.25%}.sixteen-nine>*{position:absolute;top:0;left:0;right:0;bottom:0}.sixteen-ten{position:relative}.sixteen-ten::before{display:block;content:"";width:100%;padding-top:62.5%}.sixteen-ten>*{position:absolute;top:0;left:0;right:0;bottom:0}.four-three{position:relative}.four-three::before{display:block;content:"";width:100%;padding-top:75%}.four-three>*{position:absolute;top:0;left:0;right:0;bottom:0}.sr-only{display:none}.larger{font-size:larger}.smaller{font-size:smaller}.clearfix,.sidebar-social::after{content:"";display:table;clear:both}.ellipsis,#breadcrumbs>ul{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.border{border:1px solid var(--border-color)}@media (min-width: 42em){.border-radius,.lead,.page .aspect-ratio.sixteen-nine.lead{border-radius:.5rem}}.fallback-img{background-position:center;background-repeat:no-repeat;background-image:url("data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPHN2ZyB3aWR0aD0iMTYwIiBoZWlnaHQ9IjkwIiB2aWV3Qm94PSIwIDAgMTYwIDkwIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgogIDxnIHRyYW5zZm9ybT0ibWF0cml4KDAuMDQ4ODI4LCAwLCAwLCAwLjA0Nzk5MSwgNTQuOTk5OTczLCAyMC40MjgxNDgpIj4KICAgIDxwYXRoIHN0eWxlPSJmaWxsOnJnYmEoMTI4LDEyOCwxMjgsLjMzKSIgZD0iTTk1OS44ODQgMTI4YzAuMDQwIDAuMDM0IDAuMDgyIDAuMDc2IDAuMTE2IDAuMTE2djc2Ny43N2MtMC4wMzQgMC4wNDAtMC4wNzYgMC4wODItMC4xMTYgMC4xMTZoLTg5NS43N2MtMC4wNDAtMC4wMzQtMC4wODItMC4wNzYtMC4xMTQtMC4xMTZ2LTc2Ny43NzJjMC4wMzQtMC4wNDAgMC4wNzYtMC4wODIgMC4xMTQtMC4xMTRoODk1Ljc3ek05NjAgNjRoLTg5NmMtMzUuMiAwLTY0IDI4LjgtNjQgNjR2NzY4YzAgMzUuMiAyOC44IDY0IDY0IDY0aDg5NmMzNS4yIDAgNjQtMjguOCA2NC02NHYtNzY4YzAtMzUuMi0yOC44LTY0LTY0LTY0djB6Ii8+CiAgICA8cGF0aCBzdHlsZT0iZmlsbDpyZ2JhKDEyOCwxMjgsMTI4LC4zMykiIGQ9Ik04MzIgMjg4YzAgNTMuMDIwLTQyLjk4IDk2LTk2IDk2cy05Ni00Mi45OC05Ni05NiA0Mi45OC05NiA5Ni05NiA5NiA0Mi45OCA5NiA5NnoiLz4KICAgIDxwYXRoIHN0eWxlPSJmaWxsOnJnYmEoMTI4LDEyOCwxMjgsLjMzKSIgZD0iTTg5NiA4MzJoLTc2OHYtMTI4bDIyNC0zODQgMjU2IDMyMGg2NGwyMjQtMTkyeiIvPgogIDwvZz4KPC9zdmc+")}hy-push-state a{color:var(--body-color)}@supports not ((text-decoration-thickness: initial) and (text-underline-offset: initial)){hy-push-state a{text-decoration:none;border-bottom:2px solid}}@supports (text-decoration-thickness: initial) and (text-underline-offset: initial){hy-push-state a{text-decoration-style:solid;text-underline-offset:.35rem;text-decoration-thickness:2px}}hy-push-state a.no-hover{border-bottom:none;text-decoration-thickness:unset;text-underline-offset:unset}.content a:not(.btn):not(.no-hover){border-color:var(--accent-color-faded)}@supports (text-decoration-thickness: initial) and (text-underline-offset: initial){.content a:not(.btn):not(.no-hover){text-decoration-color:var(--accent-color-faded)}}.content .aspect-ratio{overflow:hidden}.content .aspect-ratio img{margin:0;width:100%;height:100%;background-color:var(--gray-bg)}hy-drawer{width:100%;position:relative;overflow:hidden;display:block;z-index:4}@media screen and (min-width: 64em){hy-drawer{position:fixed;width:21rem;top:0;left:0;bottom:0;margin-left:0}hy-drawer.cover{position:relative;width:100%}}@media screen and (min-width: 1664px){hy-drawer{width:calc(50% - 31rem)}}.sidebar{position:relative;display:flex;justify-content:center;align-items:center;color:rgba(255,255,255,0.75);text-align:center;min-height:100vh}.sidebar.invert{color:rgba(32,32,32,0.75)}.sidebar a{color:#fff;border-bottom-color:rgba(255,255,255,0.2);text-decoration-color:rgba(255,255,255,0.2)}.sidebar.invert a{color:#222;border-bottom-color:rgba(32,32,32,0.2);text-decoration-color:rgba(32,32,32,0.2)}.sidebar-bg{position:absolute;top:0;left:calc(50% - 50vw);width:100vw;height:100%;background:#202020 center / cover}.sidebar-bg::after{content:"";position:absolute;top:0;left:0;bottom:0;right:0;background:rgba(0,0,0,0.05)}.sidebar-bg.sidebar-overlay::after{background:linear-gradient(to bottom, rgba(32,32,32,0) 0%, rgba(32,32,32,0.5) 50%, rgba(32,32,32,0) 100%)}.sidebar-sticky{position:relative;z-index:3;max-width:21rem;padding:1.5rem;contain:content}.sidebar-about .avatar{margin-bottom:1.5rem}.sidebar-about>a.sidebar-title{text-decoration:none}.sidebar-about>a.sidebar-title>h2{margin:0;padding-bottom:.5rem}.sidebar-about>a.sidebar-title::after{content:'';display:block;border-bottom:2px solid;margin:0 auto .5rem;width:4rem;border-color:rgba(255,255,255,0.2);transition:border-color 250ms}.sidebar-about>a.sidebar-title:hover::after{border-color:#fff;transition:border-color 50ms}.sidebar.invert .sidebar-about>a.sidebar-title::after{border-color:rgba(32,32,32,0.2)}.sidebar.invert .sidebar-about>a.sidebar-title:hover::after{border-color:#222}.sidebar-nav>ul{list-style:none;padding-left:0}.sidebar-nav-item{display:inline-block;margin-bottom:.5rem}@media (min-width: 64em){#_main.no-drawer #_menu{display:none}#_main.no-drawer .nav-btn-bar>:nth-child(2){border:none}}.sidebar-social>ul{display:inline-block;list-style:none;padding-left:0;margin-bottom:0}.sidebar-social>ul>li{float:left}.sidebar-social>ul>li>a{display:inline-block;text-align:center;font-size:1.4rem;width:3rem;height:4rem;padding:.5rem 0;line-height:3rem;text-decoration:none;border-bottom-width:2px;border-bottom-style:solid}.sidebar-social>ul li+li{margin-top:0}.fixed-common,.fixed-bottom,.fixed-top{position:fixed;left:0;width:100%;z-index:2}.fixed-top{top:0}.fixed-bottom{bottom:0}.navbar>.content{position:relative;padding-top:0;padding-bottom:0;min-height:0;max-height:5rem}.nav-btn-bar{margin:0 -1rem;background-color:white;background-color:var(--body-bg);height:5rem;display:flex;align-items:center;position:relative}.nav-btn-bar>:first-child,.nav-btn-bar>:last-child{border:none}.nav-btn{background:none;border:none;text-decoration:none;display:flex;align-items:center;justify-content:center;width:3.25rem;height:5rem;color:var(--menu-text);border-right:1px solid var(--border-color);border-left:1px solid var(--border-color);margin-left:-1px}#markdown-toc{margin:2rem -1rem 2rem calc(-1rem + 1px);padding-left:2.5rem;padding-bottom:.5rem}#markdown-toc:before{left:1rem}@media screen and (min-width: 1664px){body:not(.no-toc) #markdown-toc{position:absolute;z-index:4;width:20.5rem;right:0;margin:auto;overflow:auto}}@media screen and (min-width: 1664px){body.no-break-layout:not(.no-toc) #markdown-toc{width:calc(50% - 31rem)}}.content{margin-left:auto;margin-right:auto;padding:8rem 1rem 12rem}@media screen{.content{padding-left:1.5rem;min-height:100vh}}@media screen and (min-width: 42em){.content{max-width:42rem}}@media screen and (min-width: 54em){.content{max-width:48rem}}@media screen and (min-width: 64em){.content{padding-left:1rem;margin-left:24rem;margin-right:3rem}}@media screen and (min-width: 86em){.content{padding-top:9rem;margin-left:25rem;margin-right:4rem;max-width:54rem}}@media screen and (min-width: 1664px){.content{margin:auto}}.large-only{display:none}@media screen and (min-width: 1664px){.large-only{display:block}}.avatar{width:7rem;height:7rem;border-radius:100%;overflow:hidden;display:inline-block}.avatar img{width:100%}.content .avatar{float:right;box-sizing:content-box;border:1rem solid var(--body-bg);transition:border-color 1s ease;margin-top:-1.5rem;margin-right:-1rem}.center-image{margin:0 auto;display:block}.note:before{content:"Note"}.page>header>.note-sm:before,.page>header>.note:before,.page>header>#markdown-toc:before{content:"Description"}#markdown-toc:before{content:"Table of Contents"}.layout-resume .note-sm:before,.layout-resume .note:before,.layout-resume #markdown-toc:before{content:"Summary"}</style><link rel="preload" as="style" href="/assets/css/hydejack-9.1.4.css" id="_stylePreload"><link rel="preload" as="style" href="/assets/icomoon/style.css" id="_iconsPreload"><link rel="preload" as="style" href="https://fonts.googleapis.com/css?family=Roboto+Slab:700%7CNoto+Sans:400,400i,700,700i&display=swap" id="_fontsPreload"> <script> setRel('_stylePreload'); setRel('_iconsPreload'); /**/setRel('_fontsPreload');/**/ </script> <noscript><link rel="stylesheet" href="/assets/css/hydejack-9.1.4.css"><link rel="stylesheet" href="/assets/icomoon/style.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto+Slab:700%7CNoto+Sans:400,400i,700,700i&display=swap"> </noscript><style id="_pageStyle"> html{--accent-color: rgb(0,0,0);--accent-color-faded: rgba(0,0,0,0.5);--accent-color-highlight: rgba(0,0,0,0.1);--accent-color-darkened: #000;--theme-color: rgb(0,0,0)}</style><!--<![endif]--><body class="no-break-layout no-drawer"> <hy-push-state id="_pushState" replace-selector="#_main" link-selector="a[href]:not([href^='/assets/']):not(.external):not(.no-push-state)" script-selector="script" duration="500" hashchange ><main id="_main" class="content layout-post" role="main" ><nav id="breadcrumbs" class="screen-only"><ul><li><a href="/">home</a><li> <span>/</span> <a href="/blog/">blog</a><li> <span>/</span> <a href="/blog/2020/">2020</a><li> <span>/</span> <a href="/blog/2020/08/">08</a><li> <span>/</span> <a href="/blog/2020/08/29/">29</a><li> <span>/</span> <span>miasm-bootloader.html</span></ul></nav><article id="post-blog-2020-08-29-miasm-bootloader" class="page post mb6" role="article"><header><h1 class="post-title flip-project-title"> Emulating NotPetya bootloader with Miasm</h1><div class="post-date"> <span class="ellipsis mr1"> <time datetime="2020-08-29T00:00:00+02:00">29 Aug 2020</time> in <span>Blog</span> </span></div><div class="hr pb0"></div></header><p>NotPetya is a famous malware of the Petya family. It appeared in June 2017. The part running from the Master Boot Record (MBR) has been statically and dynamically studied, using for instance the Bochs debugger from IDA. Is another approach possible? This article’s goal is to show that we can emulate this bootloader using Miasm.<p><em>This article has been written by <a href="https://twitter.com/la_F0uin3">Jordan Bouyat (@la_F0uin3)</a> and <a href="https://twitter.com/adriengnt">Adrien Guinet (@adriengnt)</a>. It has originally been published in the <a href="https://connect.ed-diamond.com/MISC/MISC-098/Emulation-du-bootloader-de-NotPetya-avec-Miasm">MISC magazine n°98</a> in French. This is a slightly updated and English translation of this article.</em><h1 id="introduction">Introduction</h1><p>This Petya variant first appeared in June 2017 in Ukraine. According to Mikko Hyppönen, Chief Research Officer at F-Secure, the infection vector would be the update mechanism of the accountability software M.E.Doc, widely deployed within Eastern countries.<p>This malware family has the particularity of overwriting the bootloader of the compromised machine in order to encrypt parts of the hard drive when it reboots. This article uses this bootloader as a pretext for a tutorial concerning the emulation and reverse engineering of these little beasts thanks to the Miasm framework. The associated code is available here: <a href="https://github.com/aguinet/miasm-bootloader/">https://github.com/aguinet/miasm-bootloader/</a>. It contains a Python implementation of a subset of the interfaces of a classic x86 PC BIOS. The code was written in a way that is easily reusable for other cases, or even to help the development / debugging of bootloaders in general.<h2 id="related-works">Related works</h2><p>Many articles have already studied the behaviour of the NotPetya MBR, as well as its various cryptographic implementations and mechanisms (and their faults). Here are some significant ones:<ul><li>MISC n°86 : “Pleased to meet you, my name is Petya !”, written by Damien Schaeffer in July 2016<li>MISC n°93 : “Petya or Not Petya, that is the question”, written by “Teddy and Benjamin” in September 2017, with a very thorough static reverse engineering of the bootloader.<li>Crowdstrike : <a href="https://www.crowdstrike.com/blog/full-decryption-systems-encrypted-petya-notpetya/">Full Decryption of Systems Encrypted by Petya/NotPetya</a>. Study of an implementation error within the Salsa20 algorithm embedded in the bootloader (more on that subject later in the article).</ul><h2 id="notpetya">NotPetya</h2><p>This section deals only in a very general way with the malware’s cycle of life. It allows us to highlight the part studied in this article.<p>Once NotPetya has run on the victim’s machine, it generates an AES encryption key that will be used to achieve the first encryption phase. This key is itself encrypted with an RSA public key.<p>The malware then checks that the system uses a classical partition scheme and, if it has admin rights, enters its own data on the first sectors of the disc (from 1 to 18, then 32 to 34), with its own MBR in the first sector. If the system uses UEFI (with a GPT partition scheme), the malware skips this step. The machine then is restarted and the NotPetya bootloader executed: a Salsa20 key and a nonce are generated. These secrets are used to encrypt the Master File Table (MFT) <sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup> of NTFS file system. This data structure contains the metadata needed to find the data associated with each file. This operation looks like a classical “chkdsk”. Once this operation is done, the machine restarts one last time and then displays the ransom message.<h2 id="miasm">Miasm</h2><p>Miasm is a reverse engineering framework developed in Python. It has many features, among which:<ul><li>open, modify and generate binaries in PE, ELF 32, 64 LE, BE.<li>assemble/disassemble x86, ARM, MIPS, SH4, PPC and MSP430 code.<li>lift instruction semantics into a custom intermediate representation.<li>emulate this intermediate representation, with various JIT (Just-in-time) compilers to speed things up.<li>simplify/modify this intermediate representation, to de-obfuscate code for instance.</ul><h2 id="why-emulate-notpetya-with-miasm">Why emulate NotPetya with Miasm?</h2><p><img src="/assets/2020-08-29-miasm-bootloader/crazy.gif" alt="" class="center-image" /><p>There are various ways to emulate a bootloader. A classical approach is to use QEMU (or any other virtualization/emulation solution) by writing the bootloader on a virtual hard disk, but it makes it difficult to instrument the bootloader code. Such a thing is however possible via IDA’s Bochs debugger. This approach was adopted by Teddy and Benjamin in MISC No. 93, but also by Saurabh Sharma <sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup>. This method usually works well and makes debugging a bootloader an easy task.<p>In the article associated with the presentation of his Miasm tool at SSTIC in 2012 <sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">3</a></sup>, Fabrice Desclaux showed Miasm possibilities. One of the proposed applications was the emulation of a bootloader.<p>The ability to fully emulate a bootloader (until the BIOS interruption) with a framework like Miasm gives a sharper control over what’s happening, possibly allow de-obfuscation, and use all the tools developed in Miasm for this task. It becomes for example very simple to instrument the code in order to see the data read/written on the disk, the secrets generated, etc.<p>Eventually, NotPetya’s bootloader code is succinct, non-obfuscated and extremely simple (it runs in real mode, in 16 bits and calls only a few BIOS interruptions), so it is a nice case study to play with Miasm!<h1 id="pcx86-bootloader">PC/x86 bootloader</h1><h2 id="introduction-1">Introduction</h2><p>We will only discuss here the inner workings of “old-school” BIOS bootloaders. We will not talk about UEFI.<p>On x86 PCs, when the machine starts, the BIOS loads the first disk sector (named Master Boot Record, or MBR) at <code class="language-plaintext highlighter-rouge">0x7C00</code>, and then jumps to this address. The MBR hence contains the bootloader code. At this moment, the processor only supports 16-bit instructions and can only address memory in real mode <sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote" rel="footnote">4</a></sup>.<p>As a reminder, one disk sector contains 512 bytes. Therefore, it is not possible to store a lot of code on this sector only. That’s why bootloaders are usually designed in several stages. Indeed, the code in the first sector (the first stage) will load the stage 2 code from the hard drive , and then jump into it.<p>Below is the MBR’s structure written by NotPetya:<p><a name="fig:notpetya_mbr"></a> <img src="/assets/2020-08-29-miasm-bootloader/mbr-structure.png" alt="" width="500px" class="center-image" /><h2 id="notpetya-case">NotPetya case</h2><p>NotPetya works exactly this way. The bootstrap code (in green in the <a href="#fig:notpetya_mbr">figure above</a>) is the assembly code below. The code at address <code class="language-plaintext highlighter-rouge">0x7C38</code> (that we named <code class="language-plaintext highlighter-rouge">disk_read_stage2</code>), writes data in sectors 2 to 34 (inclusive) in memory at <code class="language-plaintext highlighter-rouge">0x8000</code>, and then jumps to this address:<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>seg000:7C00 cli
seg000:7C01 xor ax, ax
seg000:7C03 mov ds, ax
seg000:7C05 mov ss, ax
seg000:7C07 mov es, ax
seg000:7C09 lea sp, start
seg000:7C0D sti
seg000:7C0E mov eax, 32
seg000:7C14 mov byte ptr ds:word_7C93, dl
seg000:7C18 mov ebx, 1
seg000:7C1E mov cx, 8000h
seg000:7C21 call disk_read_stage2
seg000:7C24 dec eax
seg000:7C26 cmp eax, 0
seg000:7C2A jnz short loc_7C21
seg000:7C2C mov eax, dword ptr ds:8000h
seg000:7C30 jmp far ptr 0:8000h
</code></pre></div></div><h1 id="emulation-with-miasm">Emulation with Miasm</h1><h2 id="installation">Installation</h2><p>The system used for these tests is Linux-based. Windows 10 users should be able to make it work by using Windows Subsystem for Linux (WSL), by installing for example Ubuntu using the Windows Store <sup id="fnref:5" role="doc-noteref"><a href="#fn:5" class="footnote" rel="footnote">5</a></sup>.<p>We recommend using the version of Miasm specified in the <code class="language-plaintext highlighter-rouge">README</code> file from the GitHub repository. At the time of writing lines, the version used is v0.1.1. To recover this specific version, do:<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git clone --depth=1 --branch=v0.1.1 https://github.com/cea-sec/miasm/
</code></pre></div></div><p>We use the LLVM-based Miasm JIT engine, which needs the <code class="language-plaintext highlighter-rouge">llvmlite</code> python package. Other needed dependencies are installable directly through the provided <code class="language-plaintext highlighter-rouge">requirements.txt</code> file:<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ cd /path/to/src &amp;&amp; pip install -r requirements.txt
</code></pre></div></div><p>Then just install Miasm:<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ cd /path/to/miasm &amp;&amp; pip install -r requirements.txt &amp;&amp; python ./setup.py install
</code></pre></div></div><h2 id="implementation">Implementation</h2><p>All the techniques described in this article can be tried thanks to the <code class="language-plaintext highlighter-rouge">src/emulate_mbr.py</code> script in the aforementioned GitHub repository.<p>Multiple options are provided, some of them could be used to win some time during your experiments:<ul><li><p><code class="language-plaintext highlighter-rouge">--dry</code>: simulates the success of disk writings, but actually writes nothing.<li><p><code class="language-plaintext highlighter-rouge">--skip-encryption</code>: the encryption function (which is the hottest one) will be ignored (actually transforming it into a function that does nothing).<li><p><code class="language-plaintext highlighter-rouge">--verbose-bios-data</code>: dumps log messages from our BIOS implementation, with a dump of read and written disk data.<li><p><code class="language-plaintext highlighter-rouge">--verbose-bios</code>: same as <code class="language-plaintext highlighter-rouge">--verbose-bios-data</code>, without the read and written disk data.</ul><p>The <code class="language-plaintext highlighter-rouge">--help</code> flag can be used to have a more detailed list of available options.<p>The activation of Miasm’s logs can considerably slow down the performances of the overall script. The <code class="language-plaintext highlighter-rouge">--log-miasm-newblocks</code> option only dumps blocks that have never been “jitted” by Miasm.<h2 id="creation-of-a-test-disk">Creation of a test disk</h2><p>We performed our tests with virtual machines running Windows XP and Windows 10. The underlying hypervisor does not matter (VMWare, VirtualBox), as long as the disk created has a fixed size and is using VMDK. The emulation of the bootloader is done directly on the virtual machine’s disk. An advantage to this method is that there is no need to extract the bootloader from the original malware DLL or from the generated VMDK.<p class="figure"><img src="/assets/2020-08-29-miasm-bootloader/setup.png" alt="" width="400px" class="center-image" /> Emulation scenario<p>The test scenario is the following:<ol><li>voluntary infection of the virtual machine with NotPetya<li>wait for at least 10s (the machine shouldn’t reboot by itself, or the bootloader will actually launch its encryption code)<li>shutdown the virtual machine: the MBR has been replaced<li>run the emulation: the MFT is encrypted by the bootloader which then displays the ransom</ol><p>If your virtual machine is not using a flat VMDK representation, you can convert it using QEMU:<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ qemu-img convert -f vmdk mydisk.vmdk -O raw mydisk.raw
</code></pre></div></div><p>We also give a test image in the aforementioned Git repository (file <code class="language-plaintext highlighter-rouge">disk.raw.bz2</code>). Once unzipped, it is a 1GB file, and contains a simple NTFS partition with some test files.<p>We can now emulate the NotPetya bootloader. In order to do this, we need to emulate a BIOS capable of:<ul><li>reading/writing disk sectors<li>showing characters on the screen<li>capturing key strokes<li>booting on an MBR (“light” boot/reboot)</ul><p>We are going to see how to implement this using Miasm.<h2 id="system-abstraction">System abstraction</h2><p>We implement an abstraction of a simple system as seen by the BIOS. It contains:<ul><li>a virtual disk (the <code class="language-plaintext highlighter-rouge">HardDrive</code> class)<li>a video screen, which goes through a classical Unix terminal, using the <code class="language-plaintext highlighter-rouge">stdout</code> pipe<li>a keyboard, which uses the <code class="language-plaintext highlighter-rouge">stdin</code> pipe to gather key strokes (functions in <code class="language-plaintext highlighter-rouge">async_kb.py</code>)</ul><p>Abstraction is implemented in the <code class="language-plaintext highlighter-rouge">System</code> class, of which one instance is used during the emulation. This instance is initialized alongside the Miasm VM.<h2 id="miasm-virtual-machine-initialization">Miasm virtual machine initialization</h2><p>As explained in the introduction, the MBR code is loaded and executed by the BIOS at the address <code class="language-plaintext highlighter-rouge">0x7C00</code>. Then, this code will load and write its second stage at the address <code class="language-plaintext highlighter-rouge">0x8000</code>. The left space is dedicated to the stack. It begins at the address <code class="language-plaintext highlighter-rouge">0x500</code> and ends at the address <code class="language-plaintext highlighter-rouge">0x07C00</code>. Therefore, the corresponding space is <code class="language-plaintext highlighter-rouge">[0x00000500:0x00007BFF]</code>.<p>First, we need to declare these memory spaces to the Miasm virtual machine:<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">HD0</span> <span class="o">=</span> <span class="n">HardDrive</span><span class="p">(</span><span class="n">hd_path</span><span class="p">)</span>
<span class="n">sys_</span> <span class="o">=</span> <span class="n">System</span><span class="p">([</span><span class="n">HD0</span><span class="p">])</span>
<span class="n">mbr</span> <span class="o">=</span> <span class="n">HD0</span><span class="p">.</span><span class="n">read_sector</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">stage1_addr</span> <span class="o">=</span> <span class="mh">0x07C00</span>
<span class="n">stage2_addr</span> <span class="o">=</span> <span class="mh">0x08000</span>
<span class="n">jitter</span><span class="p">.</span><span class="n">vm</span><span class="p">.</span><span class="n">add_memory_page</span><span class="p">(</span><span class="n">stage1_addr</span><span class="p">,</span> <span class="n">PAGE_READ</span> <span class="o">|</span> <span class="n">PAGE_WRITE</span> <span class="o">|</span> <span class="n">PAGE_EXEC</span><span class="p">,</span> <span class="n">mbr</span><span class="p">,</span> <span class="s">"NotPetyaS1"</span><span class="p">)</span>
<span class="n">jitter</span><span class="p">.</span><span class="n">vm</span><span class="p">.</span><span class="n">add_memory_page</span><span class="p">(</span><span class="n">stage2_addr</span><span class="p">,</span> <span class="n">PAGE_READ</span> <span class="o">|</span> <span class="n">PAGE_WRITE</span> <span class="o">|</span> <span class="n">PAGE_EXEC</span><span class="p">,</span> <span class="s">"</span><span class="se">\x00</span><span class="s">"</span><span class="o">*</span><span class="n">SECTOR_LEN</span><span class="o">*</span><span class="mi">32</span><span class="p">,</span> <span class="s">"NotPetyaS2"</span><span class="p">)</span>
<span class="n">jitter</span><span class="p">.</span><span class="n">vm</span><span class="p">.</span><span class="n">add_memory_page</span><span class="p">(</span><span class="mh">0x500</span><span class="p">,</span> <span class="n">PAGE_READ</span> <span class="o">|</span> <span class="n">PAGE_WRITE</span><span class="p">,</span> <span class="s">"</span><span class="se">\x00</span><span class="s">"</span><span class="o">*</span><span class="p">(</span><span class="mh">0x7C00</span><span class="o">-</span><span class="mh">0x500</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="s">"Stack"</span><span class="p">)</span>
<span class="c1"># Pretty print of the memory layout
</span><span class="k">print</span><span class="p">(</span><span class="n">jitter</span><span class="p">.</span><span class="n">vm</span><span class="p">)</span>
</code></pre></div></div><p>Now, the memory layout of the Miasm virtual machine is the following:<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Addr               Size               Access Comment 
0x500              0x7700             RW_    Stack 
0x7C00             0x200              RWX    NotPetyaS1 
0x8000             0x4000             RWX    NotPetyaS2
</code></pre></div></div><p>NotPetya loads 32 sectors from the disk to the memory when executing the first stage. This is why the allocated memory for the second stage is 32 sectors long (32*512 bytes).<h2 id="bios-interruption-handling-in-miasm">BIOS interruption handling in Miasm</h2><p>Miasm allows us to specify an interruption handler which will be called whenever an <code class="language-plaintext highlighter-rouge">INT</code> instruction is executed. To do so, we have to tell Miasm to call our BIOS interruption handler <code class="language-plaintext highlighter-rouge">exception_int</code> with the help of <code class="language-plaintext highlighter-rouge">add_exception_handler</code> of the current used jitter:<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">jitter</span><span class="p">.</span><span class="n">add_exception_handler</span><span class="p">(</span><span class="n">EXCEPT_INT_XX</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">jitter</span><span class="p">:</span> <span class="n">exception_int</span><span class="p">(</span><span class="n">jitter</span><span class="p">,</span> <span class="n">sys_</span><span class="p">))</span>
</code></pre></div></div><h2 id="interruption-support">Interruption support</h2><p>Now, we have to implement the different BIOS interruption handlers. We can split them into four main families :<ul><li><code class="language-plaintext highlighter-rouge">INT 10h</code> : access to the screen (write characters, change colors…),<li><code class="language-plaintext highlighter-rouge">INT 13h</code> : access to the disk (read/write sectors, get disk geometry…),<li><code class="language-plaintext highlighter-rouge">INT 16h</code> : access to the keyboard (read keystroke…),<li><code class="language-plaintext highlighter-rouge">INT 19h</code> : boot on the disk’s MBR.</ul><h3 id="int-13h">INT 13h</h3><p>Here is an example of the <code class="language-plaintext highlighter-rouge">INT 13h</code> interruption, with the <code class="language-plaintext highlighter-rouge">0x43</code> code function (<code class="language-plaintext highlighter-rouge">Extended Read Sectors From Drive</code>). This code implements the instruction to load multiple sectors from the disk to the memory:<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">@</span><span class="n">func</span><span class="p">(</span><span class="n">disk_interrupts</span><span class="p">,</span> <span class="mh">0x42</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">extended_read_sectors</span><span class="p">(</span><span class="n">jitter</span><span class="p">,</span> <span class="n">sys_</span><span class="p">):</span>
    <span class="n">drive_idx</span> <span class="o">=</span> <span class="n">get_xl</span><span class="p">(</span><span class="n">jitter</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">DX</span><span class="p">)</span>
    <span class="k">print</span> <span class="s">"Extended read sectors, drive idx 0x%x"</span> <span class="o">%</span> <span class="n">drive_idx</span>

    <span class="n">dap</span> <span class="o">=</span> <span class="n">jitter</span><span class="p">.</span><span class="n">vm</span><span class="p">.</span><span class="n">get_mem</span><span class="p">((</span><span class="n">jitter</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">DS</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span><span class="o">+</span><span class="n">jitter</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">SI</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>
    <span class="n">dap_size</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">num_sect</span><span class="p">,</span> <span class="n">buff_addr</span><span class="p">,</span> <span class="n">abs_sect</span> <span class="o">=</span> <span class="n">struct</span><span class="p">.</span><span class="n">unpack</span><span class="p">(</span><span class="s">"&lt;BBHIQ"</span><span class="p">,</span> <span class="n">dap</span><span class="p">)</span>

    <span class="n">hd</span> <span class="o">=</span> <span class="n">sys_</span><span class="p">.</span><span class="n">hd</span><span class="p">(</span><span class="n">drive_idx</span><span class="p">)</span>

    <span class="k">print</span><span class="p">(</span><span class="s">"  Read %d sectors from sector %d"</span> <span class="o">%</span> <span class="p">(</span><span class="n">num_sect</span><span class="p">,</span> <span class="n">abs_sect</span><span class="p">))</span>
    <span class="n">size</span> <span class="o">=</span> <span class="n">num_sect</span> <span class="o">*</span> <span class="n">SECTOR_LEN</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">hd</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="n">abs_sect</span> <span class="o">*</span> <span class="n">SECTOR_LEN</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>

    <span class="n">jitter</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">cf</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># No error
</span>    <span class="c1"># AL is the number of sectors read
</span>    <span class="c1"># AH is the return code, 0 = successful completion 
</span>    <span class="n">jitter</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">AX</span> <span class="o">=</span> <span class="n">set_16bit_reg</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">/</span> <span class="n">SECTOR_LEN</span><span class="p">),</span> <span class="n">high</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">jitter</span><span class="p">.</span><span class="n">vm</span><span class="p">.</span><span class="n">set_mem</span><span class="p">(</span><span class="n">buff_addr</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
</code></pre></div></div><p>Note: this Python code doesn’t include error management for readability reasons. The <code class="language-plaintext highlighter-rouge">sys_</code> object is the system abstraction explained in <a href="#system-abstraction">System abstraction</a>.<p>Sectors can be loaded from disk in two different ways by using a different kind of addressing mechanism for the same <code class="language-plaintext highlighter-rouge">INT 13h</code> interruption:<ol><li><p>CHS (Cylinder, Head, Sector) addressing mechanism, used by the <code class="language-plaintext highlighter-rouge">02h</code>/<code class="language-plaintext highlighter-rouge">03h</code> codes. It can read/write one or many sectors by specifying the index of the cylinder and the head,<li><p>LBA (Logical Bloc Addressing) addressing mechanism, used by the <code class="language-plaintext highlighter-rouge">42h</code>/<code class="language-plaintext highlighter-rouge">43h</code> codes. It can read/write one or several sectors by specifying the corresponding sector in a absolute way, i.e. by specifying the offset from the first sector number on the disk regardless of heads/cylinders.</ol><p>NotPetya uses the LBA addressing mechanism. This method needs to fill a DAP (Disk Address Packet) structure. This structure describes which sectors to read/write and where to read/write them into live memory.<p>One can see that an extended LBA structure exists to read or write multiple sectors at the same time:<table><tbody><tr><td>0<td>1<td>Packet size<tr><td>1<td>1<td>Zeroed field<tr><td>2<td>2<td>Number of sectors to load<tr><td>4<td>4<td>Buffer address to load sectors to (seg:off)<tr><td>8<td>8<td>Absolute offset of the first sector to read</table><p>To sum up:<ol><li>the DAP is parsed,<li>data is read from the virtual disk,<li>the read data is stored in the corresponding memory page of the instantiated Miasm virtual machine.</ol><p>The writing mechanism is the exact opposite: the specified buffer address in the DAP contains the data to write.<h3 id="int-19h">INT 19h</h3><p>The second chosen example is the <code class="language-plaintext highlighter-rouge">INT 19h</code> interruption (diskboot). It reboots the machine <sup id="fnref:7" role="doc-noteref"><a href="#fn:7" class="footnote" rel="footnote">6</a></sup><sup id="fnref:8" role="doc-noteref"><a href="#fn:8" class="footnote" rel="footnote">7</a></sup> and is used in two locations :<ol><li>at address <code class="language-plaintext highlighter-rouge">0x892E</code>, which is called if a fatal error occurs,<li>at address <code class="language-plaintext highlighter-rouge">0x820D</code>, when the machine reboots after the MFT encryption.</ol><p>The <code class="language-plaintext highlighter-rouge">INT 19h</code> interruption is called right after the POST (Power On Self Test) procedure by the BIOS. After that, the MBR code is loaded into live memory at <code class="language-plaintext highlighter-rouge">Ox7C00</code>. Then, the BIOS jumps at this address.<p>So we can say here that it is used as a sort of <em>soft reboot</em> because the reboot is not a complete one. This instruction is part of the boot process after BIOS execution. Some BIOS can handle boot medium priority while others just loop over available mediums and boot on the first one it can.<p>Here, we will emulate this instruction simply by loading again the MBR code into the memory page dedicated to it (stage 1), and then jump onto it (at address <code class="language-plaintext highlighter-rouge">0x7C00</code>):<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">diskboot_interrupts</span> <span class="o">=</span> <span class="n">FuncTable</span><span class="p">(</span><span class="s">"INT 19h (diskboot)"</span><span class="p">)</span>
<span class="o">@</span><span class="n">func</span><span class="p">(</span><span class="n">diskboot_interrupts</span><span class="p">,</span> <span class="mh">0x02</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">reboot</span><span class="p">(</span><span class="n">jitter</span><span class="p">,</span> <span class="n">sys_</span><span class="p">):</span>
    <span class="c1"># Here, we assume only one bootable disk (index 0)
</span>    <span class="n">hd</span> <span class="o">=</span> <span class="n">sys_</span><span class="p">.</span><span class="n">hd</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">mbr</span> <span class="o">=</span> <span class="n">hd</span><span class="p">.</span><span class="n">read_sector</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">jitter</span><span class="p">.</span><span class="n">vm</span><span class="p">.</span><span class="n">set_mem</span><span class="p">(</span><span class="mh">0x7C00</span><span class="p">,</span> <span class="n">mbr</span><span class="p">)</span>
    <span class="n">jitter</span><span class="p">.</span><span class="n">pc</span> <span class="o">=</span> <span class="mh">0x7C00</span>
</code></pre></div></div><h2 id="for-a-few-more-hacks">For a few more hacks…</h2><p>The <code class="language-plaintext highlighter-rouge">STI</code> (<em>Set Interrupt Flag</em>) instruction is used at address <code class="language-plaintext highlighter-rouge">0x7C0D</code>. It can activate masked interruptions (<em>flag</em> <code class="language-plaintext highlighter-rouge">IF</code> and offset 9 of the <code class="language-plaintext highlighter-rouge">FLAGS</code> register). This <em>flag</em> doesn’t have any effect on non-maskable interruptions. Because hardware interruptions are fully emulated, Miasm doesn’t contain (legitimately) semantics for this instruction.<p>So we simply decided to ignore it by setting a breakpoint at its corresponding address:<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">jitter</span><span class="p">.</span><span class="n">add_breakpoint</span><span class="p">(</span><span class="mh">0x7C0D</span><span class="p">,</span> <span class="n">handle_sti</span><span class="p">)</span>
</code></pre></div></div><p>Then, we redirect the execution flow to the next instruction. Because this instruction is only 1 byte long, a simple incrementation of the program counter does the trick:<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">handle_sti</span><span class="p">(</span><span class="n">jitter</span><span class="p">):</span>
    <span class="n">jitter</span><span class="p">.</span><span class="n">pc</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="bp">True</span>
</code></pre></div></div><h2 id="yippie-kay-yay-motherfucker-">Yippie kay yay motherfucker !</h2><p>Now that the useful handlers are implemented and the MBR code is loaded and mapped in Miasm virtual machine, emulation of NotPetya can begin:<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">jitter</span><span class="p">.</span><span class="n">init_run</span><span class="p">(</span><span class="n">stage1_addr</span><span class="p">)</span>
<span class="n">jitter</span><span class="p">.</span><span class="n">continue_run</span><span class="p">()</span>
</code></pre></div></div><p>If the <code class="language-plaintext highlighter-rouge">--verbose-bios-data</code> flag is set (see <a href="#implementation">Implementation</a>), output of the script prints the content of the various read and write operations on the disk. For example, here is the content of the second sector (of the 32 loaded sectors by the bootloader at <code class="language-plaintext highlighter-rouge">0x8000</code>):<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Extended read sectors, drive idx 0x0
  Read 1 sectors from sector 2
00000000: 50 FF 76 04 E8 91 0A 83  C4 0A E8 3B 07 CD 19 5E  P.v........;...^
00000010: C9 C3 6A 0E E8 39 07 5B  68 70 9C E8 C0 03 5B C3  ..j..9.[hp....[.
00000020: C8 04 04 00 56 6A 00 6A  01 6A 00 6A 20 8D 86 FC  ....Vj.j.j.j ...
00000030: FD 50 8A 46 06 50 E8 21  0A 83 C4 0C 6A 00 68 8E  .P.F.P.!....j.h.
[...]
</code></pre></div></div><p>The loaded code matchs stage 2. Also, one can easily see the content loaded from sector 32:<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Extended read sectors, drive idx 0x80
  Read 1 sectors from sector 32
00000000: 00 AA 92 E7 82 11 15 D3  20 96 A7 75 51 C0 36 08  ........ ..uQ.6.
00000010: E8 65 42 8C 73 9F 06 53  77 CB C5 95 60 C8 38 69  .eB.s..Sw...`.8i
00000020: 9B 0D A4 99 E0 13 12 30  79 31 4D 7A 37 31 35 33  .......0y1Mz7153
00000030: 48 4D 75 78 58 54 75 52  32 52 31 74 37 38 6D 47  HMuxXTuR2R1t78mG
00000040: 53 64 7A 61 41 74 4E 62  42 57 58 00 00 00 00 00  SdzaAtNbBWX.....
00000050: 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  ................
00000060: 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  ................
00000070: 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  ................
00000080: 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  ................
00000090: 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  ................
000000A0: 00 00 00 00 00 00 00 00  00 48 34 79 5A 73 77 56  .........H4yZswV
000000B0: 54 64 43 6B 43 77 55 68  72 31 4D 52 6D 4A 65 69  TdCkCwUhr1MRmJei
000000C0: 76 31 34 46 4B 39 6A 5A  6A 4D 36 36 4C 44 79 65  v14FK9jZjM66LDye
000000D0: 71 52 4C 64 6B 38 53 58  53 53 73 53 53 45 78 34  qRLdk8SXSSsSSEx4
000000E0: 44 51 57 4E 47 00 00 00  00 00 00 00 00 00 00 00  DQWNG...........
000000F0: 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  ................
[...]
000001F0: 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  ...............
</code></pre></div></div><p>This sector is where NotPetya stores data. According to the description done in <a href="https://boutique.ed-diamond.com/numeros-deja-parus/1268-misc-93.html">MISC 805 n°93</a>, we can deduct its content :<ul><li><code class="language-plaintext highlighter-rouge">0x00</code> is the encrypted disk flag,<li><code class="language-plaintext highlighter-rouge">AA 92 E7 82 11 15 D3 20 96 A7 75 51 C0 36 08 E8 65 42 8C 73 9F 06 53 77 CB C5 95 60 C8 38 69</code> is the 32 bytes long Salsa20 key,<li><code class="language-plaintext highlighter-rouge">0D A4 99 E0 13 12 30 79</code> is a 8 bytes long nonce,<li>next data is the random string printed when the malware was executed on Windows at the beginning.</ul><p>After the encryption is done by the bootloader, key and nonce are erased from disk with 32 successive writings of zeros.<p>Moreover, we can see that sector 35 is used to store the number of total encrypted MFT entries. For example, here is the content of sector 35 right after the MFT header encryption:<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Extended write sectors, drive idx 0x80
  Write 1 sectors at offset 35 (from memory at 0x5C74)
00000000: 01 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  ................
[...]
</code></pre></div></div><h2 id="retrieving-secrets-in-memory">Retrieving secrets in memory</h2><p>One of the advantages of emulation is the ability to easily analyze memory pages. In our case, it is possible to retrieve the Salsa20 key used, even after the MFT table has been encrypted (during the “false chkdsk”, see <a href="#notpetya">NotPetya</a>).<p>In fact, as explained in section <a href="#int-19h">INT 19h</a>; after the encryption is over, the bootloader executes a “soft reboot” with the help of the interruption <code class="language-plaintext highlighter-rouge">INT 19h</code>. It doesn’t reboot completely the computer therefore the BIOS is not executed again. The data present in memory before the “soft reboot” is not tampered with. If the computer goes through hard reboot or reset, there would be great chances for the BIOS to overwrite data present on the stack with its own, including the precious Salsa20 key.<p>So, if the computer has not been rebooted or reset, it is pretty interesting to see if the Salsa20 key is still in memory. To do so, we simply read the key written in sector 32 (see <a href="#yippie-kay-yay-motherfucker-">this section</a>) and store its value. Then, we place a breakpoint on the instructions in charge to show the ransom message, at address <code class="language-plaintext highlighter-rouge">0x85AF</code>:<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">key</span> <span class="o">=</span> <span class="n">HD0</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="mi">32</span><span class="o">*</span><span class="n">SECTOR_LEN</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span> 
<span class="n">jitter</span><span class="p">.</span><span class="n">add_breakpoint</span><span class="p">(</span><span class="mh">0x85AF</span><span class="p">,</span> <span class="n">functools</span><span class="p">.</span><span class="n">partial</span><span class="p">(</span><span class="n">find_key_in_mem</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">))</span>
</code></pre></div></div><p>The <code class="language-plaintext highlighter-rouge">find_key_in_mem</code> function browses the virtual machine memory to find the key stored in the previous step:<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">find_key_in_mem</span><span class="p">(</span><span class="n">jitter</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
    <span class="c1"># Find if the salsa20 key is still in memory!
</span>    <span class="n">mem</span> <span class="o">=</span> <span class="n">jitter</span><span class="p">.</span><span class="n">vm</span><span class="p">.</span><span class="n">get_all_memory</span><span class="p">()</span>
      <span class="k">print</span> <span class="o">&gt;&gt;</span><span class="n">sys</span><span class="p">.</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"</span><span class="se">\n</span><span class="s">[+] Looking for key %s in memory..."</span> <span class="o">%</span> <span class="n">key</span><span class="p">.</span><span class="n">encode</span><span class="p">(</span><span class="s">"hex"</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">addr</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">mem</span><span class="p">.</span><span class="n">iteritems</span><span class="p">():</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="s">'data'</span><span class="p">].</span><span class="n">find</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">print</span> <span class="o">&gt;&gt;</span><span class="n">sys</span><span class="p">.</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"[+] Key found at address %s!"</span> <span class="o">%</span> <span class="nb">hex</span><span class="p">(</span><span class="n">addr</span> <span class="o">+</span> <span class="n">idx</span><span class="p">)</span>
        <span class="k">break</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">print</span> <span class="o">&gt;&gt;</span><span class="n">sys</span><span class="p">.</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"[-] Key not found in memory!"</span>
    <span class="k">return</span> <span class="bp">True</span>
</code></pre></div></div><p>This operation can be activated in the script using <code class="language-plaintext highlighter-rouge">--hook=find_key</code> option, like this:<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ python ./emulate-mbr.py --hook=find_key disk.raw

Repairing file system on C:
[... encryption happends here ...]

[+] Looking for key [your salsa20 key] in memory...
[+] Key found at address 0x674a!
</code></pre></div></div><p>To speed up the process, the <code class="language-plaintext highlighter-rouge">--skip-encryption</code> option can be used (see <a href="#implementation">Implementation</a>). Be careful, even if this option is used, the encryption flag in sector 32 is still set. The flag <code class="language-plaintext highlighter-rouge">--dry</code> prevents this behaviour.<p>Because we know the address where the key is stored (<code class="language-plaintext highlighter-rouge">0x674A</code>), we can put a breakpoint on a write access at this location, allowing us to know which part of the bootloader writes this key:<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">print_ip</span><span class="p">(</span><span class="n">jitter</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="nb">hex</span><span class="p">(</span><span class="n">jitter</span><span class="p">.</span><span class="n">pc</span><span class="p">))</span>
    <span class="k">return</span> <span class="bp">False</span>

<span class="n">jitter</span><span class="p">.</span><span class="n">exceptions_handler</span><span class="p">.</span><span class="n">callbacks</span><span class="p">[</span><span class="n">EXCEPT_BREAKPOINT_MEMORY</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">jitter</span><span class="p">.</span><span class="n">add_exception_handler</span><span class="p">(</span><span class="n">EXCEPT_BREAKPOINT_MEMORY</span><span class="p">,</span> <span class="n">print_ip</span><span class="p">)</span>
<span class="n">jitter</span><span class="p">.</span><span class="n">vm</span><span class="p">.</span><span class="n">add_memory_breakpoint</span><span class="p">(</span><span class="mh">0x674a</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">PAGE_WRITE</span><span class="p">)</span>
</code></pre></div></div><p>Because there is no ASLR or equivalent mechanism, this address will always be the same!<h2 id="bootloader-modification-to-decrypt-the-mft">Bootloader modification to decrypt the MFT</h2><p>If we have a mechanism to write directly into the memory of the machine (for example by using a PCI Express card <sup id="fnref:9" role="doc-noteref"><a href="#fn:9" class="footnote" rel="footnote">8</a></sup>, or other interfaces like FireWire or Thunderbolt <sup id="fnref:10" role="doc-noteref"><a href="#fn:10" class="footnote" rel="footnote">9</a></sup>), it is possible to decrypt the MFT data. The attack consists in patching the bootloader memory so that its uses the remaining key on the stack. This section simulates this attack using Miasm.<p>To do so, we will inject some code at address <code class="language-plaintext highlighter-rouge">0x82A8</code>. This function checks that the key entered is the expected one. Given that it has been erased from the hard drive, and that the ransom text is completely random <sup id="fnref:11" role="doc-noteref"><a href="#fn:11" class="footnote" rel="footnote">10</a></sup>, the bootloader has in theory no way to know if the entered key is the right one. This function will always return 0 (incorrect key). The injected code will copy the key Salsa20 from the <code class="language-plaintext highlighter-rouge">0x674A</code> address to a specific location on the stack, so that the decryption function at <code class="language-plaintext highlighter-rouge">0x835A</code> will use this key. We will then jump on this function.<p>Associated assembly code is the following:<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    ; Save registers on the stack
    PUSHA
    LEA DI, WORD PTR [BP-0x44]
    LEA BX, WORD PTR [key_addr]
    XOR CX,CX

    ; Copy the key that remains on the stack to [bp-0x44]
loop:
    MOV EAX, DWORD PTR [BX]
    MOV DWORD PTR [DI], EAX 
    ADD DI, 4
    ADD BX, 4
    INC CX
    CMP CX,8
    JNZ loop

    ; Restore previously saved registers
    POPA
    ; Jump on the decryption function (CS:OFFSET =&gt; using an absolute address)
    JMP 0000:0x835A
</code></pre></div></div><p>We use Miasm to assemble it using the following function:<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">asm_shellcode</span><span class="p">(</span><span class="n">asm</span><span class="p">,</span> <span class="n">labels</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
    <span class="n">machine</span> <span class="o">=</span> <span class="n">Machine</span><span class="p">(</span><span class="s">"x86_16"</span><span class="p">)</span>
    <span class="n">symbol_pool</span> <span class="o">=</span> <span class="n">asmblock</span><span class="p">.</span><span class="n">AsmSymbolPool</span><span class="p">()</span>

    <span class="c1"># Assemble
</span>    <span class="n">blocks</span><span class="p">,</span> <span class="n">symbol_pool</span> <span class="o">=</span> <span class="n">parse_asm</span><span class="p">.</span><span class="n">parse_txt</span><span class="p">(</span><span class="n">machine</span><span class="p">.</span><span class="n">mn</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="n">asm</span><span class="p">,</span> <span class="n">symbol_pool</span><span class="p">)</span>

    <span class="c1"># Set custom labels
</span>    <span class="k">if</span> <span class="ow">not</span> <span class="n">labels</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span><span class="n">value</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">.</span><span class="n">iteritems</span><span class="p">():</span>
            <span class="n">sym</span> <span class="o">=</span> <span class="n">symbol_pool</span><span class="p">.</span><span class="n">getby_name</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="n">symbol_pool</span><span class="p">.</span><span class="n">set_offset</span><span class="p">(</span><span class="n">sym</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="c1"># Resolve all the labels
</span>    <span class="n">patches</span> <span class="o">=</span> <span class="n">asmblock</span><span class="p">.</span><span class="n">asm_resolve_final</span><span class="p">(</span><span class="n">machine</span><span class="p">.</span><span class="n">mn</span><span class="p">,</span>
                                         <span class="n">blocks</span><span class="p">,</span>
                                         <span class="n">symbol_pool</span><span class="p">)</span>

    <span class="c1"># Patch the final code with the label values
</span>    <span class="n">shellcode</span> <span class="o">=</span> <span class="n">StrPatchwork</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">offset</span><span class="p">,</span> <span class="n">raw</span> <span class="ow">in</span> <span class="n">patches</span><span class="p">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">shellcode</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span> <span class="o">=</span> <span class="n">raw</span>
    <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">shellcode</span><span class="p">)</span>
</code></pre></div></div><p>Let’s take a look at this function. The code is first assembled using an x86 16-bit assembler. Given labels are then associated to concrete values using the <code class="language-plaintext highlighter-rouge">symbol_pool.set_offset</code> function. Remaining labels (in our case <code class="language-plaintext highlighter-rouge">loop</code>) are resolved with the <code class="language-plaintext highlighter-rouge">asmblock.asm_resolve_final</code> function, which returns assembly code for each block. We finally use the <code class="language-plaintext highlighter-rouge">StrPatchwork</code> function to assemble the final “shellcode”.<p>The <code class="language-plaintext highlighter-rouge">read_key_and_patch</code> function loads the key in memory, dumps it and writes the freshly assembled code in memory:<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">read_key_and_patch</span><span class="p">(</span><span class="n">jitter</span><span class="p">):</span>
    <span class="c1"># Key is still in the stack, at 0x674A. You can find this value by activating the
</span>    <span class="c1"># find_key_in_mem breakpoint!
</span>    <span class="n">key_addr</span> <span class="o">=</span> <span class="mh">0x674A</span>
    <span class="n">key</span> <span class="o">=</span> <span class="n">jitter</span><span class="p">.</span><span class="n">vm</span><span class="p">.</span><span class="n">get_mem</span><span class="p">(</span><span class="n">key_addr</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>
    <span class="k">print</span> <span class="o">&gt;&gt;</span><span class="n">sys</span><span class="p">.</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"</span><span class="se">\n</span><span class="s">[+] Key from memory: %s"</span> <span class="o">%</span> <span class="n">key</span><span class="p">.</span><span class="n">encode</span><span class="p">(</span><span class="s">"hex"</span><span class="p">)</span>

    <span class="c1"># Assemble our "shellcode" thanks to Miasm!
</span>    <span class="n">shellcode</span> <span class="o">=</span> <span class="s">"""
...
    """</span>
    <span class="n">shellcode</span> <span class="o">=</span> <span class="n">asm_shellcode</span><span class="p">(</span><span class="n">shellcode</span><span class="p">,</span> <span class="p">{</span><span class="s">"key_addr"</span><span class="p">:</span> <span class="n">key_addr</span><span class="p">})</span>

    <span class="c1"># Patch the bootloader in memory to decrypt using the key
</span>    <span class="n">jitter</span><span class="p">.</span><span class="n">vm</span><span class="p">.</span><span class="n">set_mem</span><span class="p">(</span><span class="mh">0x82A8</span><span class="p">,</span> <span class="n">shellcode</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">True</span>
</code></pre></div></div><p>The remaining thing to do is to put a breakpoint at the same address as in section <a href="#retrieving-secrets-in-memory">Retrieving secrets in memory</a> (<code class="language-plaintext highlighter-rouge">0x85AF</code>) to call this function:<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">jitter</span><span class="p">.</span><span class="n">add_breakpoint</span><span class="p">(</span><span class="mh">0x85AF</span><span class="p">,</span> <span class="n">read_key_and_patch</span><span class="p">)</span>
</code></pre></div></div><p>Everything is now set up. When the bootloader asks for the decryption key, user will just have to press <code class="language-plaintext highlighter-rouge">enter</code>. <code class="language-plaintext highlighter-rouge">--hook=patch_bootloader</code> flag of the <code class="language-plaintext highlighter-rouge">emulate_mbr</code> script performs this attack.<p>It is worth mentioning that <a href="https://airbus-seclab.github.io/ilo/Whitepaper-Defeating_NotPetya_from_your_iLO4-guinet-perigaud-gazet-czarny.pdf">we actually tried this</a> at <a href="https://synacktiv.com">Synacktiv</a>’s headquarters using vulnerabilities in HP’s iLO4 to gather the Salsa20 key from memory, patch the bootloader and decrypt MFT data.<h2 id="encryption-keystream-study">Encryption keystream study</h2><p>The encryption algorithm used is Salsa20 stream cipher. The general principle is: a random data flow based on a key - commonly called the keystream - is generated, and this stream is XORed with the data which will be encrypted. An advantage of stream ciphers is that the data to be encrypted do not need to be padded. On the other hand, one needs to be careful not to use the same parts of this stream twice.<p class="figure"><img src="/assets/2020-08-29-miasm-bootloader/s20-expand.png" alt="" width="400px" class="center-image" /> Data encryption with Salsa20<p>We can verify this using Miasm, by looking at the data before and after encryption, and by showing their XOR difference.<p>In order to do this, we already know how to put breakpoints. The beginning of the encryption function is at address <code class="language-plaintext highlighter-rouge">0x9798</code>, and the end at address <code class="language-plaintext highlighter-rouge">0x9877</code>. We are going to out the first breakpoint just after ‘enter<code class="language-plaintext highlighter-rouge"> instruction, and the second just before </code>leave` statement, in order to have the stack properly aligned to recover data before and after encryption. The associated code is the following:<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">_last_buf</span> <span class="o">=</span> <span class="bp">None</span>
<span class="k">def</span> <span class="nf">encrypt_start</span><span class="p">(</span><span class="n">jitter</span><span class="p">,</span> <span class="n">options</span><span class="p">):</span>
    <span class="k">global</span> <span class="n">_last_buf</span>
    <span class="n">buf_ptr</span>  <span class="o">=</span> <span class="n">upck16</span><span class="p">(</span><span class="n">jitter</span><span class="p">.</span><span class="n">vm</span><span class="p">.</span><span class="n">get_mem</span><span class="p">((</span><span class="n">jitter</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">SS</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="n">jitter</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">BP</span> <span class="o">+</span> <span class="mh">0xC</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">buf_size</span> <span class="o">=</span> <span class="n">upck16</span><span class="p">(</span><span class="n">jitter</span><span class="p">.</span><span class="n">vm</span><span class="p">.</span><span class="n">get_mem</span><span class="p">((</span><span class="n">jitter</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">SS</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="n">jitter</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">BP</span> <span class="o">+</span> <span class="mh">0xE</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">_last_buf</span> <span class="o">=</span> <span class="n">jitter</span><span class="p">.</span><span class="n">vm</span><span class="p">.</span><span class="n">get_mem</span><span class="p">((</span><span class="n">jitter</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">DS</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="n">buf_ptr</span><span class="p">,</span> <span class="n">buf_size</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">True</span>

<span class="k">def</span> <span class="nf">encrypt_end</span><span class="p">(</span><span class="n">jitter</span><span class="p">,</span> <span class="n">options</span><span class="p">):</span>
    <span class="k">global</span> <span class="n">_last_buf</span>
    <span class="n">buf_ptr</span>  <span class="o">=</span> <span class="n">upck16</span><span class="p">(</span><span class="n">jitter</span><span class="p">.</span><span class="n">vm</span><span class="p">.</span><span class="n">get_mem</span><span class="p">((</span><span class="n">jitter</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">SS</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="n">jitter</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">BP</span> <span class="o">+</span> <span class="mh">0xC</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">buf_size</span> <span class="o">=</span> <span class="n">upck16</span><span class="p">(</span><span class="n">jitter</span><span class="p">.</span><span class="n">vm</span><span class="p">.</span><span class="n">get_mem</span><span class="p">((</span><span class="n">jitter</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">SS</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="n">jitter</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">BP</span> <span class="o">+</span> <span class="mh">0xE</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">encr_buf</span> <span class="o">=</span> <span class="n">jitter</span><span class="p">.</span><span class="n">vm</span><span class="p">.</span><span class="n">get_mem</span><span class="p">((</span><span class="n">jitter</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">DS</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="n">buf_ptr</span><span class="p">,</span> <span class="n">buf_size</span><span class="p">)</span>
    <span class="n">keystream</span> <span class="o">=</span> <span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="nb">chr</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">^</span><span class="nb">ord</span><span class="p">(</span><span class="n">b</span><span class="p">))</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">_last_buf</span><span class="p">,</span><span class="n">encr_buf</span><span class="p">)).</span><span class="n">encode</span><span class="p">(</span><span class="s">"hex"</span><span class="p">)</span>
    <span class="n">keystream</span> <span class="o">=</span> <span class="s">' '</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">keystream</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">4</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">keystream</span><span class="p">),</span><span class="mi">4</span><span class="p">))</span>
    <span class="k">print</span> <span class="o">&gt;&gt;</span><span class="n">sys</span><span class="p">.</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Keystream for next 2 sectors: %s"</span> <span class="o">%</span> <span class="n">keystream</span>
    <span class="k">return</span> <span class="bp">True</span>

<span class="n">jitter</span><span class="p">.</span><span class="n">add_breakpoint</span><span class="p">(</span><span class="mh">0x979C</span><span class="p">,</span> <span class="n">functools</span><span class="p">.</span><span class="n">partial</span><span class="p">(</span><span class="n">encrypt_start</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="n">options</span><span class="p">))</span>
<span class="n">jitter</span><span class="p">.</span><span class="n">add_breakpoint</span><span class="p">(</span><span class="mh">0x9876</span><span class="p">,</span> <span class="n">functools</span><span class="p">.</span><span class="n">partial</span><span class="p">(</span><span class="n">encrypt_end</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="n">options</span><span class="p">))</span>
</code></pre></div></div><p>The <code class="language-plaintext highlighter-rouge">--dump-keystream</code> flag of the <code class="language-plaintext highlighter-rouge">emulate_mbr</code> script enables this.<p>By looking at the output, we can see that between two sectors (<code class="language-plaintext highlighter-rouge">2*512</code> bytes), the keystream is only shifted by two bytes, instead of the normally required <code class="language-plaintext highlighter-rouge">2*512</code> bytes. This shift is schematized in the image below:<p><img src="/assets/2020-08-29-miasm-bootloader/keystream.png" alt="" width="400px" class="center-image" /><p>We can also see that on a screenshot of the output of the <code class="language-plaintext highlighter-rouge">emulate_mbr</code> script below:<p class="figure"><img src="/assets/2020-08-29-miasm-bootloader/keystream_screenshot.png" alt="" /> Screenshot of the keystream<p>Thus, parts of the keystream are reused between sectors, which may help to recover some of its original data.<p>Indeed, if we consider <code class="language-plaintext highlighter-rouge">p</code> to be the clear text,<code class="language-plaintext highlighter-rouge"> k</code> the keystream and <code class="language-plaintext highlighter-rouge">c</code> the encrypted text, then the encryption function <code class="language-plaintext highlighter-rouge">E</code> is defined as<code class="language-plaintext highlighter-rouge"> E (p) = p xor k = c</code>. A part of the MFT structures being invariant and known, it is therefore possible, in two sectors, to find part of the keystream used for these two sectors. This one is reused for the two following sectors by being simply shifted by two bytes, so some of the clear text from these other areas can be found.<p>This vulnerability in the Salsa20 implementation of the bootloader has been exploited by <a href="https://www.crowdstrike.com/blog/full-decryption-systems-encrypted-petya-notpetya/">CrowdStrike</a> to recover a large portion of MFT’s original data (between 98.10% and 99.97% depending on the method).<h1 id="conclusion">Conclusion</h1><p>Emulation of the NotPetya bootloader code allows the verification of various assumptions and the understanding, in a very tangible way, of the different steps related to the encryption of MFT entries. In addition, it allows to easily find the bias in the Salsa20 keystream implementation (without having to statically reverse the algorithm), or to simulate the recovery of the key, which remains in memory after the encryption.<p>This article only shows a small subset of Miasm’s possibilities, and we hope that the approach adopted in this article will encourage uninitiated readers to try and play with it :).<h1 id="acknowledgments">Acknowledgments</h1><p>We would like to thank gapz for his initial encouragement. Big thanks also to Camille Mougey and Fabrice Desclaux for their help and thorough reviews of this article! Thanks to Thomas Chauchefoin and zerk for their comments, and to Yseult for her help with the English translation.<h1 id="appendix-application-using-vulnerabilities-in-hp-ilo-4">Appendix: application using vulnerabilities in HP iLO 4</h1><p>With Alexandre Gazet &amp; <a href="https://twitter.com/0xf4b">Fabien Perigaud</a>, we spent some time in <a href="https://synacktiv.com">Synacktiv</a>’s offices to combine the attacks described in this article with <a href="https://github.com/airbus-seclab/ilo4_toolbox">vulnerabilities they found</a> with <a href="https://twitter.com/_Sn0rkY">Joffrey Czarny</a> on HP iLO 4’s management engine. These vulnerabilities allowed us to read and write the memory of an infected server stuck at NotPetya’s bootloader stage, so that we were able to recover the encryption key and patch the bootloader in order to decrypt the MFT.<p>A full write up of the experiment can be read on <a href="https://airbus-seclab.github.io/ilo/Whitepaper-Defeating_NotPetya_from_your_iLO4-guinet-perigaud-gazet-czarny.pdf">Airbus seclab website</a>.<div class="footnotes" role="doc-endnotes"><ol><li id="fn:1" role="doc-endnote"><p><a href="https://fr.wikipedia.org/wiki/Master_File_Table">https://fr.wikipedia.org/wiki/Master_File_Table</a> <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a><li id="fn:2" role="doc-endnote"><p><a href="https://shasaurabh.blogspot.fr/2017/07/debugging-mbr-ida-pro-and-bochs-emulator.html">https://shasaurabh.blogspot.fr/2017/07/debugging-mbr-ida-pro-and-bochs-emulator.html</a> <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a><li id="fn:3" role="doc-endnote"><p><a href="https://www.sstic.org/2012/presentation/miasm_framework_de_reverse_engineering/">https://www.sstic.org/2012/presentation/miasm_framework_de_reverse_engineering/</a> <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a><li id="fn:4" role="doc-endnote"><p><a href="https://fr.wikipedia.org/wiki/Mode_r%C3%A9el">https://fr.wikipedia.org/wiki/Mode_r%C3%A9el</a> <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a><li id="fn:5" role="doc-endnote"><p><a href="https://docs.microsoft.com/en-us/windows/wsl/install-win10">https://docs.microsoft.com/en-us/windows/wsl/install-win10</a> <a href="#fnref:5" class="reversefootnote" role="doc-backlink">&#8617;</a><li id="fn:7" role="doc-endnote"><p><a href="https://wiki.osdev.org/ATA_in_x86_RealMode_(BIOS))">https://wiki.osdev.org/ATA_in_x86_RealMode_(BIOS))</a> <a href="#fnref:7" class="reversefootnote" role="doc-backlink">&#8617;</a><li id="fn:8" role="doc-endnote"><p><a href="http://webpages.charter.net/danrollins/techhelp/0243.HTM">http://webpages.charter.net/danrollins/techhelp/0243.HTM</a> <a href="#fnref:8" class="reversefootnote" role="doc-backlink">&#8617;</a><li id="fn:9" role="doc-endnote"><p><a href="https://www.sstic.org/media/SSTIC2011/SSTIC-actes/attaques_dma_peer-to-peer_et_contremesures/SSTIC2011-Article-attaques_dma_peer-to-peer_et_contremesures-lone-sang_duflot_nicomette_deswarte.pdf">https://www.sstic.org/media/SSTIC2011/SSTIC-actes/attaques_dma_peer-to-peer_et_contremesures/SSTIC2011-Article-attaques_dma_peer-to-peer_et_contremesures-lone-sang_duflot_nicomette_deswarte.pdf</a> <a href="#fnref:9" class="reversefootnote" role="doc-backlink">&#8617;</a><li id="fn:10" role="doc-endnote"><p><a href="https://github.com/carmaa/inception">https://github.com/carmaa/inception</a> <a href="#fnref:10" class="reversefootnote" role="doc-backlink">&#8617;</a><li id="fn:11" role="doc-endnote"><p><a href="https://www.crowdstrike.com/blog/petrwrap-ransomware-technical-analysis-triple-threat-file-encryption-mft-encryption-credential-theft/">https://www.crowdstrike.com/blog/petrwrap-ransomware-technical-analysis-triple-threat-file-encryption-mft-encryption-credential-theft/</a> <a href="#fnref:11" class="reversefootnote" role="doc-backlink">&#8617;</a></ol></div></article><hr class="dingbat related mb6" /><aside class="related mb4" role="complementary"><h2 class="hr-bottom">Related Posts</h2><ul class="related-posts"><li class="h4"> <a href="/blog/2022/01/30/decryption-ch.html" class="flip-title"><span>Breaking decryption.ch: the CTF that wasn't meant to be</span></a> <time class="faded fine" datetime="2022-01-30T00:00:00+01:00">30 Jan 2022</time><li class="h4"> <a href="/blog/2020/11/22/donjon-ctf-sssgx.html" class="flip-title"><span>Donjon CTF SSSGX write-up: linear functions strike back</span></a> <time class="faded fine" datetime="2020-11-22T00:00:00+01:00">22 Nov 2020</time><li class="h4"> <a href="/blog/2020/10/05/dragonffi-library-lifting.html" class="flip-title"><span>Lifting shared libraries & PIE binaries with DragonFFI (and LIEF)</span></a> <time class="faded fine" datetime="2020-10-05T00:00:00+02:00">05 Oct 2020</time></ul></aside><footer class="content" role="contentinfo"><hr/><p><small class="copyright">© 2021. All rights reserved. </small><p><small>Powered by <a class="external" href="https://hydejack.com/">Hydejack</a> v<span id="_version">9.1.4</span></small><hr class="sr-only"/></footer></main><hy-drawer id="_drawer" class="" side="left" threshold="10" noscroll ><header id="_sidebar" class="sidebar" role="banner"><div class="sidebar-bg " style="background-color:rgb(0,0,0);"></div><div class="sidebar-sticky"><nav class="sidebar-nav heading" role="navigation"> <span class="sr-only">Navigation:</span><ul><li> <a id="_drawer--opened" href="/blog/" class="sidebar-nav-item " > Blog </a><li> <a href="/software/" class="sidebar-nav-item " > Software </a><li> <a href="/pubs/" class="sidebar-nav-item " > Publications </a></ul></nav><div class="sidebar-social"> <span class="sr-only">Social</span><ul><li> <a href="https://twitter.com/adriengnt" title="Twitter" class="no-mark-external"> <span class="icon-twitter"></span> <span class="sr-only">Twitter</span> </a><li> <a href="https://github.com/aguinet" title="GitHub" class="no-mark-external"> <span class="icon-github"></span> <span class="sr-only">GitHub</span> </a></ul></div></div></header></hy-drawer><hr class="sr-only" hidden /> </hy-push-state> <!--[if gt IE 10]><!----> <script nomodule>!function(){var t,n=document.createElement("script");!("noModule"in n)&&"onbeforeload"in n&&(t=!1,document.addEventListener("beforeload",function(e){if(e.target===n)t=!0;else if(!e.target.hasAttribute("nomodule")||!t)return;e.preventDefault()},!0),n.type="module",n.src=".",document.head.appendChild(n),n.remove())}(); </script> <script src="/assets/js/hydejack-9.1.4.js" type="module"></script> <script src="/assets/js/LEGACY-hydejack-9.1.4.js" nomodule defer></script> <!--<![endif]--><div hidden><h2 class="sr-only">Templates:</h2><clap-config> <clap-text at="1">Keep going!</clap-text> <clap-text at="2">Keep going ×2!</clap-text> <clap-text at="3">Give me more!</clap-text> <clap-text at="5">Thank you, thank you</clap-text> <clap-text at="7">Far too kind!</clap-text> <clap-text at="10">Never gonna give me up?</clap-text> <clap-text at="14">Never gonna let me down?</clap-text> <clap-text at="20">Turn around and desert me!</clap-text> <clap-text at="30">You're an addict!</clap-text> <clap-text at="40">Son of a clapper!</clap-text> <clap-text at="50">No way</clap-text> <clap-text at="60">Go back to work!</clap-text> <clap-text at="70">This is getting out of <em>hand</em></clap-text> <clap-text at="80">Unbelievable</clap-text> <clap-text at="90">PREPOSTEROUS</clap-text> <clap-text at="100">I N S A N I T Y</clap-text> <clap-text at="185"><span style="font-family:monospace">FEED ME A STRAY CAT</span></clap-text> </clap-config> <template id="_animation-template"><div class="animation-main fixed-top"><nav id="breadcrumbs" class="screen-only"><ul></ul></nav><div class="content"><div class="page"></div></div></div></template> <template id="_loading-template"><div class="loading nav-btn fr"> <span class="sr-only">Loading…</span> <span class="icon-cog"></span></div></template> <template id="_error-template"><div class="page"><h1 class="page-title">Error</h1><p class="lead"> Sorry, an error occurred while loading: <a class="this-link" href=""></a>.</div></template> <template id="_permalink-template"> <a href="#" class="permalink"> <span class="sr-only">Permalink</span> <span class="content-hash"></span> </a> </template></div></html>
