<!DOCTYPE html>
<html lang="en"><!--
 __  __                __                                     __
/\ \/\ \              /\ \             __                    /\ \
\ \ \_\ \   __  __    \_\ \      __   /\_\      __       ___ \ \ \/'\
 \ \  _  \ /\ \/\ \   /'_` \   /'__`\ \/\ \   /'__`\    /'___\\ \ , <
  \ \ \ \ \\ \ \_\ \ /\ \L\ \ /\  __/  \ \ \ /\ \L\.\_ /\ \__/ \ \ \\`\
   \ \_\ \_\\/`____ \\ \___,_\\ \____\ _\ \ \\ \__/.\_\\ \____\ \ \_\ \_\
    \/_/\/_/ `/___/> \\/__,_ / \/____//\ \_\ \\/__/\/_/ \/____/  \/_/\/_/
                /\___/                \ \____/
                \/__/                  \/___/

Powered by Hydejack v9.0.4 <https://hydejack.com/>
-->
















<head>
  






  
    

<title>Emulating NotPetya bootloader with Miasm |</title>
<meta name="description" content="NotPetya is a famous malware of the Petya family. It appeared in June 2017.
The part running from the Master Boot Record (MBR) has been statically and
dynamically studied, using for instance the Bochs debugger from IDA. Is
another approach possible? This article’s goal is to show that we can emulate
this bootloader using Miasm.
">
<link rel="canonical" href="https://aguinet.github.io//blog/2020/08/29/miasm-bootloader.html">

  

  

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta http-equiv="x-ua-compatible" content="ie=edge">

<meta name="mobile-web-app-capable" content="yes">

<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-title" content="">
<meta name="apple-mobile-web-app-status-bar-style" content="default">

<meta name="application-name" content="">


  <meta name="theme-color" content="rgb(0,0,0)">


<meta name="generator" content="Hydejack v9.0.4" />


<link rel="alternate" href="https://aguinet.github.io//blog/2020/08/29/miasm-bootloader.html" hreflang="en">

<link type="application/atom+xml" rel="alternate" href="https://aguinet.github.io//feed.xml" title="" />


<link rel="shortcut icon"    href="/assets/icons/favicon.ico">
<link rel="apple-touch-icon" href="/assets/icons/icon-192x192.png">

<link rel="manifest" href="/assets/site.webmanifest">


  <link rel="dns-prefetch" href="https://fonts.googleapis.com">
  <link rel="dns-prefetch" href="https://fonts.gstatic.com">




<link rel="preload" href="/assets/img/swipe.svg" as="image" id="_hrefSwipeSVG">






<script>!function(e,t){"use strict";function n(e,t,n,o){e.addEventListener?e.addEventListener(t,n,o):e.attachEvent?e.attachEvent("on"+t,n):e["on"+t]=n}e.loadJS=function(e,o){var r=t.createElement("script");r.src=e,o&&n(r,"load",o,{once:!0});var a=t.scripts[0];return a.parentNode.insertBefore(r,a),r},e._loaded=!1,e.loadJSDeferred=function(o,r){function a(){e._loaded=!0,r&&n(c,"load",r,{once:!0});var o=t.scripts[0];o.parentNode.insertBefore(c,o)}var c=t.createElement("script");return c.src=o,e._loaded?a():n(e,"load",a,{once:!0}),c},e.setRel=e.setRelStylesheet=function(e){function o(){this.rel="stylesheet"}n(t.getElementById(e),"load",o,{once:!0})}}(window,document);
!function(a){"use strict";var b=function(b,c,d){function e(a){return h.body?a():void setTimeout(function(){e(a)})}function f(){i.addEventListener&&i.removeEventListener("load",f),i.media=d||"all"}var g,h=a.document,i=h.createElement("link");if(c)g=c;else{var j=(h.body||h.getElementsByTagName("head")[0]).childNodes;g=j[j.length-1]}var k=h.styleSheets;i.rel="stylesheet",i.href=b,i.media="only x",e(function(){g.parentNode.insertBefore(i,c?g:g.nextSibling)});var l=function(a){for(var b=i.href,c=k.length;c--;)if(k[c].href===b)return a();setTimeout(function(){l(a)})};return i.addEventListener&&i.addEventListener("load",f),i.onloadcssdefined=l,l(f),i};"undefined"!=typeof exports?exports.loadCSS=b:a.loadCSS=b}("undefined"!=typeof global?global:this);
!function(a){if(a.loadCSS){var b=loadCSS.relpreload={};if(b.support=function(){try{return a.document.createElement("link").relList.supports("preload")}catch(b){return!1}},b.poly=function(){for(var b=a.document.getElementsByTagName("link"),c=0;c<b.length;c++){var d=b[c];"preload"===d.rel&&"style"===d.getAttribute("as")&&(a.loadCSS(d.href,d,d.getAttribute("media")),d.rel=null)}},!b.support()){b.poly();var c=a.setInterval(b.poly,300);a.addEventListener&&a.addEventListener("load",function(){b.poly(),a.clearInterval(c)}),a.attachEvent&&a.attachEvent("onload",function(){a.clearInterval(c)})}}}(this);
!function(w) {
  w._baseURL = '/';
  w._publicPath = '/assets/js/';
  w._noPushState = false;
  w._noDrawer = true;
  w._noNavbar = true;
  w._noToc = false;
  w._noSearch = true;
}(window);
</script>


<script async src="/assets/bower_components/MathJax/es5/tex-mml-chtml.js" id="_MathJax"></script>


<!--[if gt IE 8]><!---->

  




<link rel="stylesheet" href="/assets/css/hydejack-9.0.4.css" id="_stylePreload">
<link rel="stylesheet" href="/assets/icomoon/style.css" id="_iconsPreload">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto+Slab:700%7CNoto+Sans:400,400i,700,700i&display=swap" id="_fontsPreload">



  <style id="_pageStyle">

html{--accent-color: rgb(0,0,0);--accent-color-faded: rgba(0,0,0,0.5);--accent-color-darkened: #000;--theme-color: rgb(0,0,0)}

</style>


<!--<![endif]-->





</head>

<body class="no-drawer">
  


<hy-push-state
  id="_pushState"
  replace-selector="#_main"
  link-selector="a[href]:not([href^='/assets/']):not(.external):not(.no-push-state)"
  script-selector="script"
  duration="500"
  hashchange
>
  
  
  <main
  id="_main"
  class="content layout-post"
  role="main"
>
  





<article id="post-blog-2020-08-29-miasm-bootloader" class="page post mb6" role="article">
  <header>
    <h1 class="post-title flip-project-title">
      
        Emulating NotPetya bootloader with Miasm
      
    </h1>

    <div class="post-date">
      
      <time datetime="2020-08-29T00:00:00+02:00">29 Aug 2020</time>
      
      
      
      
      









in <span>Blog</span>

      











    </div>

    
    

    



  <div class="hr pb0"></div>


  </header>

  
    <p>NotPetya is a famous malware of the Petya family. It appeared in June 2017.
The part running from the Master Boot Record (MBR) has been statically and
dynamically studied, using for instance the Bochs debugger from IDA. Is
another approach possible? This article’s goal is to show that we can emulate
this bootloader using Miasm.</p>

<p><em>This article has been written by <a href="https://twitter.com/la_F0uin3">Jordan Bouyat
(@la_F0uin3)</a> and <a href="https://twitter.com/adriengnt">Adrien Guinet
(@adriengnt)</a>. It has originally been published
in the <a href="https://connect.ed-diamond.com/MISC/MISC-098/Emulation-du-bootloader-de-NotPetya-avec-Miasm">MISC magazine n°98</a> in French. This is a slightly updated and
English translation of this article.</em></p>

<h1 id="introduction">Introduction</h1>

<p>This Petya variant first appeared in June 2017 in Ukraine. According to Mikko
Hyppönen, Chief Research Officer at F-Secure, the infection vector would be
the update mechanism of the accountability software M.E.Doc, widely deployed
within Eastern countries.</p>

<p>This malware family has the particularity of overwriting the bootloader of the
compromised machine in order to encrypt parts of the hard drive when it reboots.
This article uses this bootloader as a pretext for a tutorial concerning the emulation
and reverse engineering of these little beasts thanks to the Miasm
framework. The associated code is available here:
<a href="https://github.com/aguinet/miasm-bootloader/">https://github.com/aguinet/miasm-bootloader/</a>. It contains a Python
implementation of a subset of the interfaces of a classic x86 PC BIOS. The code
was written in a way that is easily reusable for other cases, or even to
help the development / debugging of bootloaders in general.</p>

<h2 id="related-works">Related works</h2>

<p>Many articles have already studied the behaviour of the NotPetya MBR, as
well as its various cryptographic implementations and mechanisms (and their
faults). Here are some significant ones:</p>

<ul>
  <li>MISC n°86 : “Pleased to meet you, my name is Petya !”, written by Damien Schaeffer in July 2016</li>
  <li>MISC n°93 : “Petya or Not Petya, that is the question”, written by “Teddy and
Benjamin” in September 2017, with a very thorough static reverse
engineering of the bootloader.</li>
  <li>Crowdstrike : <a href="https://www.crowdstrike.com/blog/full-decryption-systems-encrypted-petya-notpetya/">Full Decryption of Systems Encrypted by Petya/NotPetya</a>. Study of an implementation error within the
Salsa20 algorithm embedded in the bootloader (more on that subject later in the article).</li>
</ul>

<h2 id="notpetya">NotPetya</h2>

<p>This section deals only in a very general way with the malware’s cycle of life. It allows us to highlight the part studied in this article.</p>

<p>Once NotPetya has run on the victim’s machine, it generates an AES encryption key
that will be used to achieve the first encryption phase. This key is itself
encrypted with an RSA public key.</p>

<p>The malware then checks that the system uses a classical partition scheme and,
if it has admin rights, enters its own data on the first sectors of the disc
(from 1 to 18, then 32 to 34), with its own MBR in the first sector. If the
system uses UEFI (with a GPT partition scheme), the malware skips this step.
The machine then is restarted and the NotPetya bootloader executed: a Salsa20
key and a nonce are generated. These secrets are used to encrypt the Master
File Table (MFT) <sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote">1</a></sup> of NTFS file system. This data structure contains the metadata
needed to find the data associated with each file. This operation looks like a
classical “chkdsk”. Once this operation is done, the machine restarts one last
time and then displays the ransom message.</p>

<h2 id="miasm">Miasm</h2>

<p>Miasm is a reverse engineering framework developed in Python. It has many
features, among which:</p>

<ul>
  <li>open, modify and generate binaries in PE, ELF 32, 64 LE, BE.</li>
  <li>assemble/disassemble x86, ARM, MIPS, SH4, PPC and MSP430 code.</li>
  <li>lift instruction semantics into a custom intermediate representation.</li>
  <li>emulate this intermediate representation, with various JIT (Just-in-time)
compilers to speed things up.</li>
  <li>simplify/modify this intermediate representation, to de-obfuscate code for instance.</li>
</ul>

<h2 id="why-emulate-notpetya-with-miasm">Why emulate NotPetya with Miasm?</h2>

<p><img src="/assets/2020-08-29-miasm-bootloader/crazy.gif" alt="" class="center-image" /></p>

<p>There are various ways to emulate a bootloader. A classical approach is to use
QEMU (or any other virtualization/emulation solution) by writing the bootloader
on a virtual hard disk, but it makes it difficult to instrument the bootloader
code.  Such a thing is however possible via IDA’s Bochs debugger. This approach
was adopted by Teddy and Benjamin in MISC No. 93, but also by Saurabh Sharma
<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote">2</a></sup>. This method usually works well and makes debugging a bootloader an
easy task.</p>

<p>In the article associated with the presentation of his Miasm tool at SSTIC in
2012 <sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote">3</a></sup>, Fabrice Desclaux showed Miasm possibilities. One of the proposed
applications was the emulation of a bootloader.</p>

<p>The ability to fully emulate a bootloader (until the BIOS interruption) with a framework like Miasm gives a sharper control over what’s
happening, possibly allow de-obfuscation, and use all the tools developed in
Miasm for this task.  It becomes for example very simple to instrument the code
in order to see the data read/written on the disk, the secrets generated,
etc.</p>

<p>Eventually, NotPetya’s bootloader code is succinct, non-obfuscated and extremely
simple (it runs in real mode, in 16 bits and calls only a few BIOS
interruptions), so it is a nice case study to play with Miasm!</p>

<h1 id="pcx86-bootloader">PC/x86 bootloader</h1>

<h2 id="introduction-1">Introduction</h2>

<p>We will only discuss here the inner workings of “old-school” BIOS bootloaders.  We
will not talk about UEFI.</p>

<p>On x86 PCs, when the machine starts, the BIOS loads the first disk sector
(named Master Boot Record, or MBR) at <code class="language-plaintext highlighter-rouge">0x7C00</code>, and then jumps to this address.
The MBR hence contains the bootloader code. At this moment, the
processor only supports 16-bit instructions and can only address memory in real
mode <sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote">4</a></sup>.</p>

<p>As a reminder, one disk sector contains 512 bytes. Therefore,
it is not possible to store a lot of code on this sector only. That’s
why bootloaders are usually designed in several stages. Indeed, the code in
the first sector (the first stage) will load the stage 2 code from the hard drive ,
and then jump into it.</p>

<p>Below is the MBR’s structure written by NotPetya:</p>

<p><a name="fig:notpetya_mbr"></a>
<img src="/assets/2020-08-29-miasm-bootloader/mbr-structure.png" alt="" width="500px" class="center-image" /></p>

<h2 id="notpetya-case">NotPetya case</h2>

<p>NotPetya works exactly this way. The bootstrap code (in green in the <a href="#fig:notpetya_mbr">figure
above</a>) is the assembly code below. The code at address
<code class="language-plaintext highlighter-rouge">0x7C38</code> (that we named <code class="language-plaintext highlighter-rouge">disk_read_stage2</code>), writes data in sectors 2 to 34
(inclusive) in memory at <code class="language-plaintext highlighter-rouge">0x8000</code>, and then jumps to this address:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>seg000:7C00 cli
seg000:7C01 xor ax, ax
seg000:7C03 mov ds, ax
seg000:7C05 mov ss, ax
seg000:7C07 mov es, ax
seg000:7C09 lea sp, start
seg000:7C0D sti
seg000:7C0E mov eax, 32
seg000:7C14 mov byte ptr ds:word_7C93, dl
seg000:7C18 mov ebx, 1
seg000:7C1E mov cx, 8000h
seg000:7C21 call disk_read_stage2
seg000:7C24 dec eax
seg000:7C26 cmp eax, 0
seg000:7C2A jnz short loc_7C21
seg000:7C2C mov eax, dword ptr ds:8000h
seg000:7C30 jmp far ptr 0:8000h
</code></pre></div></div>

<h1 id="emulation-with-miasm">Emulation with Miasm</h1>

<h2 id="installation">Installation</h2>

<p>The system used for these tests is Linux-based. Windows 10 users
should be able to make it work by using Windows Subsystem for Linux
(WSL), by installing for example Ubuntu using the
Windows Store <sup id="fnref:5" role="doc-noteref"><a href="#fn:5" class="footnote">5</a></sup>.</p>

<p>We recommend using the version of Miasm specified in the
<code class="language-plaintext highlighter-rouge">README</code> file from the GitHub repository. At the time of writing
lines, the version used is v0.1.1. To recover this
specific version, do:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git clone --depth=1 --branch=v0.1.1 https://github.com/cea-sec/miasm/
</code></pre></div></div>

<p>We use the LLVM-based Miasm JIT engine, which needs the <code class="language-plaintext highlighter-rouge">llvmlite</code> python
package. Other needed dependencies are installable directly through the
provided <code class="language-plaintext highlighter-rouge">requirements.txt</code> file:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ cd /path/to/src &amp;&amp; pip install -r requirements.txt
</code></pre></div></div>

<p>Then just install Miasm:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ cd /path/to/miasm &amp;&amp; pip install -r requirements.txt &amp;&amp; python ./setup.py install
</code></pre></div></div>

<h2 id="implementation">Implementation</h2>

<p>All the techniques described in this article can be tried thanks to the
<code class="language-plaintext highlighter-rouge">src/emulate_mbr.py</code> script in the aforementioned GitHub repository.</p>

<p>Multiple options are provided, some of them could be used to win some time
during your experiments:</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">--dry</code>: simulates the success of disk writings, but actually writes nothing.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">--skip-encryption</code>: the encryption function (which is the hottest one) will
be ignored (actually transforming it into a function that does nothing).</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">--verbose-bios-data</code>: dumps log messages from our BIOS implementation, with
a dump of read and written disk data.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">--verbose-bios</code>: same as <code class="language-plaintext highlighter-rouge">--verbose-bios-data</code>, without the read and written
disk data.</p>
  </li>
</ul>

<p>The <code class="language-plaintext highlighter-rouge">--help</code> flag can be used to have a more detailed list of available options.</p>

<p>The activation of Miasm’s logs can considerably slow down the performances of the
overall script. The <code class="language-plaintext highlighter-rouge">--log-miasm-newblocks</code> option only dumps blocks that have
never been “jitted” by Miasm.</p>

<h2 id="creation-of-a-test-disk">Creation of a test disk</h2>

<p>We performed our tests with virtual machines running Windows
XP and Windows 10. The underlying hypervisor does not matter (VMWare,
VirtualBox), as long as the disk created has a fixed size and is using
VMDK. The emulation of the bootloader is done directly on the virtual machine’s disk. An advantage to this method is that there is
no need to extract the bootloader from the original malware DLL or
from the generated VMDK.</p>

<p class="figure"><img src="/assets/2020-08-29-miasm-bootloader/setup.png" alt="" width="400px" class="center-image" />
Emulation scenario</p>

<p>The test scenario is the following:</p>

<ol>
  <li>voluntary infection of the virtual machine with NotPetya</li>
  <li>wait for at least 10s (the machine shouldn’t reboot by itself, or the
bootloader will actually launch its encryption code)</li>
  <li>shutdown the virtual machine: the MBR has been replaced</li>
  <li>run the emulation: the MFT is encrypted by the bootloader which then displays the ransom</li>
</ol>

<p>If your virtual machine is not using a flat VMDK representation, you can convert
it using QEMU:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ qemu-img convert -f vmdk mydisk.vmdk -O raw mydisk.raw
</code></pre></div></div>

<p>We also give a test image in the aforementioned Git repository (file
<code class="language-plaintext highlighter-rouge">disk.raw.bz2</code>). Once unzipped, it is a 1GB file, and contains a simple NTFS
partition with some test files.</p>

<p>We can now emulate the NotPetya bootloader. In order to do this, we need to
emulate a BIOS capable of:</p>

<ul>
  <li>reading/writing disk sectors</li>
  <li>showing characters on the screen</li>
  <li>capturing key strokes</li>
  <li>booting on an MBR (“light” boot/reboot)</li>
</ul>

<p>We are going to see how to implement this using Miasm.</p>

<h2 id="system-abstraction">System abstraction</h2>

<p>We implement an abstraction of a simple system as seen by the BIOS. It
contains:</p>

<ul>
  <li>a virtual disk (the <code class="language-plaintext highlighter-rouge">HardDrive</code> class)</li>
  <li>a video screen, which goes through a classical Unix terminal, using the <code class="language-plaintext highlighter-rouge">stdout</code> pipe</li>
  <li>a keyboard, which uses the <code class="language-plaintext highlighter-rouge">stdin</code> pipe to gather key strokes (functions in <code class="language-plaintext highlighter-rouge">async_kb.py</code>)</li>
</ul>

<p>Abstraction is implemented in the <code class="language-plaintext highlighter-rouge">System</code> class, of which one instance is used during the emulation. This instance is initialized alongside the Miasm
VM.</p>

<h2 id="miasm-virtual-machine-initialization">Miasm virtual machine initialization</h2>

<p>As explained in the introduction, the MBR code is loaded and executed by the
BIOS at the address <code class="language-plaintext highlighter-rouge">0x7C00</code>. Then, this code will load and write its second stage
at the address <code class="language-plaintext highlighter-rouge">0x8000</code>. The left space is dedicated to the stack. It begins at
the address <code class="language-plaintext highlighter-rouge">0x500</code> and ends at the address <code class="language-plaintext highlighter-rouge">0x07C00</code>. Therefore, the corresponding
space is <code class="language-plaintext highlighter-rouge">[0x00000500:0x00007BFF]</code>.</p>

<p>First, we need to declare these memory spaces to the Miasm virtual machine:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">HD0</span> <span class="o">=</span> <span class="n">HardDrive</span><span class="p">(</span><span class="n">hd_path</span><span class="p">)</span>
<span class="n">sys_</span> <span class="o">=</span> <span class="n">System</span><span class="p">([</span><span class="n">HD0</span><span class="p">])</span>
<span class="n">mbr</span> <span class="o">=</span> <span class="n">HD0</span><span class="p">.</span><span class="n">read_sector</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">stage1_addr</span> <span class="o">=</span> <span class="mh">0x07C00</span>
<span class="n">stage2_addr</span> <span class="o">=</span> <span class="mh">0x08000</span>
<span class="n">jitter</span><span class="p">.</span><span class="n">vm</span><span class="p">.</span><span class="n">add_memory_page</span><span class="p">(</span><span class="n">stage1_addr</span><span class="p">,</span> <span class="n">PAGE_READ</span> <span class="o">|</span> <span class="n">PAGE_WRITE</span> <span class="o">|</span> <span class="n">PAGE_EXEC</span><span class="p">,</span> <span class="n">mbr</span><span class="p">,</span> <span class="s">"NotPetyaS1"</span><span class="p">)</span>
<span class="n">jitter</span><span class="p">.</span><span class="n">vm</span><span class="p">.</span><span class="n">add_memory_page</span><span class="p">(</span><span class="n">stage2_addr</span><span class="p">,</span> <span class="n">PAGE_READ</span> <span class="o">|</span> <span class="n">PAGE_WRITE</span> <span class="o">|</span> <span class="n">PAGE_EXEC</span><span class="p">,</span> <span class="s">"</span><span class="se">\x00</span><span class="s">"</span><span class="o">*</span><span class="n">SECTOR_LEN</span><span class="o">*</span><span class="mi">32</span><span class="p">,</span> <span class="s">"NotPetyaS2"</span><span class="p">)</span>
<span class="n">jitter</span><span class="p">.</span><span class="n">vm</span><span class="p">.</span><span class="n">add_memory_page</span><span class="p">(</span><span class="mh">0x500</span><span class="p">,</span> <span class="n">PAGE_READ</span> <span class="o">|</span> <span class="n">PAGE_WRITE</span><span class="p">,</span> <span class="s">"</span><span class="se">\x00</span><span class="s">"</span><span class="o">*</span><span class="p">(</span><span class="mh">0x7C00</span><span class="o">-</span><span class="mh">0x500</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="s">"Stack"</span><span class="p">)</span>
<span class="c1"># Pretty print of the memory layout
</span><span class="k">print</span><span class="p">(</span><span class="n">jitter</span><span class="p">.</span><span class="n">vm</span><span class="p">)</span>
</code></pre></div></div>

<p>Now, the memory layout of the Miasm virtual machine is the following:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Addr               Size               Access Comment 
0x500              0x7700             RW_    Stack 
0x7C00             0x200              RWX    NotPetyaS1 
0x8000             0x4000             RWX    NotPetyaS2
</code></pre></div></div>

<p>NotPetya loads 32 sectors from the disk to the memory when executing the first stage.
This is why the allocated memory for the second stage is 32 sectors long (32*512 bytes).</p>

<h2 id="bios-interruption-handling-in-miasm">BIOS interruption handling in Miasm</h2>

<p>Miasm allows us to specify an interruption handler which will be called
whenever an <code class="language-plaintext highlighter-rouge">INT</code> instruction is executed. To do so, we have to tell Miasm to
call our BIOS interruption handler <code class="language-plaintext highlighter-rouge">exception_int</code> with the help of
<code class="language-plaintext highlighter-rouge">add_exception_handler</code> of the current used jitter:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">jitter</span><span class="p">.</span><span class="n">add_exception_handler</span><span class="p">(</span><span class="n">EXCEPT_INT_XX</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">jitter</span><span class="p">:</span> <span class="n">exception_int</span><span class="p">(</span><span class="n">jitter</span><span class="p">,</span> <span class="n">sys_</span><span class="p">))</span>
</code></pre></div></div>

<h2 id="interruption-support">Interruption support</h2>

<p>Now, we have to implement the different BIOS interruption handlers. We can split them into four main families :</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">INT 10h</code> : access to the screen (write characters, change colors…),</li>
  <li><code class="language-plaintext highlighter-rouge">INT 13h</code> : access to the disk (read/write sectors, get disk geometry…),</li>
  <li><code class="language-plaintext highlighter-rouge">INT 16h</code> : access to the keyboard (read keystroke…),</li>
  <li><code class="language-plaintext highlighter-rouge">INT 19h</code> : boot on the disk’s MBR.</li>
</ul>

<h3 id="int-13h">INT 13h</h3>

<p>Here is an example of the <code class="language-plaintext highlighter-rouge">INT 13h</code> interruption, with the <code class="language-plaintext highlighter-rouge">0x43</code> code function
(<code class="language-plaintext highlighter-rouge">Extended Read Sectors From Drive</code>). This code implements the instruction to load
multiple sectors from the disk to the memory:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">@</span><span class="n">func</span><span class="p">(</span><span class="n">disk_interrupts</span><span class="p">,</span> <span class="mh">0x42</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">extended_read_sectors</span><span class="p">(</span><span class="n">jitter</span><span class="p">,</span> <span class="n">sys_</span><span class="p">):</span>
    <span class="n">drive_idx</span> <span class="o">=</span> <span class="n">get_xl</span><span class="p">(</span><span class="n">jitter</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">DX</span><span class="p">)</span>
    <span class="k">print</span> <span class="s">"Extended read sectors, drive idx 0x%x"</span> <span class="o">%</span> <span class="n">drive_idx</span>

    <span class="n">dap</span> <span class="o">=</span> <span class="n">jitter</span><span class="p">.</span><span class="n">vm</span><span class="p">.</span><span class="n">get_mem</span><span class="p">((</span><span class="n">jitter</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">DS</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span><span class="o">+</span><span class="n">jitter</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">SI</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>
    <span class="n">dap_size</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">num_sect</span><span class="p">,</span> <span class="n">buff_addr</span><span class="p">,</span> <span class="n">abs_sect</span> <span class="o">=</span> <span class="n">struct</span><span class="p">.</span><span class="n">unpack</span><span class="p">(</span><span class="s">"&lt;BBHIQ"</span><span class="p">,</span> <span class="n">dap</span><span class="p">)</span>

    <span class="n">hd</span> <span class="o">=</span> <span class="n">sys_</span><span class="p">.</span><span class="n">hd</span><span class="p">(</span><span class="n">drive_idx</span><span class="p">)</span>

    <span class="k">print</span><span class="p">(</span><span class="s">"  Read %d sectors from sector %d"</span> <span class="o">%</span> <span class="p">(</span><span class="n">num_sect</span><span class="p">,</span> <span class="n">abs_sect</span><span class="p">))</span>
    <span class="n">size</span> <span class="o">=</span> <span class="n">num_sect</span> <span class="o">*</span> <span class="n">SECTOR_LEN</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">hd</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="n">abs_sect</span> <span class="o">*</span> <span class="n">SECTOR_LEN</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>

    <span class="n">jitter</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">cf</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># No error
</span>    <span class="c1"># AL is the number of sectors read
</span>    <span class="c1"># AH is the return code, 0 = successful completion 
</span>    <span class="n">jitter</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">AX</span> <span class="o">=</span> <span class="n">set_16bit_reg</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">/</span> <span class="n">SECTOR_LEN</span><span class="p">),</span> <span class="n">high</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">jitter</span><span class="p">.</span><span class="n">vm</span><span class="p">.</span><span class="n">set_mem</span><span class="p">(</span><span class="n">buff_addr</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
</code></pre></div></div>

<p>Note: this Python code doesn’t include error management for readability
reasons. The <code class="language-plaintext highlighter-rouge">sys_</code> object is the system abstraction explained in
<a href="#system-abstraction">System abstraction</a>.</p>

<p>Sectors can be loaded from disk in two different ways by using a different kind of
addressing mechanism for the same <code class="language-plaintext highlighter-rouge">INT 13h</code> interruption:</p>

<ol>
  <li>
    <p>CHS (Cylinder, Head, Sector) addressing mechanism, used by the <code class="language-plaintext highlighter-rouge">02h</code>/<code class="language-plaintext highlighter-rouge">03h</code>
codes. It can read/write one or many sectors by specifying the index of the
cylinder and the head,</p>
  </li>
  <li>
    <p>LBA (Logical Bloc Addressing) addressing mechanism, used by the <code class="language-plaintext highlighter-rouge">42h</code>/<code class="language-plaintext highlighter-rouge">43h</code>
codes. It can read/write one or several sectors by specifying the corresponding
sector in a absolute way, i.e. by specifying the offset from the
first sector number on the disk regardless of heads/cylinders.</p>
  </li>
</ol>

<p>NotPetya uses the LBA addressing mechanism. This method needs to fill a DAP
(Disk Address Packet) structure. This structure describes which sectors to
read/write and where to read/write them into live memory.</p>

<p>One can see that an extended LBA structure exists to read or write multiple
sectors at the same time:</p>

<table>
  <tbody>
    <tr>
      <td>0</td>
      <td>1</td>
      <td>Packet size</td>
    </tr>
    <tr>
      <td>1</td>
      <td>1</td>
      <td>Zeroed field</td>
    </tr>
    <tr>
      <td>2</td>
      <td>2</td>
      <td>Number of sectors to load</td>
    </tr>
    <tr>
      <td>4</td>
      <td>4</td>
      <td>Buffer address to load sectors to (seg:off)</td>
    </tr>
    <tr>
      <td>8</td>
      <td>8</td>
      <td>Absolute offset of the first sector to read</td>
    </tr>
  </tbody>
</table>

<p>To sum up:</p>

<ol>
  <li>the DAP is parsed,</li>
  <li>data is read from the virtual disk,</li>
  <li>the read data is stored in the corresponding memory page of the
instantiated Miasm virtual machine.</li>
</ol>

<p>The writing mechanism is the exact opposite: the specified buffer address in the
DAP contains the data to write.</p>

<h3 id="int-19h">INT 19h</h3>

<p>The second chosen example is the <code class="language-plaintext highlighter-rouge">INT 19h</code> interruption (diskboot). It
reboots the machine <sup id="fnref:7" role="doc-noteref"><a href="#fn:7" class="footnote">6</a></sup><sup id="fnref:8" role="doc-noteref"><a href="#fn:8" class="footnote">7</a></sup> and is used in two locations :</p>

<ol>
  <li>at address <code class="language-plaintext highlighter-rouge">0x892E</code>, which is called if a fatal error occurs,</li>
  <li>at address <code class="language-plaintext highlighter-rouge">0x820D</code>, when the machine reboots after the MFT encryption.</li>
</ol>

<p>The <code class="language-plaintext highlighter-rouge">INT 19h</code> interruption is called right after the POST (Power On Self Test)
procedure by the BIOS. After that, the MBR code is loaded into live memory at
<code class="language-plaintext highlighter-rouge">Ox7C00</code>. Then, the BIOS jumps at this address.</p>

<p>So we can say here that it is used as a sort of <em>soft reboot</em> because the reboot is
not a complete one. This instruction is part of the boot process after BIOS execution. Some BIOS can handle boot medium priority while others
just loop over available mediums and boot on the first one it can.</p>

<p>Here, we will emulate this instruction simply by loading again the MBR code
into the memory page dedicated to it (stage 1), and then jump onto it (at 
address <code class="language-plaintext highlighter-rouge">0x7C00</code>):</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">diskboot_interrupts</span> <span class="o">=</span> <span class="n">FuncTable</span><span class="p">(</span><span class="s">"INT 19h (diskboot)"</span><span class="p">)</span>
<span class="o">@</span><span class="n">func</span><span class="p">(</span><span class="n">diskboot_interrupts</span><span class="p">,</span> <span class="mh">0x02</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">reboot</span><span class="p">(</span><span class="n">jitter</span><span class="p">,</span> <span class="n">sys_</span><span class="p">):</span>
    <span class="c1"># Here, we assume only one bootable disk (index 0)
</span>    <span class="n">hd</span> <span class="o">=</span> <span class="n">sys_</span><span class="p">.</span><span class="n">hd</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">mbr</span> <span class="o">=</span> <span class="n">hd</span><span class="p">.</span><span class="n">read_sector</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">jitter</span><span class="p">.</span><span class="n">vm</span><span class="p">.</span><span class="n">set_mem</span><span class="p">(</span><span class="mh">0x7C00</span><span class="p">,</span> <span class="n">mbr</span><span class="p">)</span>
    <span class="n">jitter</span><span class="p">.</span><span class="n">pc</span> <span class="o">=</span> <span class="mh">0x7C00</span>
</code></pre></div></div>

<h2 id="for-a-few-more-hacks">For a few more hacks…</h2>

<p>The <code class="language-plaintext highlighter-rouge">STI</code> (<em>Set Interrupt Flag</em>) instruction is used at address <code class="language-plaintext highlighter-rouge">0x7C0D</code>. It can
activate masked interruptions (<em>flag</em> <code class="language-plaintext highlighter-rouge">IF</code> and offset 9 of the <code class="language-plaintext highlighter-rouge">FLAGS</code> register).
This <em>flag</em> doesn’t have any effect on non-maskable interruptions. Because
hardware interruptions are fully emulated, Miasm doesn’t contain (legitimately)
semantics for this instruction.</p>

<p>So we simply decided to ignore it by setting a breakpoint at its corresponding
address:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">jitter</span><span class="p">.</span><span class="n">add_breakpoint</span><span class="p">(</span><span class="mh">0x7C0D</span><span class="p">,</span> <span class="n">handle_sti</span><span class="p">)</span>
</code></pre></div></div>

<p>Then, we redirect the execution flow to the next instruction. Because this
instruction is only 1 byte long, a simple incrementation of the program
counter does the trick:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">handle_sti</span><span class="p">(</span><span class="n">jitter</span><span class="p">):</span>
    <span class="n">jitter</span><span class="p">.</span><span class="n">pc</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="bp">True</span>
</code></pre></div></div>

<h2 id="yippie-kay-yay-motherfucker-">Yippie kay yay motherfucker !</h2>

<p>Now that the useful handlers are implemented and the MBR code is loaded and
mapped in Miasm virtual machine, emulation of NotPetya can begin:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">jitter</span><span class="p">.</span><span class="n">init_run</span><span class="p">(</span><span class="n">stage1_addr</span><span class="p">)</span>
<span class="n">jitter</span><span class="p">.</span><span class="n">continue_run</span><span class="p">()</span>
</code></pre></div></div>

<p>If the <code class="language-plaintext highlighter-rouge">--verbose-bios-data</code> flag is set (see
<a href="#implementation">Implementation</a>), output of the script prints the content
of the various read and write operations on the disk.  For example, here is the
content of the second sector (of the 32 loaded sectors by the bootloader at
<code class="language-plaintext highlighter-rouge">0x8000</code>):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Extended read sectors, drive idx 0x0
  Read 1 sectors from sector 2
00000000: 50 FF 76 04 E8 91 0A 83  C4 0A E8 3B 07 CD 19 5E  P.v........;...^
00000010: C9 C3 6A 0E E8 39 07 5B  68 70 9C E8 C0 03 5B C3  ..j..9.[hp....[.
00000020: C8 04 04 00 56 6A 00 6A  01 6A 00 6A 20 8D 86 FC  ....Vj.j.j.j ...
00000030: FD 50 8A 46 06 50 E8 21  0A 83 C4 0C 6A 00 68 8E  .P.F.P.!....j.h.
[...]
</code></pre></div></div>

<p>The loaded code matchs stage 2. Also, one can easily see the
content loaded from sector 32:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Extended read sectors, drive idx 0x80
  Read 1 sectors from sector 32
00000000: 00 AA 92 E7 82 11 15 D3  20 96 A7 75 51 C0 36 08  ........ ..uQ.6.
00000010: E8 65 42 8C 73 9F 06 53  77 CB C5 95 60 C8 38 69  .eB.s..Sw...`.8i
00000020: 9B 0D A4 99 E0 13 12 30  79 31 4D 7A 37 31 35 33  .......0y1Mz7153
00000030: 48 4D 75 78 58 54 75 52  32 52 31 74 37 38 6D 47  HMuxXTuR2R1t78mG
00000040: 53 64 7A 61 41 74 4E 62  42 57 58 00 00 00 00 00  SdzaAtNbBWX.....
00000050: 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  ................
00000060: 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  ................
00000070: 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  ................
00000080: 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  ................
00000090: 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  ................
000000A0: 00 00 00 00 00 00 00 00  00 48 34 79 5A 73 77 56  .........H4yZswV
000000B0: 54 64 43 6B 43 77 55 68  72 31 4D 52 6D 4A 65 69  TdCkCwUhr1MRmJei
000000C0: 76 31 34 46 4B 39 6A 5A  6A 4D 36 36 4C 44 79 65  v14FK9jZjM66LDye
000000D0: 71 52 4C 64 6B 38 53 58  53 53 73 53 53 45 78 34  qRLdk8SXSSsSSEx4
000000E0: 44 51 57 4E 47 00 00 00  00 00 00 00 00 00 00 00  DQWNG...........
000000F0: 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  ................
[...]
000001F0: 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  ...............
</code></pre></div></div>

<p>This sector is where NotPetya stores data. According to the description
done in <a href="https://boutique.ed-diamond.com/numeros-deja-parus/1268-misc-93.html">MISC 805
n°93</a>, we can deduct its content :</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">0x00</code> is the encrypted disk flag,</li>
  <li><code class="language-plaintext highlighter-rouge">AA 92 E7 82 11 15 D3 20 96 A7 75 51 C0 36 08 E8 65 42 8C 73 9F 06 53 77 CB C5
95 60 C8 38 69</code> is the 32 bytes long Salsa20 key,</li>
  <li><code class="language-plaintext highlighter-rouge">0D A4 99 E0 13 12 30 79</code> is a 8 bytes long nonce,</li>
  <li>next data is the random string printed when the malware was
executed on Windows at the beginning.</li>
</ul>

<p>After the encryption is done by the bootloader, key and nonce are
erased from disk with 32 successive writings of zeros.</p>

<p>Moreover, we can see that sector 35 is used to store the number of total
encrypted MFT entries. For example, here is the content of sector 35 right
after the MFT header encryption:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Extended write sectors, drive idx 0x80
  Write 1 sectors at offset 35 (from memory at 0x5C74)
00000000: 01 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  ................
[...]
</code></pre></div></div>

<h2 id="retrieving-secrets-in-memory">Retrieving secrets in memory</h2>

<p>One of the advantages of emulation is the ability to easily analyze memory pages.
In our case, it is possible to retrieve the Salsa20 key used, even after
the MFT table has been encrypted (during the “false chkdsk”, see <a href="#notpetya">NotPetya</a>).</p>

<p>In fact, as explained in section <a href="#int-19h">INT 19h</a>; after the encryption is
over, the bootloader executes a “soft reboot” with the help of the interruption
<code class="language-plaintext highlighter-rouge">INT 19h</code>. It doesn’t reboot completely the computer therefore the BIOS is not
executed again. The data present in memory before the “soft reboot”
is not tampered with. If the computer goes through hard reboot or reset, there
would be great chances for the BIOS to overwrite data present on the
stack with its own, including the precious Salsa20 key.</p>

<p>So, if the computer has not been rebooted or reset, it is pretty interesting
to see if the Salsa20 key is still in memory. To do so, we simply read the key
written in sector 32 (see <a href="#yippie-kay-yay-motherfucker-">this section</a>) and
store its value. Then, we place a breakpoint on the instructions in
charge to show the ransom message, at address <code class="language-plaintext highlighter-rouge">0x85AF</code>:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">key</span> <span class="o">=</span> <span class="n">HD0</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="mi">32</span><span class="o">*</span><span class="n">SECTOR_LEN</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span> 
<span class="n">jitter</span><span class="p">.</span><span class="n">add_breakpoint</span><span class="p">(</span><span class="mh">0x85AF</span><span class="p">,</span> <span class="n">functools</span><span class="p">.</span><span class="n">partial</span><span class="p">(</span><span class="n">find_key_in_mem</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">))</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">find_key_in_mem</code> function browses the virtual machine memory to find the
key stored in the previous step:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">find_key_in_mem</span><span class="p">(</span><span class="n">jitter</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
    <span class="c1"># Find if the salsa20 key is still in memory!
</span>    <span class="n">mem</span> <span class="o">=</span> <span class="n">jitter</span><span class="p">.</span><span class="n">vm</span><span class="p">.</span><span class="n">get_all_memory</span><span class="p">()</span>
      <span class="k">print</span> <span class="o">&gt;&gt;</span><span class="n">sys</span><span class="p">.</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"</span><span class="se">\n</span><span class="s">[+] Looking for key %s in memory..."</span> <span class="o">%</span> <span class="n">key</span><span class="p">.</span><span class="n">encode</span><span class="p">(</span><span class="s">"hex"</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">addr</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">mem</span><span class="p">.</span><span class="n">iteritems</span><span class="p">():</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="s">'data'</span><span class="p">].</span><span class="n">find</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">print</span> <span class="o">&gt;&gt;</span><span class="n">sys</span><span class="p">.</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"[+] Key found at address %s!"</span> <span class="o">%</span> <span class="nb">hex</span><span class="p">(</span><span class="n">addr</span> <span class="o">+</span> <span class="n">idx</span><span class="p">)</span>
        <span class="k">break</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">print</span> <span class="o">&gt;&gt;</span><span class="n">sys</span><span class="p">.</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"[-] Key not found in memory!"</span>
    <span class="k">return</span> <span class="bp">True</span>
</code></pre></div></div>

<p>This operation can be activated in the script using <code class="language-plaintext highlighter-rouge">--hook=find_key</code> option, like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ python ./emulate-mbr.py --hook=find_key disk.raw

Repairing file system on C:
[... encryption happends here ...]

[+] Looking for key [your salsa20 key] in memory...
[+] Key found at address 0x674a!
</code></pre></div></div>

<p>To speed up the process, the <code class="language-plaintext highlighter-rouge">--skip-encryption</code> option can be used (see
<a href="#implementation">Implementation</a>). Be careful, even if this option is used, the
encryption flag in sector 32 is still set. The flag <code class="language-plaintext highlighter-rouge">--dry</code> prevents
this behaviour.</p>

<p>Because we know the address where the key is stored (<code class="language-plaintext highlighter-rouge">0x674A</code>), we can put a
breakpoint on a write access at this location, allowing us to know which part
of the bootloader writes this key:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">print_ip</span><span class="p">(</span><span class="n">jitter</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="nb">hex</span><span class="p">(</span><span class="n">jitter</span><span class="p">.</span><span class="n">pc</span><span class="p">))</span>
    <span class="k">return</span> <span class="bp">False</span>

<span class="n">jitter</span><span class="p">.</span><span class="n">exceptions_handler</span><span class="p">.</span><span class="n">callbacks</span><span class="p">[</span><span class="n">EXCEPT_BREAKPOINT_MEMORY</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">jitter</span><span class="p">.</span><span class="n">add_exception_handler</span><span class="p">(</span><span class="n">EXCEPT_BREAKPOINT_MEMORY</span><span class="p">,</span> <span class="n">print_ip</span><span class="p">)</span>
<span class="n">jitter</span><span class="p">.</span><span class="n">vm</span><span class="p">.</span><span class="n">add_memory_breakpoint</span><span class="p">(</span><span class="mh">0x674a</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">PAGE_WRITE</span><span class="p">)</span>
</code></pre></div></div>

<p>Because there is no ASLR or equivalent mechanism, this address will always be
the same!</p>

<h2 id="bootloader-modification-to-decrypt-the-mft">Bootloader modification to decrypt the MFT</h2>

<p>If we have a mechanism to write directly into the memory of the machine (for
example by using a PCI Express card <sup id="fnref:9" role="doc-noteref"><a href="#fn:9" class="footnote">8</a></sup>, or other interfaces like FireWire or
Thunderbolt <sup id="fnref:10" role="doc-noteref"><a href="#fn:10" class="footnote">9</a></sup>), it is possible to decrypt the MFT data. The attack
consists in patching the bootloader memory so that its uses the remaining key on
the stack. This section simulates this attack using Miasm.</p>

<p>To do so, we will inject some code at address <code class="language-plaintext highlighter-rouge">0x82A8</code>. This function checks
that the key entered is the expected one. Given that it has been erased from
the hard drive, and that the ransom text is completely random <sup id="fnref:11" role="doc-noteref"><a href="#fn:11" class="footnote">10</a></sup>, the
bootloader has in theory no way to know if the entered key is the right one. This
function will always return 0 (incorrect key). The injected code will copy the
key Salsa20 from the <code class="language-plaintext highlighter-rouge">0x674A</code> address to a specific location on the stack, so
that the decryption function at <code class="language-plaintext highlighter-rouge">0x835A</code> will use this key.  We will then jump
on this function.</p>

<p>Associated assembly code is the following:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    ; Save registers on the stack
    PUSHA
    LEA DI, WORD PTR [BP-0x44]
    LEA BX, WORD PTR [key_addr]
    XOR CX,CX

    ; Copy the key that remains on the stack to [bp-0x44]
loop:
    MOV EAX, DWORD PTR [BX]
    MOV DWORD PTR [DI], EAX 
    ADD DI, 4
    ADD BX, 4
    INC CX
    CMP CX,8
    JNZ loop

    ; Restore previously saved registers
    POPA
    ; Jump on the decryption function (CS:OFFSET =&gt; using an absolute address)
    JMP 0000:0x835A
</code></pre></div></div>

<p>We use Miasm to assemble it using the following function:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">asm_shellcode</span><span class="p">(</span><span class="n">asm</span><span class="p">,</span> <span class="n">labels</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
    <span class="n">machine</span> <span class="o">=</span> <span class="n">Machine</span><span class="p">(</span><span class="s">"x86_16"</span><span class="p">)</span>
    <span class="n">symbol_pool</span> <span class="o">=</span> <span class="n">asmblock</span><span class="p">.</span><span class="n">AsmSymbolPool</span><span class="p">()</span>

    <span class="c1"># Assemble
</span>    <span class="n">blocks</span><span class="p">,</span> <span class="n">symbol_pool</span> <span class="o">=</span> <span class="n">parse_asm</span><span class="p">.</span><span class="n">parse_txt</span><span class="p">(</span><span class="n">machine</span><span class="p">.</span><span class="n">mn</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="n">asm</span><span class="p">,</span> <span class="n">symbol_pool</span><span class="p">)</span>

    <span class="c1"># Set custom labels
</span>    <span class="k">if</span> <span class="ow">not</span> <span class="n">labels</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span><span class="n">value</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">.</span><span class="n">iteritems</span><span class="p">():</span>
            <span class="n">sym</span> <span class="o">=</span> <span class="n">symbol_pool</span><span class="p">.</span><span class="n">getby_name</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="n">symbol_pool</span><span class="p">.</span><span class="n">set_offset</span><span class="p">(</span><span class="n">sym</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="c1"># Resolve all the labels
</span>    <span class="n">patches</span> <span class="o">=</span> <span class="n">asmblock</span><span class="p">.</span><span class="n">asm_resolve_final</span><span class="p">(</span><span class="n">machine</span><span class="p">.</span><span class="n">mn</span><span class="p">,</span>
                                         <span class="n">blocks</span><span class="p">,</span>
                                         <span class="n">symbol_pool</span><span class="p">)</span>

    <span class="c1"># Patch the final code with the label values
</span>    <span class="n">shellcode</span> <span class="o">=</span> <span class="n">StrPatchwork</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">offset</span><span class="p">,</span> <span class="n">raw</span> <span class="ow">in</span> <span class="n">patches</span><span class="p">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">shellcode</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span> <span class="o">=</span> <span class="n">raw</span>
    <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">shellcode</span><span class="p">)</span>
</code></pre></div></div>

<p>Let’s take a look at this function. The code is first assembled using an x86
16-bit assembler.  Given labels are then associated to concrete values using the <code class="language-plaintext highlighter-rouge">symbol_pool.set_offset</code> function.  Remaining labels (in our case
<code class="language-plaintext highlighter-rouge">loop</code>) are resolved with the <code class="language-plaintext highlighter-rouge">asmblock.asm_resolve_final</code> function, which
returns assembly code for each block.  We finally use the <code class="language-plaintext highlighter-rouge">StrPatchwork</code>
function to assemble the final “shellcode”.</p>

<p>The <code class="language-plaintext highlighter-rouge">read_key_and_patch</code> function loads the key in memory, dumps it and writes
the freshly assembled code in memory:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">read_key_and_patch</span><span class="p">(</span><span class="n">jitter</span><span class="p">):</span>
    <span class="c1"># Key is still in the stack, at 0x674A. You can find this value by activating the
</span>    <span class="c1"># find_key_in_mem breakpoint!
</span>    <span class="n">key_addr</span> <span class="o">=</span> <span class="mh">0x674A</span>
    <span class="n">key</span> <span class="o">=</span> <span class="n">jitter</span><span class="p">.</span><span class="n">vm</span><span class="p">.</span><span class="n">get_mem</span><span class="p">(</span><span class="n">key_addr</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>
    <span class="k">print</span> <span class="o">&gt;&gt;</span><span class="n">sys</span><span class="p">.</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"</span><span class="se">\n</span><span class="s">[+] Key from memory: %s"</span> <span class="o">%</span> <span class="n">key</span><span class="p">.</span><span class="n">encode</span><span class="p">(</span><span class="s">"hex"</span><span class="p">)</span>

    <span class="c1"># Assemble our "shellcode" thanks to Miasm!
</span>    <span class="n">shellcode</span> <span class="o">=</span> <span class="s">"""
...
    """</span>
    <span class="n">shellcode</span> <span class="o">=</span> <span class="n">asm_shellcode</span><span class="p">(</span><span class="n">shellcode</span><span class="p">,</span> <span class="p">{</span><span class="s">"key_addr"</span><span class="p">:</span> <span class="n">key_addr</span><span class="p">})</span>

    <span class="c1"># Patch the bootloader in memory to decrypt using the key
</span>    <span class="n">jitter</span><span class="p">.</span><span class="n">vm</span><span class="p">.</span><span class="n">set_mem</span><span class="p">(</span><span class="mh">0x82A8</span><span class="p">,</span> <span class="n">shellcode</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">True</span>
</code></pre></div></div>

<p>The remaining thing to do is to put a breakpoint at the same address as in section
<a href="#retrieving-secrets-in-memory">Retrieving secrets in memory</a> (<code class="language-plaintext highlighter-rouge">0x85AF</code>) to call this function:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">jitter</span><span class="p">.</span><span class="n">add_breakpoint</span><span class="p">(</span><span class="mh">0x85AF</span><span class="p">,</span> <span class="n">read_key_and_patch</span><span class="p">)</span>
</code></pre></div></div>

<p>Everything is now set up. When the bootloader asks for the decryption key, user will just have to press <code class="language-plaintext highlighter-rouge">enter</code>.
<code class="language-plaintext highlighter-rouge">--hook=patch_bootloader</code> flag of the
<code class="language-plaintext highlighter-rouge">emulate_mbr</code> script performs this attack.</p>

<p>It is worth mentioning that <a href="https://airbus-seclab.github.io/ilo/Whitepaper-Defeating_NotPetya_from_your_iLO4-guinet-perigaud-gazet-czarny.pdf">we actually tried
this</a>
at <a href="https://synacktiv.com">Synacktiv</a>’s headquarters using vulnerabilities in
HP’s iLO4 to gather the Salsa20 key from memory, patch the bootloader and
decrypt MFT data.</p>

<h2 id="encryption-keystream-study">Encryption keystream study</h2>

<p>The encryption algorithm used is Salsa20 stream cipher. The general
principle is: a random data flow based on a key - commonly called the
keystream - is generated, and this stream is XORed with the data which will be
encrypted. An advantage of stream ciphers is that the data to be encrypted do not
need to be padded. On the other hand, one needs to be careful not to use the
same parts of this stream twice.</p>

<p class="figure"><img src="/assets/2020-08-29-miasm-bootloader/s20-expand.png" alt="" width="400px" class="center-image" />
Data encryption with Salsa20</p>

<p>We can verify this using Miasm, by looking at the data before and after
encryption, and by showing their XOR difference.</p>

<p>In order to do this, we already know how to put breakpoints. The beginning of
the encryption function is at address <code class="language-plaintext highlighter-rouge">0x9798</code>, and the end at address
<code class="language-plaintext highlighter-rouge">0x9877</code>. We are going to out the first breakpoint just after ‘enter<code class="language-plaintext highlighter-rouge">
instruction, and the second just before </code>leave` statement, in order to have
the stack properly aligned to recover data before and after encryption. The
associated code is the following:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">_last_buf</span> <span class="o">=</span> <span class="bp">None</span>
<span class="k">def</span> <span class="nf">encrypt_start</span><span class="p">(</span><span class="n">jitter</span><span class="p">,</span> <span class="n">options</span><span class="p">):</span>
    <span class="k">global</span> <span class="n">_last_buf</span>
    <span class="n">buf_ptr</span>  <span class="o">=</span> <span class="n">upck16</span><span class="p">(</span><span class="n">jitter</span><span class="p">.</span><span class="n">vm</span><span class="p">.</span><span class="n">get_mem</span><span class="p">((</span><span class="n">jitter</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">SS</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="n">jitter</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">BP</span> <span class="o">+</span> <span class="mh">0xC</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">buf_size</span> <span class="o">=</span> <span class="n">upck16</span><span class="p">(</span><span class="n">jitter</span><span class="p">.</span><span class="n">vm</span><span class="p">.</span><span class="n">get_mem</span><span class="p">((</span><span class="n">jitter</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">SS</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="n">jitter</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">BP</span> <span class="o">+</span> <span class="mh">0xE</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">_last_buf</span> <span class="o">=</span> <span class="n">jitter</span><span class="p">.</span><span class="n">vm</span><span class="p">.</span><span class="n">get_mem</span><span class="p">((</span><span class="n">jitter</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">DS</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="n">buf_ptr</span><span class="p">,</span> <span class="n">buf_size</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">True</span>

<span class="k">def</span> <span class="nf">encrypt_end</span><span class="p">(</span><span class="n">jitter</span><span class="p">,</span> <span class="n">options</span><span class="p">):</span>
    <span class="k">global</span> <span class="n">_last_buf</span>
    <span class="n">buf_ptr</span>  <span class="o">=</span> <span class="n">upck16</span><span class="p">(</span><span class="n">jitter</span><span class="p">.</span><span class="n">vm</span><span class="p">.</span><span class="n">get_mem</span><span class="p">((</span><span class="n">jitter</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">SS</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="n">jitter</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">BP</span> <span class="o">+</span> <span class="mh">0xC</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">buf_size</span> <span class="o">=</span> <span class="n">upck16</span><span class="p">(</span><span class="n">jitter</span><span class="p">.</span><span class="n">vm</span><span class="p">.</span><span class="n">get_mem</span><span class="p">((</span><span class="n">jitter</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">SS</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="n">jitter</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">BP</span> <span class="o">+</span> <span class="mh">0xE</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">encr_buf</span> <span class="o">=</span> <span class="n">jitter</span><span class="p">.</span><span class="n">vm</span><span class="p">.</span><span class="n">get_mem</span><span class="p">((</span><span class="n">jitter</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">DS</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="n">buf_ptr</span><span class="p">,</span> <span class="n">buf_size</span><span class="p">)</span>
    <span class="n">keystream</span> <span class="o">=</span> <span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="nb">chr</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">^</span><span class="nb">ord</span><span class="p">(</span><span class="n">b</span><span class="p">))</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">_last_buf</span><span class="p">,</span><span class="n">encr_buf</span><span class="p">)).</span><span class="n">encode</span><span class="p">(</span><span class="s">"hex"</span><span class="p">)</span>
    <span class="n">keystream</span> <span class="o">=</span> <span class="s">' '</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">keystream</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">4</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">keystream</span><span class="p">),</span><span class="mi">4</span><span class="p">))</span>
    <span class="k">print</span> <span class="o">&gt;&gt;</span><span class="n">sys</span><span class="p">.</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Keystream for next 2 sectors: %s"</span> <span class="o">%</span> <span class="n">keystream</span>
    <span class="k">return</span> <span class="bp">True</span>

<span class="n">jitter</span><span class="p">.</span><span class="n">add_breakpoint</span><span class="p">(</span><span class="mh">0x979C</span><span class="p">,</span> <span class="n">functools</span><span class="p">.</span><span class="n">partial</span><span class="p">(</span><span class="n">encrypt_start</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="n">options</span><span class="p">))</span>
<span class="n">jitter</span><span class="p">.</span><span class="n">add_breakpoint</span><span class="p">(</span><span class="mh">0x9876</span><span class="p">,</span> <span class="n">functools</span><span class="p">.</span><span class="n">partial</span><span class="p">(</span><span class="n">encrypt_end</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="n">options</span><span class="p">))</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">--dump-keystream</code> flag of the <code class="language-plaintext highlighter-rouge">emulate_mbr</code> script enables this.</p>

<p>By looking at the output, we can see that between two sectors
(<code class="language-plaintext highlighter-rouge">2*512</code> bytes), the keystream is only shifted by two bytes, instead of the
normally required <code class="language-plaintext highlighter-rouge">2*512</code> bytes. This shift is schematized in the image below:</p>

<p><img src="/assets/2020-08-29-miasm-bootloader/keystream.png" alt="" width="400px" class="center-image" /></p>

<p>We can also see that on a screenshot of the output of the <code class="language-plaintext highlighter-rouge">emulate_mbr</code> script
below:</p>

<p class="figure"><img src="/assets/2020-08-29-miasm-bootloader/keystream_screenshot.png" alt="" />
Screenshot of the keystream</p>

<p>Thus, parts of the keystream are reused between sectors, which may help to
recover some of its original data.</p>

<p>Indeed, if we consider <code class="language-plaintext highlighter-rouge">p</code> to be the clear text,<code class="language-plaintext highlighter-rouge"> k</code> the keystream and <code class="language-plaintext highlighter-rouge">c</code> the
encrypted text, then the encryption function <code class="language-plaintext highlighter-rouge">E</code> is defined as<code class="language-plaintext highlighter-rouge"> E (p) = p xor k
= c</code>. A part of the MFT structures being invariant and known, it is therefore
possible, in two sectors, to find part of the keystream used for these two
sectors. This one is reused for the two following sectors by being simply
shifted by two bytes, so some of the clear text from these other areas can be
found.</p>

<p>This vulnerability in the Salsa20 implementation of the bootloader has been
exploited by <a href="https://www.crowdstrike.com/blog/full-decryption-systems-encrypted-petya-notpetya/">CrowdStrike</a> to recover a large portion of MFT’s
original data (between 98.10% and 99.97% depending on the method).</p>

<h1 id="conclusion">Conclusion</h1>

<p>Emulation of the NotPetya bootloader code allows the verification of various
assumptions and the understanding, in a very tangible way, of the different
steps related to the encryption of MFT entries. In addition, it allows to
easily find the bias in the Salsa20 keystream implementation (without having
to statically reverse the algorithm), or to simulate the recovery of the key, which
remains in memory after the encryption.</p>

<p>This article only shows a small subset of Miasm’s possibilities, and
we hope that the approach adopted in this article will encourage uninitiated
readers to try and play with it :).</p>

<h1 id="acknowledgments">Acknowledgments</h1>

<p>We would like to thank gapz for his initial encouragement. Big thanks also to
Camille Mougey and Fabrice Desclaux for their help and thorough reviews of this
article! Thanks to Thomas Chauchefoin and zerk for their comments, and to Yseult for her help with the English translation.</p>

<h1 id="appendix-application-using-vulnerabilities-in-hp-ilo-4">Appendix: application using vulnerabilities in HP iLO 4</h1>

<p>With Alexandre Gazet &amp; <a href="https://twitter.com/0xf4b">Fabien Perigaud</a>, we spent
some time in <a href="https://synacktiv.com">Synacktiv</a>’s offices to combine the
attacks described in this article with <a href="https://github.com/airbus-seclab/ilo4_toolbox">vulnerabilities they
found</a> with <a href="https://twitter.com/_Sn0rkY">Joffrey
Czarny</a> on HP iLO 4’s management engine. These
vulnerabilities allowed us to read and write the memory of an infected server
stuck at NotPetya’s bootloader stage, so that we were able to recover the
encryption key and patch the bootloader in order to decrypt the MFT.</p>

<p>A full write up of the experiment can be read on <a href="https://airbus-seclab.github.io/ilo/Whitepaper-Defeating_NotPetya_from_your_iLO4-guinet-perigaud-gazet-czarny.pdf">Airbus seclab
website</a>.</p>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p><a href="https://fr.wikipedia.org/wiki/Master_File_Table">https://fr.wikipedia.org/wiki/Master_File_Table</a> <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p><a href="https://shasaurabh.blogspot.fr/2017/07/debugging-mbr-ida-pro-and-bochs-emulator.html">https://shasaurabh.blogspot.fr/2017/07/debugging-mbr-ida-pro-and-bochs-emulator.html</a> <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p><a href="https://www.sstic.org/2012/presentation/miasm_framework_de_reverse_engineering/">https://www.sstic.org/2012/presentation/miasm_framework_de_reverse_engineering/</a> <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:4" role="doc-endnote">
      <p><a href="https://fr.wikipedia.org/wiki/Mode_r%C3%A9el">https://fr.wikipedia.org/wiki/Mode_r%C3%A9el</a> <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:5" role="doc-endnote">
      <p><a href="https://docs.microsoft.com/en-us/windows/wsl/install-win10">https://docs.microsoft.com/en-us/windows/wsl/install-win10</a> <a href="#fnref:5" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:7" role="doc-endnote">
      <p><a href="https://wiki.osdev.org/ATA_in_x86_RealMode_(BIOS))">https://wiki.osdev.org/ATA_in_x86_RealMode_(BIOS))</a> <a href="#fnref:7" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:8" role="doc-endnote">
      <p><a href="http://webpages.charter.net/danrollins/techhelp/0243.HTM">http://webpages.charter.net/danrollins/techhelp/0243.HTM</a> <a href="#fnref:8" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:9" role="doc-endnote">
      <p><a href="https://www.sstic.org/media/SSTIC2011/SSTIC-actes/attaques_dma_peer-to-peer_et_contremesures/SSTIC2011-Article-attaques_dma_peer-to-peer_et_contremesures-lone-sang_duflot_nicomette_deswarte.pdf">https://www.sstic.org/media/SSTIC2011/SSTIC-actes/attaques_dma_peer-to-peer_et_contremesures/SSTIC2011-Article-attaques_dma_peer-to-peer_et_contremesures-lone-sang_duflot_nicomette_deswarte.pdf</a> <a href="#fnref:9" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:10" role="doc-endnote">
      <p><a href="https://github.com/carmaa/inception">https://github.com/carmaa/inception</a> <a href="#fnref:10" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:11" role="doc-endnote">
      <p><a href="https://www.crowdstrike.com/blog/petrwrap-ransomware-technical-analysis-triple-threat-file-encryption-mft-encryption-credential-theft/">https://www.crowdstrike.com/blog/petrwrap-ransomware-technical-analysis-triple-threat-file-encryption-mft-encryption-credential-theft/</a> <a href="#fnref:11" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>

  
</article>


<hr class="dingbat related" />




  
     



  

  
  

  
    


  <aside class="related mb4" role="complementary">  <h2 class="hr-bottom">Related Posts</h2>  <ul class="related-posts">                  <li class="h4">  <a href="/blog/2020/11/22/donjon-ctf-sssgx.html" class="flip-title"><span>Donjon CTF SSSGX write-up: linear functions strike back</span></a>  <time class="faded fine" datetime="2020-11-22T00:00:00+01:00">22 Nov 2020</time></li>                        <li class="h4">  <a href="/blog/2020/10/05/dragonffi-library-lifting.html" class="flip-title"><span>Lifting shared libraries & PIE binaries with DragonFFI (and LIEF)</span></a>  <time class="faded fine" datetime="2020-10-05T00:00:00+02:00">05 Oct 2020</time></li>            </ul></aside>

  

  
  

  
    

  


  
<footer class="content" role="contentinfo">
  <hr/>
  
    <p><small class="copyright">© 2020. All rights reserved.
</small></p>
  
  
    <p><small>Powered by <a class="external" href="https://hydejack.com/">Hydejack</a> v<span id="_version">9.0.4</span></small></p>
  <hr class="sr-only"/>
</footer>


</main>

  <hy-drawer
  id="_drawer"
  class=""
  side="left"
  threshold="10"
  noscroll
  
>
  <header id="_sidebar" class="sidebar" role="banner">
    




<div class="sidebar-bg " style="background-color:rgb(0,0,0);"></div>

    <div class="sidebar-sticky">
  <nav class="sidebar-nav heading" role="navigation">
    <span class="sr-only">Navigation:</span>
<ul>
  
    
      
      <li>
        <a
          id="_drawer--opened"
          href="/blog/"
          class="sidebar-nav-item"
          
        >
          Blog
        </a>
      </li>
    
      
      <li>
        <a
          
          href="/software/"
          class="sidebar-nav-item"
          
        >
          Software
        </a>
      </li>
    
      
      <li>
        <a
          
          href="/pubs/"
          class="sidebar-nav-item"
          
        >
          Publications
        </a>
      </li>
    
  
</ul>

  </nav>

  
  <div class="sidebar-social">
    <span class="sr-only">Social</span>
<ul>
  
    
    
      



  

  
  
  
  

  

  

  <li>
    <a href="https://twitter.com/adriengnt" title="Twitter" class="no-mark-external">
      <span class="icon-twitter"></span>
      <span class="sr-only">Twitter</span>
    </a>
  </li>


    

    
    
      



  

  
  
  
  

  

  

  <li>
    <a href="https://github.com/aguinet" title="GitHub" class="no-mark-external">
      <span class="icon-github"></span>
      <span class="sr-only">GitHub</span>
    </a>
  </li>


    

    
    
  
</ul>

  </div>
</div>

  </header>
</hy-drawer>
<hr class="sr-only" hidden />

</hy-push-state>


  <!--[if gt IE 10]><!---->
  <script nomodule>!function(){var e=document.createElement("script");if(!("noModule"in e)&&"onbeforeload"in e){var t=!1;document.addEventListener("beforeload",function(n){if(n.target===e)t=!0;else if(!n.target.hasAttribute("nomodule")||!t)return;n.preventDefault()},!0),e.type="module",e.src=".",document.head.appendChild(e),e.remove()}}();
</script>
  <script src="/assets/js/hydejack-9.0.4.js" type="module"></script>
  <script src="/assets/js/LEGACY-hydejack-9.0.4.js" nomodule defer></script>
  

  

<!--<![endif]-->
  



<div hidden>
  
  <h2 class="sr-only">Templates:</h2>

  <template id="_animation-template">
  <div class="animation-main fixed-top">
    <div class="content">
      <div class="page"></div>
    </div>
  </div>
</template>

  <template id="_loading-template">
  <div class="loading nav-btn fr">
    <span class="sr-only">Loading…</span>
    <span class="icon-cog"></span>
  </div>
</template>

  <template id="_error-template">
  <div class="page">
    <h1 class="page-title">Error</h1>
    
    
    <p class="lead">
      Sorry, an error occurred while loading: <a class="this-link" href=""></a>.
    </p>
  </div>
</template>

  <template id="_forward-template">
  <button id="_forward" class="forward nav-btn no-hover">
    <span class="sr-only">Forward</span>
    <span class="icon-arrow-right2"></span>
  </button>
</template>

  <template id="_back-template">
  <button id="_back" class="back nav-btn no-hover">
    <span class="sr-only">Back</span>
    <span class="icon-arrow-left2"></span>
  </button>
</template>

  <template id="_permalink-template">
  <a href="#" class="permalink">
    <span class="sr-only">Permalink</span>
    <span class="content-hash"></span>
  </a>
</template>

</div>


</body>
</html>
